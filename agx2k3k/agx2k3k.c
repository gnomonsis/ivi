/********************************************************************************
 *  Copyright 2011-2016, National Instruments, Corporation.  All Rights Reserved. *
 ********************************************************************************/
/*****************************************************************************
 *  Agilent 2000 3000 3000T and 4000 X-Series Oscilloscopes Instrument Driver
 *  LabWindows/CVI Instrument Driver
 *  Original Release: 24. June 2011
 *  By: Chenchen Zhou, National Instruments
 *
 *  Modification History:
 *
 *  2011-06-24 - Instrument Driver Created.
 *  2011-12-05 - [czhou] Update the error checking code in
 *                       agx2k3k_ReadWaveformMeasurement function.
 *  2012-09-01 - [hfeng] Add support for new models:MSO-X 3102A, MSO-X 3104A,
 *                       DSO-X 3102A, DSO-X 3104A
 *                       New functionality in power group, search group, demo
 *                       group, trigger group, function group, Serial Bus group,
 *                       marker group, WGEN group
 *  2013-03-30 - [hchen] Add support for Agilent InfiniiVision 4000 X-Series
 *                       Oscilloscopes.
 *                       New functionality in acquisition group, power group,
 *                       search group, math configuration group, marker group,
 *                       trigger group, measurements group, function group,
 *                       Serial Bus group, waveform generator group, WGEN group,
 *                       digital voltmeter group.
 *	2013-11-07 - [yanliu] Fix CAR 430719
 *						  Modified agx2k3k_InitAttributes function for the
 *						  following attributes:
 *							- AGX2K3K_ATTR_DVM_ENABLED
 *							- AGX2K3K_ATTR_DVM_AUTO_RANGE_ENABLED
 *							- AGX2K3K_ATTR_DVM_MODE
 *							- AGX2K3K_ATTR_DVM_ANALOG_SOURCE
 *							- AGX2K3K_ATTR_DVM_CURRENT
 *							- AGX2K3K_ATTR_DVM_FREQUENCY
 *	2015-09-07 - [holi]
 *						 1. Added support for 3000T X-Series and updated 4000X-Series and updated driver to comply with IVI-2014 generation.
 *						 MSO-X 3012T, MSO-X 3022T, MSO-X 3032T, MSO-X 3052T, MSO-X 3102T, MSO-X 3014T, MSO-X 3024T, MSO-X 3034T, MSO-X 3054T, MSO-X 3104T,
 *						 DSO-X 3012T, DSO-X 3022T, DSO-X 3032T, DSO-X 3052T, DSO-X 3102T, DSO-X 3014T, DSO-X 3024T, DSO-X 3034T, DSO-X 3054T, DSO-X 3104T
 *						 Added functions:
 *						 agx2k3k_ConfigureMathSmoothPointsNumber
 *						 agx2k3k_ConfigureMathFFTFrequency
 *						 agx2k3k_ConfigureChannelProbeTek
 *						 agx2k3k_ConfigureTriggerZone
 *						 agx2k3k_ConfigureTriggerZonePlacement
 *						 agx2k3k_ReadTriggerZoneValidity
 *						 agx2k3k_AutoSetupTriggerLevel
 *						 agx2k3k_ConfigureLINTriggerSymbolic
 *						 agx2k3k_ConfigureLINDisplay
 *						 agx2k3k_ConfigureSENT
 *						 agx2k3k_ConfigureSENTTrigger
 *						 agx2k3k_ConfigureSENTSignal
 *						 agx2k3k_ConfigureCANFDBus
 *						 agx2k3k_ConfigureCANDisplay
 *						 agx2k3k_ConfigureCANTriggerPattern
 *						 agx2k3k_ConfigureCANTriggerSymbolic
 *						 agx2k3k_EnableCANTriggerIDFilter
 *						 agx2k3k_ConfigureGeneratorOutputMode
 *						 agx2k3k_ConfigureGeneratorTrackingPhase
 *						 agx2k3k_ApplyPowerControlResponse
 *						 agx2k3k_ConfigurePowerControlResponse
 *						 agx2k3k_ConfigurePowerAnalysisEfficiency
 *						 agx2k3k_ConfigurePowerAnalysisHarmonics
 *						 agx2k3k_RecallSerialBusDataFromFile
 *						 agx2k3k_SaveAnalysisResults
 *						 agx2k3k_SaveUSBSignalQualityTestResults
 *						 agx2k3k_SaveMultiChanWaveformData
 *						 agx2k3k_ReadMarkerDYDX
 *						 agx2k3k_ReadSBusErrorCount
 *						 agx2k3k_ConfigureSearchEventNumber
 *						 agx2k3k_ConfigureSearchPeak
 *						 agx2k3k_ConfigureSearchSerialCAN
 *						 agx2k3k_ConfigureSearchSerialLIN
 *						 agx2k3k_ConfigureSearchSerialSENT
 *						 agx2k3k_RunUSBComplianceTest
 *						 agx2k3k_AutoSetupUSBComplianceTest
 *						 agx2k3k_ConfigureUSBComplianceTest
 *						 agx2k3k_ConfigureUSBComplianceSource
 *						 agx2k3k_ClearFFTEvaluatedWaveforms
 *						 agx2k3k_ConfigureFFTAverageCount
 *						 agx2k3k_ConfigureFFT
 *						 agx2k3k_ConfigureFFTFrequency
 *						 agx2k3k_ConfigureFFTSource
 *						 agx2k3k_ConfigureFFTWindowing
 *						 agx2k3k_ConfigureFFTDisplayMode
 *						 agx2k3k_EnableCounter
 *						 agx2k3k_ResetTotalizerCount
 *						 agx2k3k_ConfigureCounter
 *						 agx2k3k_ConfigureCounterTotalizer
 *						 agx2k3k_ReadCounterValue
 *
 *						 Modified functions:
 *						 agx2k3k_ConfigureCANTrigger
 *						 agx2k3k_ConfigureLINTrigger
 *						 agx2k3k_ConfigureDemoFunction
 *						 agx2k3k_ConfigureMathFunction
 *						 agx2k3k_AutoSetupPowerSignal
 *						 agx2k3k_ReadWaveformMeasurement
 *					     agx2k3k_FetchWaveformMeasurementSafe
 *					     agx2k3k_ReadWaveformMeasurement
 *					     agx2k3k_ConfigureLINBus
 *						 agx2k3k_ConfigureSPIBus
 *					     agx2k3k_ConfigureSearchSerialA429
 *					     agx2k3k_ConfigureSBusFlexrayTrigger
 *						 agx2k3kAttrFlexrayTriggerEventBassId_WriteCallback
 *                       agx2k3kAttrFlexrayTriggerFrameId_WriteCallback
 *
 *					     Added attributes:
 *					     AGX2K3K_ATTR_CHANNEL_PROBE_TEK_MODEL
 *					     AGX2K3K_ATTR_SBUS_CAN_DISPLAY
 *					     AGX2K3K_ATTR_SBUS_CAN_FD_SAMPLE_POINT
 *					     AGX2K3K_ATTR_SBUS_CAN_SIGNAL_FD_BAUDRATE
 *					     AGX2K3K_ATTR_SBUS_CAN_TRIGGER_IDFILTER_ENABLED
 *					     AGX2K3K_ATTR_SBUS_CAN_TRIGGER_PATTERN_DATA_DLC
 *					     AGX2K3K_ATTR_SBUS_CAN_TRIGGER_PATTERN_DATA_START
 *					     AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_MESSAGE
 *					     AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_SIGNAL
 *					     AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_VALUE
 *					     AGX2K3K_ATTR_SBUS_LIN_DISPLAY
 *					     AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_FRAME
 *					     AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_SIGNAL
 *					     AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_VALUE
 *					     AGX2K3K_ATTR_SBUS_SENT_CLOCK
 *					     AGX2K3K_ATTR_SBUS_SENT_CRC
 *					     AGX2K3K_ATTR_SBUS_SENT_DISPLAY
 *					     AGX2K3K_ATTR_SBUS_SENT_FORMAT
 *					     AGX2K3K_ATTR_SBUS_SENT_IDLE
 *					     AGX2K3K_ATTR_SBUS_SENT_LENGTH
 *					     AGX2K3K_ATTR_SBUS_SENT_PPULSE_ENABLED
 *					     AGX2K3K_ATTR_SBUS_SENT_SIGNAL_DISPLAY_ENABLED
 *					     AGX2K3K_ATTR_SBUS_SENT_SIGNAL_LENGTH
 *					     AGX2K3K_ATTR_SBUS_SENT_SIGNAL_MULTIPLIER
 *					     AGX2K3K_ATTR_SBUS_SENT_SIGNAL_OFFSET
 *					     AGX2K3K_ATTR_SBUS_SENT_SIGNAL_ORDER
 *					     AGX2K3K_ATTR_SBUS_SENT_SIGNAL_START
 *					     AGX2K3K_ATTR_SBUS_SENT_TRIGGER_TOLERANCE
 *					     AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_LENGTH
 *					     AGX2K3K_ATTR_SBUS_SENT_TRIGGER
 *					     AGX2K3K_ATTR_SBUS_SENT_TOLERANCE
 *					     AGX2K3K_ATTR_SBUS_SENT_SOURCE
 *					     AGX2K3K_ATTR_SBUS_SENT_TRIGGER_FAST_DATA
 *					     AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_DATA
 *					     AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_ID
 *					     AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME
 *					     AGX2K3K_ATTR_MATH_SMOOTH_POINTS
 *					     AGX2K3K_ATTR_MATH_FFT_FREQUENCY_START
 *					     AGX2K3K_ATTR_MATH_FFT_FREQUENCY_STOP
 *					     AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_CURSOR_ENABLED
 *					     AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_MASK_ENABLED
 *					     AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_MEASUREMENT_ENABLED
 *					     AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_SEARCH_ENABLED
 *					     AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_SEGMENTED_ENABLED
 *					     AGX2K3K_ATTR_SEARCH_EVENT
 *					     AGX2K3K_ATTR_SEARCH_PEAK_EXCURSION
 *					     AGX2K3K_ATTR_SEARCH_PEAK_MAXIMUM_PEAKS
 *					     AGX2K3K_ATTR_SEARCH_PEAK_THRESHOLD
 *					     AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_MESSAGE
 *					     AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_SIGNAL
 *					     AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_VALUE
 *					     AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_FRAME
 *					     AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_SIGNAL
 *					     AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_VALUE
 *					     AGX2K3K_ATTR_SEARCH_SERIAL_SENT_MODE
 *					     AGX2K3K_ATTR_SEARCH_SERIAL_SENT_SLOW_DATA
 *					     AGX2K3K_ATTR_SEARCH_SERIAL_SENT_SLOW_ID
 *					     AGX2K3K_ATTR_SEARCH_PEAK_SOURCE
 *					     AGX2K3K_ATTR_SEARCH_SERIAL_SENT_FAST_DATA
 *					     AGX2K3K_ATTR_TRIGGER_ZONE_SOURCE
 *					     AGX2K3K_ATTR_TRIGGER_ZONE_STATE_ENABLED
 *					     AGX2K3K_ATTR_TRIGGER_ZONE_MODE
 *					     AGX2K3K_ATTR_MULTICHANNEL_TRIGGER_ZONE_STATE_ENABLED
 *					     AGX2K3K_ATTR_POWER_CLRESPONSE_FREQUENCY_START
 *					     AGX2K3K_ATTR_POWER_CLRESPONSE_FREQUENCY_STOP
 *					     AGX2K3K_ATTR_POWER_CLRESPONSE_YMAXIMUM
 *					     AGX2K3K_ATTR_POWER_CLRESPONSE_YMINIMUM
 *					     AGX2K3K_ATTR_POWER_EFFICIENCY_TYPE
 *					     AGX2K3K_ATTR_POWER_HARMONICS_REAL_POWER_TYPE
 *					     AGX2K3K_ATTR_POWER_HARMONICS_REAL_POWER_VALUE
 *					     AGX2K3K_ATTR_WAVEGEN_OUTPUT_MODE
 *					     AGX2K3K_ATTR_WAVEGEN_TRACK_PHASE
 *					     AGX2K3K_ATTR_COMPLIANCE_USB_HUBS
 *					     AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_ADJACENT
 *					     AGX2K3K_ATTR_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE
 *					     AGX2K3K_ATTR_COMPLIANCE_USB_TEST_CONNECTION
 *					     AGX2K3K_ATTR_COMPLIANCE_USB_TEST_TYPE
 *					     AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DIFFERENTIAL
 *					     AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DMINUS
 *					     AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DPLUS
 *					     AGX2K3K_ATTR_COUNTER_ENABLE
 *					     AGX2K3K_ATTR_COUNTER_MODE
 *					     AGX2K3K_ATTR_COUNTER_NUMBER_OF_DIGITS
 *					     AGX2K3K_ATTR_COUNTER_SOURCE
 *					     AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_ENABLED
 *					     AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_POLARITY
 *					     AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_SOURCE
 *					     AGX2K3K_ATTR_COUNTER_TOTALIZE_SLOPE
 *					     AGX2K3K_ATTR_FFT_AVERAGE_COUNT
 *					     AGX2K3K_ATTR_FFT_FREQUENCY_CENTER
 *					     AGX2K3K_ATTR_FFT_DISPLAY_ENABLED
 *					     AGX2K3K_ATTR_FFT_DISPLAY_MODE
 *					     AGX2K3K_ATTR_FFT_FREQUENCY_START
 *					     AGX2K3K_ATTR_FFT_FREQUENCY_STOP
 *					     AGX2K3K_ATTR_FFT_VERTICAL_OFFSET
 *					     AGX2K3K_ATTR_FFT_VERTICAL_RANGE
 *					     AGX2K3K_ATTR_FFT_VERTICAL_REFERENCE
 *					     AGX2K3K_ATTR_FFT_VERTICAL_SCALE
 *					     AGX2K3K_ATTR_FFT_SOURCE1
 *					     AGX2K3K_ATTR_FFT_FREQUENCY_SPAN
 *					     AGX2K3K_ATTR_FFT_VERTICAL_UNIT
 *					     AGX2K3K_ATTR_FFT_WINDOW
 *
 *					     2.Fix CAR 544897
 *					     Modified agx2k3k_ReadWaveformMeasurement function:
 *					     Used the actual channel "channelName" instead of "channel" after function Ivi_CoerceChannelName
 *	2016-02-29 - [junzhang]
 *						 1. Added support for 6000 X-Series
 *						    DSO-X 6002A, DSO-X 6004A, MSO-X 6002A, MSO-X 6004A
 *
 *                       Added functions:
 *						 agx2k3k_ConfigureChannelBandwidth
 *						 agx2k3k_ConfigureClockRecoveryFixed
 *						 agx2k3k_ConfigureClockRecoveryFOPLL
 *						 agx2k3k_ConfigureClockRecoverySOPLL
 *						 agx2k3k_ConfigureClockRecoveryExplicit
 *						 agx2k3k_ConfigureHistogram
 *						 agx2k3k_ConfigureHistogramWaveform
 *						 agx2k3k_ResetHistogramCounters
 *						 agx2k3k_ApplyJitterHistogram
 *						 agx2k3k_ApplyJitterSpectrum
 *						 agx2k3k_ConfigureJitterMeasurement
 *						 agx2k3k_ConfigureJitterAnalysisEnabled
 *						 agx2k3k_ApplyJitterTrend
 *						 agx2k3k_ApplyJitterTrendSmooth
 *						 agx2k3k_ReadNCycleToNCycleJitter
 *						 agx2k3k_ReadNPeriodJitter
 *						 agx2k3k_ReadDataTIEJitter
 *						 agx2k3k_ReadClockTIEJitter
 *						 agx2k3k_ReadHistogramMeasurement
 *						 agx2k3k_ReadRTEyeMeasurement
 *						 agx2k3k_ReadCycleToCycleWidth
 *						 agx2k3k_BuildRealTimeEye
 *						 agx2k3k_ConfigureRealTimeEye
 *						 agx2k3k_QueryUIIntervals
 *						 agx2k3k_ConfigureCANFDStandard
 *						 agx2k3k_ConfigureSystemPrecision
 *						 agx2k3k_ConfigureTriggerJFreeEnabled
 *						 agx2k3k_ConfigureWaveformSubsource
 *
 *						 Modified functions:
 *						 agx2k3k_ConfigureIICBusSource
 *						 agx2k3k_ConfigureAcquisitionMode
 *						 agx2k3k_ConfigureMathFunction
 *
 *					     Added attributes:
 *					     AGX2K3K_ATTR_HISTOGRAM_MEASUREMENT
 *					     AGX2K3K_ATTR_HISTOGRAM_MODE
 *					     AGX2K3K_ATTR_HISTOGRAM_AXIS
 *					     AGX2K3K_ATTR_JITTER_MEASUREMENT
 *					     AGX2K3K_ATTR_WAVEFORM_SOURCE_SUBSOURCE
 *					     AGX2K3K_ATTR_SYSTEM_PRECISION_LENGTH
 *					     AGX2K3K_ATTR_CHANNEL_BANDWIDTH
 *					     AGX2K3K_ATTR_HISTOGRAM_WINDOW_BLIMIT
 *					     AGX2K3K_ATTR_HISTOGRAM_WINDOW_LLIMIT
 *					     AGX2K3K_ATTR_HISTOGRAM_WINDOW_RLIMIT
 *					     AGX2K3K_ATTR_HISTOGRAM_WINDOW_TLIMIT
 *					     AGX2K3K_ATTR_JITTER_ENABLE
 *					     AGX2K3K_ATTR_RTEYE_ENABLE
 *					     AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_CGRADE_ENABLED
 *					     AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_HISTOGRAM_ENABLED
 *					     AGX2K3K_ATTR_SYSTEM_PRECISION_ENABLED
 *					     AGX2K3K_ATTR_TRIGGER_JFREE_ENABLED
 *					     AGX2K3K_ATTR_HISTOGRAM_WINDOW_SOURCE
 *					     AGX2K3K_ATTR_RTEYE_SOURCE
 *
 *						 2.Fix CAR 570406
 *						 Modified agx2k3k_FetchEfficiency & agx2k3k_FetchRipple
 *						 use correct format code %lf instead of %f for reading Real64
 *
 *						 3.Fix CAR 571147
 *                       Modified agx2k3k_ConfigureRuntTriggerSource to comply
 *						 with the IVI specification. The runt tigger width is moved
 *                       to a new function agx2k3k_ConfigureRuntTriggerWidth
 *
 *						 4.Fix CAR 575109
 *						 Attributes were used but not added to driver session
 *						 AGX2K3K_ATTR_INSTR_TRIGGER_RUNT_SOURCE
 * 					     AGX2K3K_ATTR_INSTR_TRIGGER_TRANSITION_SOURCE
 *						 AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_BURST_SOURCE
 *****************************************************************************/
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include "agx2k3k.h"


#ifndef _MSC_VER
#include <formatio.h>
#endif

/*****************************************************************************
 *--------------------- Hidden Attribute Declarations -----------------------*
 *****************************************************************************/

#define AGX2K3K_ATTR_OPC_TIMEOUT                          (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 1L)    /* ViInt32 */
#define AGX2K3K_ATTR_INSTR_MODEL_TYPE                     (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 2L)    /* ViInt32 */
#define AGX2K3K_ATTR_OPC_CALLBACK                         (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 6L)    /* ViAddr */
#define AGX2K3K_ATTR_CHECK_STATUS_CALLBACK                (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 7L)    /* ViAddr */
#define AGX2K3K_ATTR_USER_INTERCHANGE_CHECK_CALLBACK      (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 8L)    /* ViAddr */

#define AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_SOURCE            (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 116L)  /* ViString */
#define AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_LEVEL             (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 117L)  /* ViReal64 */

#define AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_BURST_SOURCE      (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 118L)  /* ViString */

#define AGX2K3K_ATTR_INSTR_TRIGGER_TV_SOURCE              (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 119L)  /* ViString */

#define AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_SOURCE          (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 126L)  /* ViString */
#define AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_LEVEL           (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 127L)  /* ViReal64 */

#define AGX2K3K_ATTR_INSTR_TRIGGER_PATTERN                (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 135L)  /* ViString */
#define AGX2K3K_ATTR_INSTR_TRIGGER_RUNT_SOURCE            (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 139L)  /* ViString */

#define AGX2K3K_ATTR_INSTR_TRIGGER_TRANSITION_SOURCE      (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 148L)  /* ViString */

#define AGX2K3K_ATTR_INSTR_ACQUISITION_POINTS             (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 183L)  /* ViInt32 */
#define AGX2K3K_ATTR_INSTR_AUTO_PROBE_SENSE_ENABLED       (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 189L)  /* ViBoolean, channel-based */
#define AGX2K3K_ATTR_INSTR_PROBE_ATTENUATION              (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 190L)  /* ViReal64 */

#define AGX2K3K_ATTR_INSTR_VERT_COUPLING                  (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 197L)  /* ViInt32, enum */

#define AGX2K3K_ATTR_INSTR_INPUT_IMPEDANCE                (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 211L)  /* ViString */
#define AGX2K3K_ATTR_INSTR_BW_LIMIT                       (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 213L)  /* ViBoolean */
#define AGX2K3K_ATTR_INSTR_MAX_INPUT_FREQUENCY            (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 214L)  /* ViReal64 */

#define AGX2K3K_ATTR_INSTR_CHANNEL_LABEL                  (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 219L)  /* ViString */

#define AGX2K3K_ATTR_INSTR_MATH_SOURCE                    (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 226L)  /* ViInt32 */
#define AGX2K3K_ATTR_INSTR_DATA_SOURCE                    (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 227L)  /* ViString  */
#define AGX2K3K_ATTR_INSTR_MATH_OPERATION                 (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 228L)  /* ViInt32 */
#define AGX2K3K_ATTR_INSTR_MATH_OPERATION_MULTICHANNEL    (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 229L)  /* ViInt32 */
#define AGX2K3K_ATTR_INSTR_MEAS_REF                       (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 240L)  /* ViString */
#define AGX2K3K_ATTR_INSTR_MEAS_SOURCE                    (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 241L)  /* ViString */
#define AGX2K3K_ATTR_INSTR_MEAS_DELAY                     (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 242L)  /* ViString */
#define AGX2K3K_ATTR_INSTR_MATH_SOURCE1                   (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 247L)  /* ViString */
#define AGX2K3K_ATTR_INSTR_MATH_SOURCE2                   (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 248L)  /* ViString */
#define AGX2K3K_ATTR_INSTR_MATH_GOFT_OPERATION            (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 249L)  /* ViInt32 */
#define AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE1              (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 250L)  /* ViString */
#define AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE2              (IVI_SPECIFIC_PRIVATE_ATTR_BASE + 251L)  /* ViString */


/*****************************************************************************
 *---------------------------- Useful Macros --------------------------------*
 *****************************************************************************/
#define HEADER_SIZE              13L              /* Maximum size of header for binary data */

/*- I/O buffer size -----------------------------------------------------*/
#define BUFFER_SIZE              1024L

/*- 488.2 Event Status Register (ESR) Bits ------------------------------*/
#define IEEE_488_2_ERROR_MASK    0x3C

/*- Defined macros and constants for instrument model checking ----------*/
#define SETUP_MODEL_TAG          "Model"

/*- Defined macros and constants for record mode checking ---------------*/
#define SETUP_RECORD_MODE_TAG    "RecordMode"


static IviRangeTableEntry attrHorzRecordModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_RECORD_NORMAL, 0, 0, "NORM", 0 },
    { AGX2K3K_VAL_RECORD_MAX,    0, 0, "MAX",  0 },
    { AGX2K3K_VAL_RECORD_RAW,    0, 0, "RAW",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrHorzRecordModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrHorzRecordModeRangeTableEntries,
};

enum
{
    UNKNOWN   = -1,


    /* 3000 X-Series MSO models */
    MSOX3014A = 1,      /* 4 analog 16 digital (mixed signal) 100 MHz */
    MSOX3024A,          /* 4 analog 16 digital (mixed signal) 200 MHz */
    MSOX3034A,          /* 4 analog 16 digital (mixed signal) 350 MHz */
    MSOX3054A,          /* 4 analog 16 digital (mixed signal) 500 MHz */
    MSOX3012A,          /* 2 analog 16 digital (mixed signal) 100 MHz */
    MSOX3032A,          /* 2 analog 16 digital (mixed signal) 350 MHz */
    MSOX3052A,          /* 2 analog 16 digital (mixed signal) 500 MHz */

    MSOX3102A,          /* 4 analog 16 digital (mixed signal) 1 GHz */
    MSOX3104A,          /* 2 analog 16 digital (mixed signal) 1 GHz */

    /* 3000 X-Series DSO models */
    DSOX3014A,          /* 4 analog 100 MHz */
    DSOX3024A,          /* 4 analog 200 MHz */
    DSOX3034A,          /* 4 analog 350 MHz */
    DSOX3054A,          /* 4 analog 500 MHz */
    DSOX3012A,          /* 2 analog 100 MHz */
    DSOX3032A,          /* 2 analog 350 MHz */
    DSOX3052A,          /* 2 analog 500 MHz */

    DSOX3102A,          /* 2 analog 1 GHz */
    DSOX3104A,          /* 2 analog 1 GHz */

    /* 2000 X-Series MSO models */
    MSOX2004A,          /* 4 analog 8 digital (mixed signal) 70 MHz  */
    MSOX2014A,          /* 4 analog 8 digital (mixed signal) 100 MHz */
    MSOX2024A,          /* 4 analog 8 digital (mixed signal) 200 MHz */
    MSOX2002A,          /* 2 analog 8 digital (mixed signal) 70 MHz  */
    MSOX2012A,          /* 2 analog 8 digital (mixed signal) 100 MHz */
    MSOX2022A,          /* 2 analog 8 digital (mixed signal) 200 MHz */

    /* 2000 X-Series DSO models */
    DSOX2004A,          /* 4 analog 70 MHz  */
    DSOX2014A,          /* 4 analog 100 MHz */
    DSOX2024A,          /* 4 analog 200 MHz */
    DSOX2002A,          /* 2 analog 70 MHz  */
    DSOX2012A,          /* 2 analog 100 MHz */
    DSOX2022A,          /* 2 analog 200 MHz */

    /* 4000 X-Series MSO models */
    MSOX4022A,          /* 2 analog 16 logic (mixed signal) 200 MHz */
    MSOX4032A,          /* 2 analog 16 logic (mixed signal) 350 MHz */
    MSOX4052A,          /* 2 analog 16 logic (mixed signal) 500 MHz */
    MSOX4024A,          /* 4 analog 16 logic (mixed signal) 200 MHz */
    MSOX4034A,          /* 4 analog 16 logic (mixed signal) 350 MHz */
    MSOX4054A,          /* 4 analog 16 logic (mixed signal) 500 MHz */
    MSOX4104A,          /* 4 analog 16 logic (mixed signal) 1 GHz */
    MSOX4154A,          /* 4 analog 16 logic (mixed signal) 1.5 GHz */

    /* 4000 X-Series DSO models */
    DSOX4022A,          /* 2 analog 200 MHz */
    DSOX4032A,          /* 2 analog 350 MHz */
    DSOX4052A,          /* 2 analog 500 MHz */
    DSOX4024A,          /* 4 analog 200 MHz */
    DSOX4034A,          /* 4 analog 350 MHz */
    DSOX4054A,          /* 4 analog 500 MHz */
    DSOX4104A,          /* 4 analog 1 GHz */
    DSOX4154A,          /* 4 analog 1.5 GHz */

    /* 3000T X-Series MSO models */
    MSOX3012T,          /* 2 channels 16 logic channels 100 MHz */
    MSOX3022T,          /* 2 channels 16 logic channels 200 MHz */
    MSOX3032T,          /* 2 channels 16 logic channels 350 MHz */
    MSOX3052T,          /* 2 channels 16 logic channels 500 MHz */
    MSOX3102T,          /* 2 channels 16 logic channels 1 GHz */

    MSOX3014T,          /* 4 channels 16 logic channels 100 MHz */
    MSOX3024T,          /* 4 channels 16 logic channels 200 MHz */    /*2 functions*/
    MSOX3034T,          /* 4 channels 16 logic channels 350 MHz */
    MSOX3054T,          /* 4 channels 16 logic channels 500 MHz */
    MSOX3104T,          /* 4 channels 16 logic channels 1 GHz */

    /* 3000T X-Series DSO models */
    DSOX3012T,          /* 2 channels 100 MHz */
    DSOX3022T,          /* 2 channels 200 MHz */
    DSOX3032T,          /* 2 channels 350 MHz */
    DSOX3052T,          /* 2 channels 500 MHz */
    DSOX3102T,          /* 2 channels 1 GHz */

    DSOX3014T,          /* 4 channels 100 MHz */
    DSOX3024T,          /* 4 channels 200 MHz */
    DSOX3034T,          /* 4 channels 350 MHz */
    DSOX3054T,          /* 4 channels 500 MHz */
    DSOX3104T,          /* 4 channels 1 GHz */

    /* 6000 X-Series models */
    DSOX6002A,          /* 2 channels */
    DSOX6004A,          /* 4 channels */
    MSOX6002A,          /* 2 channels 16 logic channels */
    MSOX6004A,          /* 4 channels 16 logic channels */
};

static IviStringValueTable gs_agx2k3k_ModelTable =
{
    /* 3000 X-Series MSO models */
    { MSOX3014A, "MSO-X 3014A" },     /* 4 analog 16 digital (mixed signal) 100 MHz */
    { MSOX3024A, "MSO-X 3024A" },     /* 4 analog 16 digital (mixed signal) 200 MHz */
    { MSOX3034A, "MSO-X 3034A" },     /* 4 analog 16 digital (mixed signal) 350 MHz */
    { MSOX3054A, "MSO-X 3054A" },     /* 4 analog 16 digital (mixed signal) 500 MHz */
    { MSOX3012A, "MSO-X 3012A" },     /* 2 analog 16 digital (mixed signal) 100 MHz */
    { MSOX3032A, "MSO-X 3032A" },     /* 2 analog 16 digital (mixed signal) 350 MHz */
    { MSOX3052A, "MSO-X 3052A" },     /* 2 analog 16 digital (mixed signal) 500 MHz */

    { MSOX3102A, "MSO-X 3102A" },     /* 4 analog 16 digital (mixed signal) 1 GHz */
    { MSOX3104A, "MSO-X 3104A" },     /* 2 analog 16 digital (mixed signal) 1 GHz */

    /* 3000 X-Series DSO models */
    { DSOX3014A, "DSO-X 3014A" },     /* 4 analog 100 MHz */
    { DSOX3024A, "DSO-X 3024A" },     /* 4 analog 200 MHz */
    { DSOX3034A, "DSO-X 3034A" },     /* 4 analog 350 MHz */
    { DSOX3054A, "DSO-X 3054A" },     /* 4 analog 500 MHz */
    { DSOX3012A, "DSO-X 3012A" },     /* 2 analog 100 MHz */
    { DSOX3032A, "DSO-X 3032A" },     /* 2 analog 350 MHz */
    { DSOX3052A, "DSO-X 3052A" },     /* 2 analog 500 MHz */

    { DSOX3102A, "DSO-X 3102A" },     /* 2 analog 1 GHz */
    { DSOX3104A, "DSO-X 3104A" },     /* 2 analog 1 GHz */

    /* 2000 X-Series MSO models */
    { MSOX2004A, "MSO-X 2004A" },     /* 4 analog 8 digital (mixed signal) 70 MHz  */
    { MSOX2014A, "MSO-X 2014A" },     /* 4 analog 8 digital (mixed signal) 100 MHz */
    { MSOX2024A, "MSO-X 2024A" },     /* 4 analog 8 digital (mixed signal) 200 MHz */
    { MSOX2002A, "MSO-X 2002A" },     /* 2 analog 8 digital (mixed signal) 70 MHz  */
    { MSOX2012A, "MSO-X 2012A" },     /* 2 analog 8 digital (mixed signal) 100 MHz */
    { MSOX2022A, "MSO-X 2022A" },     /* 2 analog 8 digital (mixed signal) 200 MHz */

    /* 2000 X-Series DSO models */
    { DSOX2004A, "DSO-X 2004A" },     /* 4 analog 70 MHz  */
    { DSOX2014A, "DSO-X 2014A" },     /* 4 analog 100 MHz */
    { DSOX2024A, "DSO-X 2024A" },     /* 4 analog 200 MHz */
    { DSOX2002A, "DSO-X 2002A" },     /* 2 analog 70 MHz  */
    { DSOX2012A, "DSO-X 2012A" },     /* 2 analog 100 MHz */
    { DSOX2022A, "DSO-X 2022A" },     /* 2 analog 200 MHz */

    /* 4000 X-Series MSO models */
    { MSOX4022A, "MSO-X 4022A" },     /* 2 analog 16 logic (mixed signal) 200 MHz */
    { MSOX4032A, "MSO-X 4032A" },     /* 2 analog 16 logic (mixed signal) 350 MHz */
    { MSOX4052A, "MSO-X 4052A" },     /* 2 analog 16 logic (mixed signal) 500 MHz */
    { MSOX4024A, "MSO-X 4024A" },     /* 4 analog 16 logic (mixed signal) 200 MHz */
    { MSOX4034A, "MSO-X 4034A" },     /* 4 analog 16 logic (mixed signal) 350 MHz */
    { MSOX4054A, "MSO-X 4054A" },     /* 4 analog 16 logic (mixed signal) 500 MHz */
    { MSOX4104A, "MSO-X 4104A" },     /* 4 analog 16 logic (mixed signal) 1 GHz */
    { MSOX4154A, "MSO-X 4154A" },     /* 4 analog 16 logic (mixed signal) 1.5 GHz */
    /* 4000 X-Series DSO models */
    { DSOX4022A, "DSO-X 4022A" },     /* 2 analog 200 MHz */
    { DSOX4032A, "DSO-X 4032A" },     /* 2 analog 350 MHz */
    { DSOX4052A, "DSO-X 4052A" },     /* 2 analog 500 MHz */
    { DSOX4024A, "DSO-X 4024A" },     /* 4 analog 200 MHz */
    { DSOX4034A, "DSO-X 4034A" },     /* 4 analog 350 MHz */
    { DSOX4054A, "DSO-X 4054A" },     /* 4 analog 500 MHz */
    { DSOX4104A, "DSO-X 4104A" },     /* 4 analog 1 GHz */
    { DSOX4154A, "DSO-X 4154A" },     /* 4 analog 1.5 GHz */

    /* 3000T X-Series MSO models */
    { MSOX3012T, "MSO-X 3012T" },     /* 2 channels 16 logic channels 100 MHz */
    { MSOX3022T, "MSO-X 3022T" },     /* 2 channels 16 logic channels 200 MHz */
    { MSOX3032T, "MSO-X 3032T" },     /* 2 channels 16 logic channels 350 MHz */
    { MSOX3052T, "MSO-X 3052T" },     /* 2 channels 16 logic channels 500 MHz */
    { MSOX3102T, "MSO-X 3102T" },     /* 2 channels 16 logic channels 1 GHz */

    { MSOX3014T, "MSO-X 3014T" },     /* 4 channels 16 logic channels 100 MHz */
    { MSOX3024T, "MSO-X 3024T" },     /* 4 channels 16 logic channels 200 MHz */
    { MSOX3034T, "MSO-X 3034T" },     /* 4 channels 16 logic channels 350 MHz */
    { MSOX3054T, "MSO-X 3054T" },     /* 4 channels 16 logic channels 500 MHz */
    { MSOX3104T, "MSO-X 3104T" },     /* 4 channels 16 logic channels 1 GHz */

    /* 3000T X-Series DSO models */
    { DSOX3012T, "DSO-X 3012T" },     /* 2 channels 100 MHz */
    { DSOX3022T, "DSO-X 3022T" },     /* 2 channels 200 MHz */
    { DSOX3032T, "DSO-X 3032T" },     /* 2 channels 350 MHz */
    { DSOX3052T, "DSO-X 3052T" },     /* 2 channels 500 MHz */
    { DSOX3102T, "DSO-X 3102T" },     /* 2 channels 1 GHz */

    { DSOX3014T, "DSO-X 3014T" },     /* 4 channels 100 MHz */
    { DSOX3024T, "DSO-X 3024T" },     /* 4 channels 200 MHz */
    { DSOX3034T, "DSO-X 3034T" },     /* 4 channels 350 MHz */
    { DSOX3054T, "DSO-X 3054T" },     /* 4 channels 500 MHz */
    { DSOX3104T, "DSO-X 3104T" },     /* 4 channels 1 GHz */

    { DSOX6002A, "DSO-X 6002A" },     /* 2 channels */
    { DSOX6004A, "DSO-X 6004A" },     /* 4 channels */
    { MSOX6002A, "MSO-X 6002A" },     /* 2 channels 16 logic channels */
    { MSOX6004A, "MSO-X 6004A" },     /* 4 channels 16 logic channels */

    { VI_NULL,   VI_NULL       }
};

static ViConstString gpstrDSODataSources[] = { "FUNC", "MATH", "SBUS1", "SBUS2" };
static ViConstString gpstrMSODataSources[] = { "POD1", "POD2", "BUS1", "BUS2", "FUNC", "MATH", "SBUS1", "SBUS2" };
static ViConstString gpstr2Channels[] = { "CHAN1", "CHAN2" };
static ViConstString gpstr4Channels[] = { "CHAN1", "CHAN2", "CHAN3", "CHAN4" };

#define IS_MSO_2000_2CHAN(mt)     (mt == MSOX2002A || mt == MSOX2012A || mt == MSOX2022A)
#define IS_MSO_2000_4CHAN(mt)     (mt == MSOX2004A || mt == MSOX2014A || mt == MSOX2024A)
#define IS_MSO_3000_2CHAN(mt)     (mt == MSOX3012A || mt == MSOX3032A || mt == MSOX3052A || mt == MSOX3102A || mt == MSOX3012T || mt == MSOX3022T || mt == MSOX3032T || mt == MSOX3052T || mt == MSOX3102T)
#define IS_MSO_3000_4CHAN(mt)     (mt == MSOX3014A || mt == MSOX3024A || mt == MSOX3034A || mt == MSOX3054A || mt == MSOX3104A || mt == MSOX3014T || mt == MSOX3024T || mt == MSOX3034T || mt == MSOX3054T || mt == MSOX3104T)
#define IS_MSO_3000T_2CHAN(mt)    (mt == MSOX3012T || mt == MSOX3022T || mt == MSOX3032T || mt == MSOX3052T || mt == MSOX3102T)
#define IS_MSO_3000T_4CHAN(mt)    (mt == MSOX3014T || mt == MSOX3024T || mt == MSOX3034T || mt == MSOX3054T || mt == MSOX3104T)
#define IS_MSO_4000_2CHAN(mt)     (mt == MSOX4022A || mt == MSOX4032A || mt == MSOX4052A)
#define IS_MSO_4000_4CHAN(mt)     (mt == MSOX4024A || mt == MSOX4034A || mt == MSOX4054A || mt == MSOX4104A || mt == MSOX4154A)
#define IS_DSO_2000_2CHAN(mt)     (mt == DSOX2002A || mt == DSOX2012A || mt == DSOX2022A)
#define IS_DSO_2000_4CHAN(mt)     (mt == DSOX2004A || mt == DSOX2014A || mt == DSOX2024A)
#define IS_DSO_3000_2CHAN(mt)     (mt == DSOX3012A || mt == DSOX3032A || mt == DSOX3052A || mt == DSOX3102A || mt == DSOX3012T || mt == DSOX3022T || mt == DSOX3032T || mt == DSOX3052T || mt == DSOX3102T)
#define IS_DSO_3000_4CHAN(mt)     (mt == DSOX3014A || mt == DSOX3024A || mt == DSOX3034A || mt == DSOX3054A || mt == DSOX3104A || mt == DSOX3014T || mt == DSOX3024T || mt == DSOX3034T || mt == DSOX3054T || mt == DSOX3104T)
#define IS_DSO_3000T_2CHAN(mt)    (mt == DSOX3012T || mt == DSOX3022T || mt == DSOX3032T || mt == DSOX3052T || mt == DSOX3102T)
#define IS_DSO_3000T_4CHAN(mt)    (mt == DSOX3014T || mt == DSOX3024T || mt == DSOX3034T || mt == DSOX3054T || mt == DSOX3104T)
#define IS_DSO_4000_2CHAN(mt)     (mt == DSOX4022A || mt == DSOX4032A || mt == DSOX4052A)
#define IS_DSO_4000_4CHAN(mt)     (mt == DSOX4024A || mt == DSOX4034A || mt == DSOX4054A || mt == DSOX4154A)

#define IS_2000_SERIES(mt)        (IS_MSO_2000_2CHAN (mt) || IS_MSO_2000_4CHAN (mt) || IS_DSO_2000_2CHAN (mt) || IS_DSO_2000_4CHAN (mt))
#define IS_3000_SERIES(mt)        (IS_MSO_3000_2CHAN (mt) || IS_MSO_3000_4CHAN (mt) || IS_DSO_3000_2CHAN (mt) || IS_DSO_3000_4CHAN (mt))
#define IS_4000_SERIES(mt)        (IS_MSO_4000_2CHAN (mt) || IS_MSO_4000_4CHAN (mt) || IS_DSO_4000_2CHAN (mt) || IS_DSO_4000_4CHAN (mt))
#define IS_3000T_SERIES(mt)       (IS_MSO_3000T_2CHAN (mt) || IS_MSO_3000T_4CHAN (mt) || IS_DSO_3000T_2CHAN (mt) || IS_DSO_3000T_4CHAN (mt))
#define IS_6000_SERIES(mt)        (mt == DSOX6002A || mt == DSOX6004A || mt == MSOX6002A || mt == MSOX6004A)

/*- List of channels passed to the Ivi_BuildChannelTable function -------*/
#define CHANNEL_LIST_4       "CHAN1,CHAN2,CHAN3,CHAN4"
#define CHANNEL_LIST_2       "CHAN1,CHAN2"
#define LOGIC_CHANNELS       "DIG0,DIG1,DIG2,DIG3,DIG4,DIG5,DIG6,DIG7,DIG8,DIG9,DIG10,DIG11,DIG12,DIG13,DIG14,DIG15,POD1,POD2"
#define MATH_DSO_CHANNELS    "FUNC,MATH,SBUS1,SBUS2"
#define MATH_MSO_CHANNELS    "BUS1,BUS2,FUNC,MATH,SBUS1,SBUS2"
#define WMEMORY_CHANNELS     "WMEM1,WMEM2"
#define EXTERNAL_CHANNELS    "EXT"
#define SERIAL_CHANNELS      "SBUS1,SBUS2"
#define WGEN_CHANNELS        "WGEN1,WGEN2"
#define FUNCTION_CHANNELS    "FUNC1,FUNC2,FUNC3,FUNC4"
#define ZONE_CHANNELS        "ZONE1,ZONE2"
#define SIGNAL_CHANNELS      "SIGN1,SIGN2,SIGN3,SIGN4,SIGN5,SIGN6"

#define HAS_2CHANNELS(mt)    (IS_MSO_2000_2CHAN (mt) || IS_MSO_3000_2CHAN (mt) || IS_MSO_4000_2CHAN (mt) || IS_DSO_2000_2CHAN (mt) || IS_DSO_3000_2CHAN (mt) || IS_DSO_4000_2CHAN (mt) || mt == DSOX6002A || mt == MSOX6002A)
#define HAS_4CHANNELS(mt)    (IS_MSO_2000_4CHAN (mt) || IS_MSO_3000_4CHAN (mt) || IS_MSO_4000_4CHAN (mt) || IS_DSO_2000_4CHAN (mt) || IS_DSO_3000_4CHAN (mt) || IS_DSO_4000_4CHAN (mt) || mt == DSOX6004A || mt == MSOX6004A)

#define IS_DSO_INSTR(mt)     (IS_DSO_2000_2CHAN (mt) || IS_DSO_2000_4CHAN (mt) || IS_DSO_3000_2CHAN (mt) || IS_DSO_3000_4CHAN (mt) || IS_DSO_4000_2CHAN (mt) || IS_DSO_4000_4CHAN (mt) || mt == DSOX6002A || mt == DSOX6004A)
#define IS_MSO_INSTR(mt)     (IS_MSO_2000_2CHAN (mt) || IS_MSO_2000_4CHAN (mt) || IS_MSO_3000_2CHAN (mt) || IS_MSO_3000_4CHAN (mt) || IS_MSO_4000_2CHAN (mt) || IS_MSO_4000_4CHAN (mt) || mt == MSOX6002A || mt == MSOX6004A)

/*- Minimum value for the Trigger Holdoff that the instrument supports-----*/
#define MIN_HOLDOFF_VALUE    60e-9

/*- Defined macros for enum attributes ----------------------------------*/
#define agx2k3k_GetCmdFromIntValue(value, table, cmd) \
    Ivi_GetViInt32EntryFromValue (value, table, VI_NULL, VI_NULL, VI_NULL, VI_NULL, cmd, VI_NULL)

#define agx2k3k_GetValueFromCmd(buffer, table, value) \
    Ivi_GetViInt32EntryFromString (buffer, table, value, VI_NULL, VI_NULL, VI_NULL, VI_NULL)

#define agx2k3k_IsComplexMathOperation(op) \
    (op == AGX2K3K_VAL_MATH_OPERATION_INTEGRATE || op == AGX2K3K_VAL_MATH_OPERATION_DIFFERENTIATE || op == AGX2K3K_VAL_MATH_OPERATION_FFT || op == AGX2K3K_VAL_MATH_OPERATION_SQUARE_ROOT)

#define agx2k3k_IsGtOperation(op) \
    (op == AGX2K3K_VAL_MATH_OPERATION_GOFT_PLUS || op == AGX2K3K_VAL_MATH_OPERATION_GOFT_MINUS || op == AGX2K3K_VAL_MATH_OPERATION_GOFT_MULTIPLY)


/*****************************************************************************
 * Tables of commands for specified attributes
 *****************************************************************************/
/*- Table of commands for enum attributes (ViInt32) -------------------------*/
static IviStringValueTable gs_EnumCommands =
{
    { AGX2K3K_ATTR_TIMEBASE_MODE,                           ":TIM:MODE"                 },
    { AGX2K3K_ATTR_SBUS_CAN_ID_MODE,                        ":%s:CAN:TRIG:PATT:ID:MODE" },
    { AGX2K3K_ATTR_TIMEBASE_REFERENCE,                      ":TIM:REF"                  },
    { AGX2K3K_ATTR_TRIGGER_TYPE,                            ":TRIG:MODE"                },
    { AGX2K3K_ATTR_TRIGGER_COUPLING,                        ":TRIG:EDGE:COUP"           },
    { AGX2K3K_ATTR_TRIGGER_MODIFIER,                        ":TRIG:SWE"                 },
    { AGX2K3K_ATTR_TRIGGER_SLOPE,                           ":TRIG:EDGE:SLOP"           },
    { AGX2K3K_ATTR_EBURST_SLOPE,                            ":TRIG:EBUR:SLOP"           },
    { AGX2K3K_ATTR_TRIGGER_REJECT_FILTER,                   ":TRIG:EDGE:REJ"            },
    { AGX2K3K_ATTR_TV_TRIGGER_SIGNAL_FORMAT,                ":TRIG:TV:STAN"             },
    { AGX2K3K_ATTR_TV_TRIGGER_EVENT,                        ":TRIG:TV:MODE"             },
    { AGX2K3K_ATTR_TV_TRIGGER_POLARITY,                     ":TRIG:TV:POL"              },
    { AGX2K3K_ATTR_GLITCH_POLARITY,                         ":TRIG:GLIT:POL"            },
    { AGX2K3K_ATTR_GLITCH_CONDITION,                        ":TRIG:GLIT:QUAL"           },
    { AGX2K3K_ATTR_PATTERN_QUALIFIER,                       ":TRIG:PATT:QUAL"           },
    { AGX2K3K_ATTR_SETUPHOLD_SLOPE,                         ":TRIG:SHOL:SLOP"           },
    { AGX2K3K_ATTR_USB_TRIGGER,                             ":TRIG:USB:TRIG"            },
    { AGX2K3K_ATTR_USB_SPEED,                               ":TRIG:USB:SPE"             },
    { AGX2K3K_ATTR_RUNT_POLARITY,                           ":TRIG:RUNT:POL"            },
    { AGX2K3K_ATTR_RUNT_QUALIFIER,                          ":TRIG:RUNT:QUAL"           },
    { AGX2K3K_ATTR_TRANSITION_QUALIFIER,                    ":TRIG:TRAN:QUAL"           },
    { AGX2K3K_ATTR_TRANSITION_SLOPE,                        ":TRIG:TRAN:SLOP"           },
    { AGX2K3K_ATTR_SBUS_CAN_SIGNAL,                         ":%s:CAN:SIGN:DEF"          },
    { AGX2K3K_ATTR_SBUS_CAN_TRIGGER,                        ":%s:CAN:TRIG"              },
    { AGX2K3K_ATTR_SBUS_I2S_ALIGNMENT,                      ":%s:I2S:ALIG"              },
    { AGX2K3K_ATTR_SBUS_I2S_CLOCK_SLOPE,                    ":%s:I2S:CLOC:SLOP"         },
    { AGX2K3K_ATTR_SBUS_I2S_TRIGGER_AUDIO,                  ":%s:I2S:TRIG:AUD"          },
    { AGX2K3K_ATTR_SBUS_I2S_TRIGGER,                        ":%s:I2S:TRIG"              },
    { AGX2K3K_ATTR_SBUS_I2S_WS_LOW,                         ":%s:I2S:WSL"               },
    { AGX2K3K_ATTR_SBUS_IIC_TYPE,                           ":%s:IIC:TRIG"              },
    { AGX2K3K_ATTR_SBUS_IIC_QUALIFIER,                      ":%s:IIC:TRIG:QUAL"         },
    { AGX2K3K_ATTR_SBUS_IIC_SIZE,                           ":%s:IIC:ASIZ"              },
    { AGX2K3K_ATTR_SBUS_LIN_TRIGGER,                        ":%s:LIN:TRIG"              },
    { AGX2K3K_ATTR_SBUS_LIN_STANDARD,                       ":%s:LIN:STAN"              },
    { AGX2K3K_ATTR_SBUS_LIN_SYNC_BREAK,                     ":%s:LIN:SYNC"              },
    /* {AGX2K3K_ATTR_SBUS_LIN_TRIGGER,                    ":%s:LIN:TRIG"              },   */  /* by holi: it's duplicated */
    { AGX2K3K_ATTR_SBUS_SPI_SLOPE,                          ":%s:SPI:CLOC:SLOP"         },
    { AGX2K3K_ATTR_SBUS_SPI_BIT_ORDER,                      ":%s:SPI:BIT"               },
    { AGX2K3K_ATTR_SBUS_SPI_FRAME,                          ":%s:SPI:FRAM"              },
    { AGX2K3K_ATTR_SBUS_SPI_TRIGGER_TYPE,                   ":%s:SPI:TRIG:TYPE"         },
    { AGX2K3K_ATTR_SBUS_UART_BIT_ORDER,                     ":%s:UART:BIT"              },
    { AGX2K3K_ATTR_SBUS_UART_PARITY,                        ":%s:UART:PAR"              },
    { AGX2K3K_ATTR_SBUS_UART_POLARITY,                      ":%s:UART:POL"              },
    { AGX2K3K_ATTR_SBUS_UART_TRIGGER_QUALIFIER,             ":%s:UART:TRIG:QUAL"        },
    { AGX2K3K_ATTR_SBUS_UART_TRIGGER_TYPE,                  ":%s:UART:TRIG:TYPE"        },
    { AGX2K3K_ATTR_ACQUISITION_TYPE,                        ":ACQ:TYPE"                 },
    { AGX2K3K_ATTR_ACQUISITION_MODE,                        ":ACQ:MODE"                 },
    { AGX2K3K_ATTR_INSTR_VERT_COUPLING,                     ":%s:COUP"                  },
    { AGX2K3K_ATTR_PROBE_UNITS,                             ":%s:UNIT"                  },
    { AGX2K3K_ATTR_INSTR_MATH_OPERATION,                    ":FUNC:OPER"                },
    { AGX2K3K_ATTR_INSTR_MATH_OPERATION_MULTICHANNEL,       ":%s:OPER"                  }, /* added in version 3.0 */
    { AGX2K3K_ATTR_INSTR_MATH_GOFT_OPERATION,               ":FUNC:GOFT:OPER"           },
    { AGX2K3K_ATTR_MATH_WINDOW,                             ":FUNC:WIND"                },
    { AGX2K3K_ATTR_MATH_WINDOW_MULTICHANNEL,                ":%s:WIND"                  }, /* added in version 3.0 */
    { AGX2K3K_ATTR_DIG_SIZE,                                ":%s:SIZE"                  },
    { AGX2K3K_ATTR_HORZ_RECORD_MODE,                        ":WAV:POIN:MODE"            },
    { AGX2K3K_ATTR_WAVEGEN_FUNCTION,                        ":WGEN:FUNC"                },
    { AGX2K3K_ATTR_WAVEGEN_FUNCTION_MULTICHANNEL,           ":%s:FUNC"                  }, /* added in version 3.0 */
    { AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE,                  ":WGEN:OUTP:LOAD"           },
    { AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE_MULTICHANNEL,     ":%s:OUTP:LOAD"             }, /* added in version 3.0 */
    { AGX2K3K_ATTR_VERTICAL_COUPLING,                       ":%s:COUP"                  },

    /* New attributes added in version 2.0 */
    { AGX2K3K_ATTR_WGEN_ARBITRARY_BYTEORDER,                ":WGEN:ARB:BYT"             },
    { AGX2K3K_ATTR_WGEN_ARBITRARY_BYTEORDER_MULTICHANNEL,   ":%s:ARB:BYT"               }, /* added in version 3.0 */
    { AGX2K3K_ATTR_SEARCH_SERIAL_A429_MODE,                 ":SEAR:SER:A429:MODE"       },
    { AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_MODE,              ":SEAR:SER:FLEX:MODE"       },
    { AGX2K3K_ATTR_SEARCH_SERIAL_M1553_MODE,                ":SEAR:SER:M1553:MODE"      },
    { AGX2K3K_ATTR_DEMO_FUNCTION,                           ":DEMO:FUNC"                },
    { AGX2K3K_ATTR_TRIGGER_PATTERN_FORMAT,                  ":TRIG:PATT:FORM"           },
    { AGX2K3K_ATTR_TRIGGER_DELAY_ARM_SLOPE,                 ":TRIG:DEL:ARM:SLOP"        },
    { AGX2K3K_ATTR_TRIGGER_DELAY_ARM_SOURCE,                ":TRIG:DEL:ARM:SOUR"        },
    { AGX2K3K_ATTR_TRIGGER_DELAY_TRIGGER_SLOPE,             ":TRIG:DEL:TRIG:SLOP"       },
    { AGX2K3K_ATTR_TRIGGER_DELAY_TRIGGER_SOURCE,            ":TRIG:DEL:TRIG:SOUR"       },
    { AGX2K3K_ATTR_MARKER_XUNIT,                            ":MARK:XUN"                 },
    { AGX2K3K_ATTR_MARKER_YUNIT,                            ":MARK:YUN"                 },
    { AGX2K3K_ATTR_FUNCTION_BUS_CLOCK,                      ":FUNC:BUS:CLOC"            },
    { AGX2K3K_ATTR_FUNCTION_BUS_CLOCK_MULTICHANNEL,         ":%s:BUS:CLOC"              }, /* added in version 3.0 */
    { AGX2K3K_ATTR_FUNCTION_BUS_SLOPE,                      ":FUNC:BUS:SLOP"            },
    { AGX2K3K_ATTR_FUNCTION_BUS_SLOPE_MULTICHANNEL,         ":%s:BUS:SLOP"              }, /* added in version 3.0 */
    { AGX2K3K_ATTR_FUNCTION_BUS_YUNITS,                     ":FUNC:BUS:YUN"             },
    { AGX2K3K_ATTR_FUNCTION_BUS_YUNITS_MULTICHANNEL,        ":%s:BUS:YUN"               }, /* added in version 3.0 */
    { AGX2K3K_ATTR_FUNCTION_TREND_MEASUREMENT,              ":FUNC:TREN:MEAS"           },
    { AGX2K3K_ATTR_FUNCTION_TREND_MEASUREMENT_MULTICHANNEL, ":%s:TREN:MEAS"             }, /* added in version 3.0 */
    { AGX2K3K_ATTR_FUNCTION_VTYPE,                          ":FUNC:VTYP"                },
    { AGX2K3K_ATTR_FUNCTION_VTYPE_MULTICHANNEL,             ":%s:VTYP"                  }, /* added in version 3.0 */
    { AGX2K3K_ATTR_POWER_SIGNALS_AUTOSETUP_TYPE,            ":POW:SIGN:AUT"             },
    { AGX2K3K_ATTR_POWER_HARMONICS_DISPLAY_STYLE,           ":POW:HARM:DISP"            },
    { AGX2K3K_ATTR_POWER_HARMONICS_LINE,                    ":POW:HARM:LINE"            },
    { AGX2K3K_ATTR_POWER_HARMONICS_STANDARD,                ":POW:HARM:STAN"            },
    { AGX2K3K_ATTR_POWER_MODULATION_SOURCE,                 ":POW:MOD:SOU"              },
    { AGX2K3K_ATTR_POWER_MODULATION_TYPE,                   ":POW:MOD:TYPE"             },
    { AGX2K3K_ATTR_POWER_PSRR_FREQUENCY_MAX,                ":POW:PSRR:FREQ:MAX"        },
    { AGX2K3K_ATTR_POWER_PSRR_FREQUENCY_MIN,                ":POW:PSRR:FREQ:MIN"        },
    { AGX2K3K_ATTR_POWER_QUALITY_TYPE,                      ":POW:QUAL:TYPE"            },
    { AGX2K3K_ATTR_POWER_SLEW_SOURCE,                       ":POW:SLEW:SOUR"            },
    { AGX2K3K_ATTR_POWER_SWITCH_CONDUCTION,                 ":POW:SWIT:COND"            },
    { AGX2K3K_ATTR_SBUS_MODE,                               ":SBUS:MODE"                },
    { AGX2K3K_ATTR_A429_TRIGGER_TYPE,                       ":%s:A429:TRIG:TYPE"        },
    { AGX2K3K_ATTR_A429_BASE,                               ":%s:A429:BASE"             },
    { AGX2K3K_ATTR_M1553_BASE,                              ":%s:M1553:BASE"            },
    { AGX2K3K_ATTR_M1553_SOURCE,                            ":%s:M1553:SOUR"            },
    { AGX2K3K_ATTR_A429_FORMAT,                             ":%s:A429:FORM"             },
    { AGX2K3K_ATTR_A429_SIGNAL,                             ":%s:A429:SIGN"             },
    { AGX2K3K_ATTR_A429_SOURCE,                             ":%s:A429:SOUR"             },
    { AGX2K3K_ATTR_A429_SPEED,                              ":%s:A429:SPE"              },
    { AGX2K3K_ATTR_FLEXRAY_BAUDRATE,                        ":%s:FLEX:BAUD"             },
    { AGX2K3K_ATTR_FLEXRAY_CHANNEL,                         ":%s:FLEX:CHAN"             },
    { AGX2K3K_ATTR_FLEXRAY_SOURCE,                          ":%s:FLEX:SOUR"             },
    { AGX2K3K_ATTR_FLEXRAY_TRIGGER,                         ":%s:FLEX:TRIG"             },
    { AGX2K3K_ATTR_FLEXRAY_TRIGGER_ERROR_TYPE,              ":%s:FLEX:TRIG:ERR:TYPE"    },
    { AGX2K3K_ATTR_FLEXRAY_TRIGGER_EVENT_TYPE,              ":%s:FLEX:TRIG:EVEN:TYPE"   },
    { AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_CCREPETITION,      ":%s:FLEX:TRIG:FRAM:CCR"    },
    { AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_TYPE,              ":%s:FLEX:TRIG:FRAM:TYPE"   },


    /* New attributes added in version 3.0 */
    { AGX2K3K_ATTR_DVM_MODE,                                ":DVM:MODE"                 },
    { AGX2K3K_ATTR_DVM_ANALOG_SOURCE,                       ":DVM:SOUR"                 },
    { AGX2K3K_ATTR_REFERENCE_SIGNAL_MODE,                   ":ACQ:RSIG"                 },
    { AGX2K3K_ATTR_MEASURE_INFORMATION_TYPE,                ":MEAS:STAT"                },
    { AGX2K3K_ATTR_POWER_HARMONICS_FAIL_PASS_STATUS,        ":POW:HARM:STAT"            },
    { AGX2K3K_ATTR_SBUS_FLEX_EVENT_TRIGGER_MODE,            "%s:FLEX:TRIG:EVEN:TYPE"    },
    { AGX2K3K_ATTR_SBUS_USB_BASE,                           "%s:USB:BASE"               },
    { AGX2K3K_ATTR_SBUS_USB_DIFFERENTIAL_SOURCE,            "%s:USB:SOUR:DIFF"          },
    { AGX2K3K_ATTR_SBUS_USB_D_MINUS_SOURCE,                 "%s:USB:SOUR:DMIN"          },
    { AGX2K3K_ATTR_SBUS_USB_D_PLUS_SOURCE,                  "%s:USB:SOUR:DPL"           },
    { AGX2K3K_ATTR_SBUS_USB_SPEED,                          "%s:USB:SPE"                },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_MODE,                   "%s:USB:TRIG"               },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PID,               "%s:USB:TRIG:PID:DATA"      },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_HANDSHAKE_PID,          "%s:USB:TRIG:PID:HAND"      },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_SPECIAL_PID,            "%s:USB:TRIG:PID:SPEC"      },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_TOKEN_PID,              "%s:USB:TRIG:PID:TOK"       },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_SEARCH_MODE,           ":SEAR:SER:USB:MODE"        },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_PID,              ":SEAR:SER:USB:PID:DATA"    },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_HANDSHAKE_PID,         ":SEAR:SER:USB:PID:HAND"    },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_SPECIAL_PID,           ":SEAR:SER:USB:PID:SPEC"    },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_TOKEN_PID,             ":SEAR:SER:USB:PID:TOK"     },
    { AGX2K3K_ATTR_WAVEGEN_STORE_ARB_WAVEFORM,              "%s:ARB:STOR"               },
    { AGX2K3K_ATTR_WAVEGEN_MODULATION_SIGNAL_SHAPE,         "%s:MOD:FUNC"               },
    { AGX2K3K_ATTR_WAVEGEN_MODULATION_TYPE,                 "%s:MOD:TYPE"               },
    { AGX2K3K_ATTR_INTERPOLATION,                           "%s:ARB:INT"                },
    { AGX2K3K_ATTR_WAVEGEN_OUTPUT_POLARITY_INVERTED,        "%s:OUTP:POL"               },

    /* New attributes added in version 3.1 */
    { AGX2K3K_ATTR_CHANNEL_PROBE_TEK_MODEL,                 "%s:PROB:MMOD"              },
    { AGX2K3K_ATTR_COUNTER_MODE,                            ":COUN:MODE",               },
    { AGX2K3K_ATTR_COUNTER_SOURCE,                          ":COUN:SOUR",               },
    { AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_SOURCE,            ":COUN:TOT:GATE:SOUR"       },
    { AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_POLARITY,          ":COUN:TOT:GATE:POL",       },
    { AGX2K3K_ATTR_COUNTER_TOTALIZE_SLOPE,                  ":COUN:TOT:SLOP",           },
    { AGX2K3K_ATTR_FFT_DISPLAY_MODE,                        ":FFT:DMOD",                },
    { AGX2K3K_ATTR_FFT_SOURCE1,                             ":FFT:SOUR1",               },
    { AGX2K3K_ATTR_FFT_VERTICAL_UNIT,                       ":FFT:VTYP",                },
    { AGX2K3K_ATTR_FFT_WINDOW,                              ":FFT:WIND",                },
    { AGX2K3K_ATTR_POWER_EFFICIENCY_TYPE,                   ":POW:EFF:TYPE",            },
    { AGX2K3K_ATTR_POWER_HARMONICS_REAL_POWER_TYPE,         ":POW:HARM:RPOW",           },
    { AGX2K3K_ATTR_SBUS_CAN_DISPLAY,                        "%s:CAN:DISP"               },
    { AGX2K3K_ATTR_SBUS_LIN_DISPLAY,                        "%s:LIN:DISP"               },
    { AGX2K3K_ATTR_SBUS_SENT_CRC,                           "%s:SENT:CRC"               },
    { AGX2K3K_ATTR_SBUS_SENT_DISPLAY,                       "%s:SENT:DISP"              },
    { AGX2K3K_ATTR_SBUS_SENT_FORMAT,                        "%s:SENT:FORM"              },
    { AGX2K3K_ATTR_SBUS_SENT_IDLE,                          "%s:SENT:IDLE"              },
    { AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_LENGTH,           "%s:SENT:TRIG:SLOW:ILEN"    },
    { AGX2K3K_ATTR_SBUS_SENT_TRIGGER,                       "%s:SENT:TRIG"              },
    { AGX2K3K_ATTR_SBUS_SENT_SOURCE,                        "%s:SENT:SOUR"              },
    { AGX2K3K_ATTR_SEARCH_SERIAL_SENT_MODE,                 ":SEAR:SER:SENT:MODE",      },
    { AGX2K3K_ATTR_SEARCH_PEAK_SOURCE,                      ":SEAR:PEAK:SOUR",          },
    { AGX2K3K_ATTR_TRIGGER_ZONE_SOURCE,                     ":TRIG:ZONE:SOUR"           },
    { AGX2K3K_ATTR_TRIGGER_ZONE_MODE,                       ":TRIG:%s:MODE"             },
    { AGX2K3K_ATTR_WAVEGEN_OUTPUT_MODE,                     "%s:OUTP:MODE"              },
    { AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_ADJACENT,          ":COMP:USB:SOUR:ADJ",       },
    { AGX2K3K_ATTR_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE,      ":COMP:USB:TEST",           },
    { AGX2K3K_ATTR_COMPLIANCE_USB_TEST_CONNECTION,          ":COMP:USB:TEST:CONN",      },
    { AGX2K3K_ATTR_COMPLIANCE_USB_TEST_TYPE,                ":COMP:USB:TEST:TYPE",      },
    { AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DIFFERENTIAL,      ":COMP:USB:SOUR:DIFF",      },
    { AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DMINUS,            ":COMP:USB:SOUR:DMIN",      },
    { AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DPLUS,             ":COMP:USB:SOUR:DPL",       },

    /* New attributes added in version 3.2 */
    { AGX2K3K_ATTR_HISTOGRAM_MEASUREMENT,                   ":HIST:MEAS"                },
    { AGX2K3K_ATTR_HISTOGRAM_MODE,                          ":HIST:MODE"                },
    { AGX2K3K_ATTR_HISTOGRAM_AXIS,                          ":HIST:AXIS"                },
    { AGX2K3K_ATTR_JITTER_MEASUREMENT,                      ":JITT:MEAS"                },
    { AGX2K3K_ATTR_WAVEFORM_SOURCE_SUBSOURCE,               ":WAV:SOUR:SUBS"            },

    { VI_NULL,                                              VI_NULL                     }
};

/*- Table of commands for ViInt32 attributes --------------------------------*/
static IviStringValueTable gs_ViInt32Commands =
{
    { AGX2K3K_ATTR_TV_TRIGGER_LINE_NUMBER,              ":TRIG:TV:LINE"               },
    { AGX2K3K_ATTR_SBUS_UART_WIDTH,                     ":%s:UART:WIDT"               },
    { AGX2K3K_ATTR_SBUS_CAN_BAUDRATE,                   ":%s:CAN:SIGN:BAUD"           },
    { AGX2K3K_ATTR_SBUS_CAN_DATA_LENGTH,                ":%s:CAN:TRIG:PATT:DATA:LENG" },
    { AGX2K3K_ATTR_SBUS_I2S_RECEIVER_WIDTH,             ":%s:I2S:RWID"                },
    { AGX2K3K_ATTR_SBUS_I2S_TRANSMIT_WIDTH,             ":%s:I2S:TWID"                },
    { AGX2K3K_ATTR_SBUS_IIC_ADDRESS,                    ":%s:IIC:TRIG:PATT:ADDR"      },
    { AGX2K3K_ATTR_SBUS_IIC_DATA,                       ":%s:IIC:TRIG:PATT:DATA"      },
    { AGX2K3K_ATTR_SBUS_IIC_DATA2,                      ":%s:IIC:TRIG:PATT:DAT2"      },
    { AGX2K3K_ATTR_SBUS_LIN_BAUDRATE,                   ":%s:LIN:SIGN:BAUD"           },
    { AGX2K3K_ATTR_SBUS_LIN_TRIGGER_ID,                 ":%s:LIN:TRIG:ID"             },
    { AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA_LENGTH,        ":%s:LIN:TRIG:PATT:DATA:LENG" },
    { AGX2K3K_ATTR_SBUS_SPI_MISO_WIDTH,                 ":%s:SPI:TRIG:PATT:MISO:WIDT" },
    { AGX2K3K_ATTR_SBUS_SPI_MOSI_WIDTH,                 ":%s:SPI:TRIG:PATT:MOSI:WIDT" },
    { AGX2K3K_ATTR_SBUS_SPI_WORD_WIDTH,                 ":%s:SPI:WIDT"                },
    { AGX2K3K_ATTR_SBUS_UART_COUNT_ERROR,               ":%s:UART:COUN:ERR"           }, /*  Read only */
    { AGX2K3K_ATTR_SBUS_UART_COUNT_TX,                  ":%s:UART:COUN:TXFR"          }, /*  Read only */
    { AGX2K3K_ATTR_SBUS_UART_COUNT_RX,                  ":%s:UART:COUN:RXFR"          }, /*  Read only */
    { AGX2K3K_ATTR_SBUS_UART_FRAMING,                   ":%s:UART:FRAM"               },
    { AGX2K3K_ATTR_SBUS_UART_TRIGGER_BURST,             ":%s:UART:TRIG:BURS"          },
    { AGX2K3K_ATTR_SBUS_UART_TRIGGER_DATA,              ":%s:UART:TRIG:DATA"          },
    { AGX2K3K_ATTR_NUM_AVERAGES,                        ":ACQ:COUN"                   },
    { AGX2K3K_ATTR_INSTR_ACQUISITION_POINTS,            ":ACQ:POIN"                   },
    { AGX2K3K_ATTR_DIG_POSITION,                        ":%s:POS"                     },
    { AGX2K3K_ATTR_HORZ_RECORD_LENGTH,                  ":WAV:POIN"                   },
    { AGX2K3K_ATTR_EBURST_COUNT,                        ":TRIG:EBUR:COUN"             },
    { AGX2K3K_ATTR_SEGMENT_COUNT,                       ":ACQ:SEGM:COUN"              }, /*  option SGM */
    { AGX2K3K_ATTR_SEGMENT_INDEX,                       ":ACQ:SEGM:IND"               }, /*  option SGM */
    { AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW,          ":%s:I2S:TRIG:RANG"           },
    { AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH,         ":%s:I2S:TRIG:RANG"           },
    { AGX2K3K_ATTR_SBUS_UART_BAUDRATE,                  ":%s:UART:BAUD"               },

    /* New attributes added in version 2.0 */
    { AGX2K3K_ATTR_WGEN_MODULATION_NOISE,               ":WGEN:MOD:NOIS"              },
    { AGX2K3K_ATTR_WGEN_MODULATION_NOISE_MULTICHANNEL,  ":%s:MOD:NOIS"                }, /* added in version 3.0 */
    { AGX2K3K_ATTR_SEARCH_SERIAL_A429_LABEL,            ":SEAR:SER:A429:LAB"          },
    { AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_DATA_LENGTH,   ":SEAR:SER:FLEX:DATA:LENG"    },
    { AGX2K3K_ATTR_SEARCH_SERIAL_M1553_RTA,             ":SEAR:SER:M1553:RTA"         },
    { AGX2K3K_ATTR_TRIGGER_TV_UDTV_ENUMBER,             ":TRIG:TV:UDTV:ENUM"          },
    { AGX2K3K_ATTR_TRIGGER_DELAY_TRIGGER_COUNT,         ":TRIG:DEL:TRIG:COUN"         },
    { AGX2K3K_ATTR_POWER_SIGNALS_OVERSHOOT,             ":POW:SIGN:OVER"              },
    { AGX2K3K_ATTR_POWER_SIGNALS_CYCLES,                ":POW:SIGN:CYCL"              },
    { AGX2K3K_ATTR_POWER_PSRR_RMAX,                     ":POW:PSRR:RMAX"              },
    { AGX2K3K_ATTR_POWER_SWITCH_IREFERENCE,             ":POW:SWIT:IREF"              },
    { AGX2K3K_ATTR_POWER_SWITCH_VREFERENCE,             ":POW:SWIT:VREF"              },
    { AGX2K3K_ATTR_M1553_TRIGGER_RTA,                   ":%s:M1553:TRIG:RTA"          },
    { AGX2K3K_ATTR_M1553_TRIGGER_TYPE,                  ":%s:M1553:TRIG:TYPE"         },
    { AGX2K3K_ATTR_FLEXRAY_NULL_COUNT,                  ":%s:FLEX:COUN:NULL"          },
    { AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_CC_BASE,       ":%s:FLEX:TRIG:FRAM:CCB"      },

    /* New attributes added in version 3.0 */
    { AGX2K3K_ATTR_FUNCTION_NUM_AVERAGES,               "%s:AVER:COUN"                },
    { AGX2K3K_ATTR_POWER_HARMONICS_FAIL_COUNT,          ":POW:HARM:FAIL"              },
    { AGX2K3K_ATTR_POWER_HARMONICS_RUN_ITERATION_COUNT, ":POW:HARM:RUNC"              },
    { AGX2K3K_ATTR_POWER_HARMONICS_CYCLE_COUNT,         ":POW:SIGN:CYCL:HARM"         },
    { AGX2K3K_ATTR_POWER_QUALITY_CYCLE_COUNT,           ":POW:SIGN:CYCL:QUAL"         },
    { AGX2K3K_ATTR_SBUS_A429_ERROR_COUNT,               "%s:A429:COUN:ERR"            },
    { AGX2K3K_ATTR_SBUS_A429_WORD_COUNT,                "%s:A429:COUN:WORD"           },
    { AGX2K3K_ATTR_SBUS_FLEX_SYNC_FRAME_COUNT,          "%s:FLEX:COUN:SYNC"           },
    { AGX2K3K_ATTR_SBUS_FLEX_TOTAL_FRAME_COUNT,         "%s:FLEX:COUN:TOT"            },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_LENGTH,       ":SEAR:SER:USB:DATA:LENG"     },
    { AGX2K3K_ATTR_WAVEGEN_ARB_WAVEFORM_POINT_COUNT,    "%s:ARB:DATA:ATTR:POIN"       },
    { AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_COUNT,         "%s:MOD:AM:DEPT"              },
    { AGX2K3K_ATTR_WAVEGEN_MODULATION_RAMP_SYMMETRY,    "%s:MOD:FUNC:RAMP:SYMM"       },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_LENGTH,        "%s:USB:TRIG:DATA:LENG"       },

    /* New attributes added in version 3.1 */
    { AGX2K3K_ATTR_COUNTER_NUMBER_OF_DIGITS,            ":COUN:NDIG"                  },
    { AGX2K3K_ATTR_POWER_CLRESPONSE_FREQUENCY_START,    ":POW:CLR:FREQ:STAR"          },
    { AGX2K3K_ATTR_POWER_CLRESPONSE_FREQUENCY_STOP,     ":POW:CLR:FREQ:STOP"          },
    { AGX2K3K_ATTR_POWER_CLRESPONSE_YMAXIMUM,           ":POW:CLR:YMAX"               },
    { AGX2K3K_ATTR_POWER_CLRESPONSE_YMINIMUM,           ":POW:CLR:YMIN"               },
    { AGX2K3K_ATTR_MATH_SMOOTH_POINTS,                  "%s:SMO:POIN"                 },
    { AGX2K3K_ATTR_SBUS_CAN_SIGNAL_FD_BAUDRATE,         "%s:CAN:SIGN:FDB"             },
    { AGX2K3K_ATTR_SBUS_CAN_TRIGGER_PATTERN_DATA_DLC,   "%s:CAN:TRIG:PATT:DATA:DLC"   },
    { AGX2K3K_ATTR_SBUS_CAN_TRIGGER_PATTERN_DATA_START, "%s:CAN:TRIG:PATT:DATA:STAR"  },
    { AGX2K3K_ATTR_SBUS_SENT_LENGTH,                    "%s:SENT:LENG"                },
    { AGX2K3K_ATTR_SBUS_SENT_TRIGGER_TOLERANCE,         "%s:SENT:TRIG:TOL"            },
    { AGX2K3K_ATTR_SBUS_SENT_TOLERANCE,                 "%s:SENT:TOL"                 },
    { AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_DATA,         "%s:SENT:TRIG:SLOW:DATA"      },
    { AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_ID,           "%s:SENT:TRIG:SLOW:ID"        },
    { AGX2K3K_ATTR_SEARCH_EVENT,                        ":SEAR:EVEN"                  },
    { AGX2K3K_ATTR_SEARCH_PEAK_MAXIMUM_PEAKS,           ":SEAR:PEAK:NPE"              },
    { AGX2K3K_ATTR_SEARCH_SERIAL_SENT_SLOW_DATA,        ":SEAR:SER:SENT:SLOW:DATA"    },
    { AGX2K3K_ATTR_SEARCH_SERIAL_SENT_SLOW_ID,          ":SEAR:SER:SENT:SLOW:ID"      },
    { AGX2K3K_ATTR_WAVEGEN_TRACK_PHASE,                 "%s:TRAC:PHAS"                },
    { AGX2K3K_ATTR_COMPLIANCE_USB_HUBS,                 ":COMP:USB:HUBS"              },
    { AGX2K3K_ATTR_FFT_AVERAGE_COUNT,                   ":FFT:AVER:COUN"              },

    /* New attributes added in version 3.2 */
    { AGX2K3K_ATTR_SYSTEM_PRECISION_LENGTH,             ":SYST:PREC:LENG"             },

    { VI_NULL,                                          VI_NULL                       }
};

/*- Table of commands for ViReal64 attributes -------------------------------*/
static IviStringValueTable gs_ViReal64Commands =
{
    { AGX2K3K_ATTR_TIMEBASE_POSITION,                       ":TIM:POS"                },
    { AGX2K3K_ATTR_TIMEBASE_SCALE,                          ":TIM:SCAL"               },
    { AGX2K3K_ATTR_WIN_TIMEBASE_POSITION,                   ":TIM:WIND:POS"           },
    { AGX2K3K_ATTR_WIN_TIMEBASE_RANGE,                      ":TIM:WIND:RANG"          },
    { AGX2K3K_ATTR_WIN_TIMEBASE_SCALE,                      ":TIM:WIND:SCAL"          },
    { AGX2K3K_ATTR_TRIGGER_HOLDOFF,                         ":TRIG:HOLD"              },
    { AGX2K3K_ATTR_SETUPHOLD_HOLD_TIME,                     ":TRIG:SHOL:TIME:HOLD"    },
    { AGX2K3K_ATTR_SETUPHOLD_SETUP_TIME,                    ":TRIG:SHOL:TIME:SET"     },
    { AGX2K3K_ATTR_HORZ_TIME_PER_RECORD,                    ":TIM:RANG"               },
    { AGX2K3K_ATTR_HORZ_SAMPLE_RATE,                        ":ACQ:SRAT"               },
    { AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_LEVEL,                ":TRIG:EDGE:LEV"          },
    { AGX2K3K_ATTR_EBURST_IDLE,                             ":TRIG:EBUR:IDLE"         },
    { AGX2K3K_ATTR_GLITCH_MIN_WIDTH,                        ":TRIG:GLIT:GRE"          },
    { AGX2K3K_ATTR_GLITCH_WIDTH,                            ":TRIG:GLIT:LESS"         },
    { AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_LEVEL,              ":TRIG:GLIT:LEV"          },
    { AGX2K3K_ATTR_PATTERN_MIN,                             ":TRIG:PATT:GRE"          },
    { AGX2K3K_ATTR_PATTERN_MAX,                             ":TRIG:PATT:LESS"         },
    { AGX2K3K_ATTR_TRIGGER_LEVEL_HIGH,                      ":TRIG:LEV:HIGH"          },
    { AGX2K3K_ATTR_TRIGGER_LEVEL_LOW,                       ":TRIG:LEV:LOW"           },
    { AGX2K3K_ATTR_RUNT_TIME,                               ":TRIG:RUNT:TIME"         },
    { AGX2K3K_ATTR_TRANSITION_TIME,                         ":TRIG:TRAN:TIME"         },
    { AGX2K3K_ATTR_SBUS_SPI_TIMEOUT,                        ":%s:SPI:CLOC:TIM"        },
    { AGX2K3K_ATTR_INSTR_PROBE_ATTENUATION,                 ":%s:PROB"                },
    { AGX2K3K_ATTR_PROBE_SKEW,                              ":%s:PROB:SKEW"           },
    { AGX2K3K_ATTR_VERTICAL_RANGE,                          ":%s:RANG"                },
    { AGX2K3K_ATTR_VERTICAL_OFFSET,                         ":%s:OFFS"                },
    { AGX2K3K_ATTR_MATH_SCALE,                              ":FUNC:SCAL"              },
    { AGX2K3K_ATTR_MATH_SCALE_MULTICHANNEL,                 ":%s:SCAL"                }, /* added in version 3.0 */
    { AGX2K3K_ATTR_MATH_OFFSET,                             ":FUNC:OFFS"              },
    { AGX2K3K_ATTR_MATH_OFFSET_MULTICHANNEL,                ":%s:OFFS"                }, /* added in version 3.0 */
    { AGX2K3K_ATTR_MATH_SPAN,                               ":FUNC:SPAN"              },
    { AGX2K3K_ATTR_MATH_SPAN_MULTICHANNEL,                  ":%s:SPAN"                }, /* added in version 3.0 */
    { AGX2K3K_ATTR_MATH_CENTER,                             ":FUNC:CENT"              },
    { AGX2K3K_ATTR_MATH_CENTER_MULTICHANNEL,                ":%s:CENT"                }, /* added in version 3.0 */
    { AGX2K3K_ATTR_SBUS_UART_TRIGGER_IDLE,                  ":%s:UART:TRIG:IDLE"      },
    { AGX2K3K_ATTR_WAVEGEN_PERIOD,                          ":WGEN:PER"               },
    { AGX2K3K_ATTR_WAVEGEN_PERIOD_MULTICHANNEL,             ":%s:PER"                 }, /* added in version 3.0 */
    { AGX2K3K_ATTR_WAVEGEN_VOLTAGE,                         ":WGEN:VOLT"              },
    { AGX2K3K_ATTR_WAVEGEN_VOLTAGE_MULTICHANNEL,            ":%s:VOLT"                }, /* added in version 3.0 */
    { AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH,                    ":WGEN:VOLT:HIGH"         },
    { AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH_MULTICHANNEL,       ":%s:VOLT:HIGH"           }, /* added in version 3.0 */
    { AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW,                     ":WGEN:VOLT:LOW"          },
    { AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW_MULTICHANNEL,        ":%s:VOLT:LOW"            }, /* added in version 3.0 */
    { AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET,                  ":WGEN:VOLT:OFFS"         },
    { AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET_MULTICHANNEL,     ":%s:VOLT:OFFS"           }, /* added in version 3.0 */
    { AGX2K3K_ATTR_WAVEGEN_FREQUENCY,                       ":WGEN:FREQ"              },
    { AGX2K3K_ATTR_WAVEGEN_FREQUENCY_MULTICHANNEL,          ":%s:FREQ"                }, /* added in version 3.0 */
    { AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH,                     ":WGEN:FUNC:PULS:WIDT"    },
    { AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH_MULTICHANNEL,        ":%s:FUNC:PULS:WIDT"      }, /* added in version 3.0 */
    { AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY,                   ":WGEN:FUNC:RAMP:SYMM"    },
    { AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY_MULTICHANNEL,      ":%s:FUNC:RAMP:SYMM"      }, /* added in version 3.0 */
    { AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE,               ":WGEN:FUNC:SQU:DCYC"     },
    { AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE_MULTICHANNEL,  ":%s:FUNC:SQU:DCYC"       }, /* added in version 3.0 */
    { AGX2K3K_ATTR_WMEMORY_SKEW,                            ":%s:SKEW"                },
    { AGX2K3K_ATTR_WMEMORY_Y_OFFSET,                        ":%s:YOFF"                },
    { AGX2K3K_ATTR_WMEMORY_Y_RANGE,                         ":%s:YRAN"                },
    { AGX2K3K_ATTR_WMEMORY_Y_SCALE,                         ":%s:YSC"                 },
    { AGX2K3K_ATTR_DIG_THRESHOLD,                           ":%s:THR"                 },

    /* New attributes added in version 2.0 */
    { AGX2K3K_ATTR_TRIGGER_TV_UDTV_HTIME,                   ":TRIG:TV:UDTV:HTIM"      },
    { AGX2K3K_ATTR_TRIGGER_TV_UDTV_PGTHAN,                  ":TRIG:TV:UDTV:PGTH"      },
    { AGX2K3K_ATTR_TRIGGER_DELAY_TDELAY_TIME,               ":TRIG:DEL:TDEL:TIME"     },
    { AGX2K3K_ATTR_FUNCTION_BUS_YINCREMENT,                 ":FUNC:BUS:YINC"          },
    { AGX2K3K_ATTR_FUNCTION_BUS_YINCREMENT_MULTICHANNEL,    ":%s:BUS:YINC"            }, /* added in version 3.0 */
    { AGX2K3K_ATTR_FUNCTION_BUS_YORIGIN,                    ":FUNC:BUS:YOR"           },
    { AGX2K3K_ATTR_FUNCTION_BUS_YORIGIN_MULTICHANNEL,       ":%s:BUS:YOR"             }, /* added in version 3.0 */
    { AGX2K3K_ATTR_FUNCTION_FREQ_HIGHPASS,                  ":FUNC:FREQ:HIGH"         },
    { AGX2K3K_ATTR_FUNCTION_FREQ_HIGHPASS_MULTICHANNEL,     ":%s:FREQ:HIGH"           }, /* added in version 3.0 */
    { AGX2K3K_ATTR_FUNCTION_FREQ_LOWPASS,                   ":FUNC:FREQ:LOWP"         },
    { AGX2K3K_ATTR_FUNCTION_FREQ_LOWPASS_MULTICHANNEL,      ":%s:FREQ:LOWP"           }, /* added in version 3.0 */
    { AGX2K3K_ATTR_FUNCTION_LINEAR_GAIN,                    ":FUNC:LIN:GAIN"          },
    { AGX2K3K_ATTR_FUNCTION_LINEAR_GAIN_MULTICHANNEL,       ":%s:LIN:GAIN"            }, /* added in version 3.0 */
    { AGX2K3K_ATTR_FUNCTION_LINEAR_OFFSET,                  ":FUNC:LIN:OFFS"          },
    { AGX2K3K_ATTR_FUNCTION_LINEAR_OFFSET_MULTICHANNEL,     ":%s:LIN:OFFS"            }, /* added in version 3.0 */
    { AGX2K3K_ATTR_FUNCTION_INTEGRATE_IOFFSET,              ":FUNC:INT:IOFF"          },
    { AGX2K3K_ATTR_FUNCTION_INTEGRATE_IOFFSET_MULTICHANNEL, ":%s:INT:IOFF"            }, /* added in version 3.0 */
    { AGX2K3K_ATTR_POWER_SIGNALS_VMAXIMUM,                  ":POW:SIGN:VMAX"          },
    { AGX2K3K_ATTR_POWER_SIGNALS_VSTEADY,                   ":POW:SIGN:VST"           },
    { AGX2K3K_ATTR_POWER_SIGNALS_IEXPECTED,                 ":POW:SIGN:IEXP"          },
    { AGX2K3K_ATTR_POWER_SIGNALS_DURATION,                  ":POW:SIGN:DUR"           },
    { AGX2K3K_ATTR_POWER_SWITCH_RDS,                        ":POW:SWIT:RDS"           },
    { AGX2K3K_ATTR_POWER_SWITCH_VCE,                        ":POW:SWIT:VCE"           },
    { AGX2K3K_ATTR_POWER_TRANSIENT_IINITIAL,                ":POW:TRAN:IIN"           },
    { AGX2K3K_ATTR_POWER_TRANSIENT_INEW,                    ":POW:TRAN:INEW"          },
    { AGX2K3K_ATTR_A429_TRIGGER_LABEL,                      ":%s:A429:TRIG:LAB"       },

    /* New attributes added in version 3.0 */
    { AGX2K3K_ATTR_DVM_CURRENT,                             ":DVM:CURR"               },
    { AGX2K3K_ATTR_DVM_FREQUENCY,                           ":DVM:FREQ"               },
    { AGX2K3K_ATTR_FUNCTION_VERTICAL_AXIS,                  "%s:RANG"                 },
    { AGX2K3K_ATTR_FUNCTION_REFERENCE_LEVEL,                "%s:REF"                  },
    { AGX2K3K_ATTR_MEASURE_POWER_PHASE_ANGLE,               ":MEAS:ANGL"              },
    { AGX2K3K_ATTR_MEASURE_APPARENT_POWER,                  ":MEAS:APP"               },
    { AGX2K3K_ATTR_MEASURE_AREA,                            ":MEAS:ARE"               },
    { AGX2K3K_ATTR_MEASURE_POWER_LOSS_PER_CYCLE,            ":MEAS:CPL"               },
    { AGX2K3K_ATTR_MEASURE_CREST_FACOTR,                    ":MEAS:CRES"              },
    { AGX2K3K_ATTR_MEASURE_ENERGY_LOSS,                     ":MEAS:ELOS"              },
    { AGX2K3K_ATTR_MEASURE_POWER_FACTOR,                    ":MEAS:FACT"              },
    { AGX2K3K_ATTR_MEASURE_INPUT_POWER,                     ":MEAS:IPOW"              },
    { AGX2K3K_ATTR_MEASURE_OFF_TIME,                        ":MEAS:OFFT"              },
    { AGX2K3K_ATTR_MEASURE_ON_TIME,                         ":MEAS:ONT"               },
    { AGX2K3K_ATTR_MEASURE_OUTPUT_POWER,                    ":MEAS:OPOW"              },
    { AGX2K3K_ATTR_MEASURE_POWER_LOSS,                      ":MEAS:PLOS"              },
    { AGX2K3K_ATTR_MEASURE_REACTIVE_POWER,                  ":MEAS:REAC"              },
    { AGX2K3K_ATTR_MEASURE_REAL_POWER,                      ":MEAS:REAL"              },
    { AGX2K3K_ATTR_POWER_HARMONICS_POWER_FACTOR,            ":POW:HARM:POW"           },
    { AGX2K3K_ATTR_POWER_HARMONICS_TOTAL_DISTORTION,        ":POW:HARM:THD"           },
    { AGX2K3K_ATTR_POWER_EFFICIENCY_DURATION,               ":POW:SIGN:DUR:EFF"       },
    { AGX2K3K_ATTR_POWER_MODULATION_DURATION,               ":POW:SIGN:DUR:MOD"       },
    { AGX2K3K_ATTR_POWER_OFF_DURAQTION,                     ":POW:SIGN:DUR:ONOF:OFF"  },
    { AGX2K3K_ATTR_POWER_ON_DURATION,                       ":POW:SIGN:DUR:ONOF:ON"   },
    { AGX2K3K_ATTR_POWER_RIPPLE_DURATION,                   ":POW:SIGN:DUR:RIPP"      },
    { AGX2K3K_ATTR_POWER_TRANSIENT_DURATION,                ":POW:SIGN:DUR:TRAN"      },
    { AGX2K3K_ATTR_POWER_IRUSH_AMPLITUDE,                   ":POW:SIGN:IEXP"          },
    { AGX2K3K_ATTR_POWER_IRUSH_MAX_VOLTAGE,                 ":POW:SIGN:VMAX:INR"      },
    { AGX2K3K_ATTR_POWER_OFF_MAX_VOLTAGE,                   ":POW:SIGN:VMAX:ONOF:OFF" },
    { AGX2K3K_ATTR_POWER_ON_MAX_VOLTAGE,                    ":POW:SIGN:VMAX:ONOF:ON"  },
    { AGX2K3K_ATTR_POWER_OFF_DC_VOLTAGE,                    ":POW:SIGN:VST:ONOF:OFF"  },
    { AGX2K3K_ATTR_POWER_ON_DC_VOLTAGE,                     ":POW:SIGN:VST:ONOF:ON"   },
    { AGX2K3K_ATTR_POWER_TRANSIENT_DC_VOLTAGE,              ":POW:SIGN:VST:TRAN"      },
    { AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_FREQUENCY,         "%s:MOD:AM:FREQ"          },
    { AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_DEVIATION,         "%s:MOD:FM:DEV"           },
    { AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_FREQUENCY,         "%s:MOD:FM:FREQ"          },
    { AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_HOP_FREQUENCY,  "%s:MOD:FSK:FREQ"         },
    { AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_RATE,           "%s:MOD:FSK:RATE"         },

    /* New attributes added in version 3.1 */
    { AGX2K3K_ATTR_FFT_FREQUENCY_START,                     ":FFT:FREQ:STAR"          },
    { AGX2K3K_ATTR_FFT_FREQUENCY_STOP,                      ":FFT:FREQ:STOP"          },
    { AGX2K3K_ATTR_FFT_VERTICAL_OFFSET,                     ":FFT:OFFS"               },
    { AGX2K3K_ATTR_FFT_VERTICAL_RANGE,                      ":FFT:RANG"               },
    { AGX2K3K_ATTR_FFT_VERTICAL_REFERENCE,                  ":FFT:REF"                },
    { AGX2K3K_ATTR_FFT_VERTICAL_SCALE,                      ":FFT:SCAL"               },
    { AGX2K3K_ATTR_FFT_FREQUENCY_SPAN,                      ":FFT:SPAN"               },
    { AGX2K3K_ATTR_FFT_FREQUENCY_CENTER,                    ":FFT:CENT"               },
    { AGX2K3K_ATTR_MATH_FFT_FREQUENCY_START,                "%s:FREQ:STAR"            },
    { AGX2K3K_ATTR_MATH_FFT_FREQUENCY_STOP,                 "%s:FREQ:STOP"            },
    { AGX2K3K_ATTR_POWER_HARMONICS_REAL_POWER_VALUE,        ":POW:HARM:RPOW:USER"     },
    { AGX2K3K_ATTR_SBUS_CAN_FD_SAMPLE_POINT,                "%s:CAN:FDSP"             },
    { AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_VALUE,         "%s:CAN:TRIG:SYMB:VAL"    },
    { AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_VALUE,         "%s:LIN:TRIG:SYMB:VAL"    },
    { AGX2K3K_ATTR_SBUS_SENT_CLOCK,                         "%s:SENT:CLOC"            },
    { AGX2K3K_ATTR_SEARCH_PEAK_EXCURSION,                   ":SEAR:PEAK:EXC"          },
    { AGX2K3K_ATTR_SEARCH_PEAK_THRESHOLD,                   ":SEAR:PEAK:THR"          },
    { AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_VALUE,        ":SEAR:SER:CAN:SYMB:VAL"  },
    { AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_VALUE,        ":SEAR:SER:LIN:SYMB:VAL"  },

    /* New attributes added in version 3.2 */
    { AGX2K3K_ATTR_CHANNEL_BANDWIDTH,                       ":%s:BAND"                },
    { AGX2K3K_ATTR_HISTOGRAM_WINDOW_BLIMIT,                 ":HIST:WIND:BLIM"         },
    { AGX2K3K_ATTR_HISTOGRAM_WINDOW_LLIMIT,                 ":HIST:WIND:LLIM"         },
    { AGX2K3K_ATTR_HISTOGRAM_WINDOW_RLIMIT,                 ":HIST:WIND:RLIM"         },
    { AGX2K3K_ATTR_HISTOGRAM_WINDOW_TLIMIT,                 ":HIST:WIND:TLIM"         },

    { VI_NULL,                                              VI_NULL                   }
};

/*- Table of commands for ViBoolean attributes ------------------------------*/
static IviStringValueTable gs_ViBooleanCommands =
{
    { AGX2K3K_ATTR_TIMEBASE_VERNIER,                        ":TIM:VERN"           },
    { AGX2K3K_ATTR_TRIGGER_NOISE_REJECT,                    ":TRIG:NREJ"          },
    { AGX2K3K_ATTR_TRIGGER_HF_REJECT,                       ":TRIG:HFR"           },
    { AGX2K3K_ATTR_CHANNEL_ENABLED,                         ":%s:DISP"            },
    { AGX2K3K_ATTR_INSTR_BW_LIMIT,                          ":%s:BWL"             },
    { AGX2K3K_ATTR_VERNIER,                                 ":%s:VERN"            },
    { AGX2K3K_ATTR_INVERT,                                  ":%s:INV"             },
    { AGX2K3K_ATTR_MATH_CHANNEL_ENABLED,                    ":FUNC:DISP"          },
    { AGX2K3K_ATTR_MATH_CHANNEL_ENABLED_MULTICHANNEL,       ":%s:DISP"            }, /* added in version 3.0 */
    { AGX2K3K_ATTR_DIG_CHANNEL_ENABLED,                     ":%s:DISP"            },
    { AGX2K3K_ATTR_SBUS_LIN_PARITY,                         ":%s:LIN:PAR"         },
    { AGX2K3K_ATTR_SBUS_UART_COUNT_RESET,                   ":%s:UART:COUN:RES"   },
    { AGX2K3K_ATTR_WAVEGEN_RESET,                           ":WGEN:RST"           },
    { AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE,                   ":WGEN:OUTP"          },
    { AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE_MULTICHANNEL,      ":%s:OUTP"            }, /* added in version 3.0 */
    { AGX2K3K_ATTR_SEGMENT_ANALYZE_ENABLE,                  ":ACQ:SEGM:ANAL"      }, /*  option SGM */

    /* New attributes added in version 2.0 */
    { AGX2K3K_ATTR_WGEN_ARBITRARY_INTERPOLATE,              ":WGEN:ARB:INT"       },
    { AGX2K3K_ATTR_SAVE_MAX_WAVE_ENABLED,                   ":SAVE:WAV:LENG:MAX"  },
    { AGX2K3K_ATTR_TRIGGER_TV_UDTV_HSYNC_ENABLED,           ":TRIG:TV:UDTV:HSYN"  },
    { AGX2K3K_ATTR_MEAS_STAT_RESD_ENABLED,                  ":MEAS:STAT:RSD"      },
    { AGX2K3K_ATTR_POWER_ENABLED,                           ":POW:ENAB"           },
    { AGX2K3K_ATTR_POWER_ANALYSIS_ENABLED,                  ":POW:ONOF:TEST"      },

    /* New attributes added in version 3.0 */
    { AGX2K3K_ATTR_DVM_ENABLED,                             ":DVM:ENAB"           },
    { AGX2K3K_ATTR_DVM_AUTO_RANGE_ENABLED,                  ":DVM:ARAN"           },
    { AGX2K3K_ATTR_WAVEGEN_MODULATION_ENABLED,              "%s:MOD:STAT"         },
    { AGX2K3K_ATTR_WAVEGEN_TRACKING_ENABLED,                "%s:TRAC"             },
    { AGX2K3K_ATTR_WAVEGEN_AMPLITUDE_TRACKING_ENABLED,      "%s:TRAC:AMPL"        },
    { AGX2K3K_ATTR_WAVEGEN_FREQUENCY_TRACKING_ENABLED,      "%s:TRAC:FREQ"        },

    /* New attributes added in version 3.1 */
    { AGX2K3K_ATTR_COUNTER_ENABLE,                          ":COUN:ENAB"          },
    { AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_ENABLED,           ":COUN:TOT:GATE:ENAB" },
    { AGX2K3K_ATTR_FFT_DISPLAY_ENABLED,                     ":FFT:DISP"           },
    { AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_CURSOR_ENABLED,      ":SAVE:RES:FORM:CURS" },
    { AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_MASK_ENABLED,        ":SAVE:RES:FORM:MASK" },
    { AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_MEASUREMENT_ENABLED, ":SAVE:RES:FORM:MEAS" },
    { AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_SEARCH_ENABLED,      ":SAVE:RES:FORM:SEAR" },
    { AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_SEGMENTED_ENABLED,   ":SAVE:RES:FORM:SEGM" },
    { AGX2K3K_ATTR_SBUS_CAN_TRIGGER_IDFILTER_ENABLED,       "%s:CAN:TRIG:IDF"     },
    { AGX2K3K_ATTR_SBUS_SENT_PPULSE_ENABLED,                "%s:SENT:PPUL"        },
    { AGX2K3K_ATTR_TRIGGER_ZONE_STATE_ENABLED,              ":TRIG:ZONE:STAT"     },
    { AGX2K3K_ATTR_MULTICHANNEL_TRIGGER_ZONE_STATE_ENABLED, ":TRIG:%s:STAT"       },

    /* New attributes added in version 3.2 */
    { AGX2K3K_ATTR_JITTER_ENABLE,                           ":JITT:STAT"          },
    { AGX2K3K_ATTR_RTEYE_ENABLE,                            ":RTEY:STAT"          },
    { AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_CGRADE_ENABLED,      ":SAVE:RES:FORM:CGR"  },
    { AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_HISTOGRAM_ENABLED,   ":SAVE:RES:FORM:HIST" },
    { AGX2K3K_ATTR_SYSTEM_PRECISION_ENABLED,                ":SYST:PREC"          },
    { AGX2K3K_ATTR_TRIGGER_JFREE_ENABLED,                   ":TRIG:JFR"           },

    { VI_NULL,                                              VI_NULL               }
};

/*- Table of commands for ViString attributes ------------------------------*/
static IviStringValueTable gs_ViStringCommands =
{
    { AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_SOURCE,              ":TRIG:EDGE:SOUR"             },
    { AGX2K3K_ATTR_INSTR_TRIGGER_TV_SOURCE,                ":TRIG:TV:SOUR"               },
    { AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_BURST_SOURCE,        ":TRIG:EBUR:SOUR"             },
    { AGX2K3K_ATTR_SETUPHOLD_CLKSRC,                       ":TRIG:SHOL:SOUR:CLOC"        },
    { AGX2K3K_ATTR_SETUPHOLD_DATASRC,                      ":TRIG:SHOL:SOUR:DATA"        },
    { AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_SOURCE,            ":TRIG:GLIT:SOUR"             },
    { AGX2K3K_ATTR_GLITCH_RANGE,                           ":TRIG:GLIT:RANG"             },
    { AGX2K3K_ATTR_INSTR_TRIGGER_PATTERN,                  ":TRIG:PATT"                  },
    { AGX2K3K_ATTR_INSTR_TRIGGER_RUNT_SOURCE,              ":TRIG:RUNT:SOUR"             },
    { AGX2K3K_ATTR_SETUPHOLD_DATASRC,                      ":TRIG:SHOL:SOUR:DATA"        },
    { AGX2K3K_ATTR_INSTR_TRIGGER_TRANSITION_SOURCE,        ":TRIG:TRAN:SOUR"             },
    { AGX2K3K_ATTR_SBUS_CAN_SOURCE,                        ":%s:CAN:SOUR"                },
    { AGX2K3K_ATTR_SBUS_CAN_DATA,                          ":%s:CAN:TRIG:PATT:DATA"      },
    { AGX2K3K_ATTR_SBUS_CAN_ID,                            ":%s:CAN:TRIG:PATT:ID"        },
    { AGX2K3K_ATTR_PATTERN_RANGE,                          ":TRIG:PATT:RANG"             },
    { AGX2K3K_ATTR_SBUS_I2S_SOURCE_CLOCK,                  ":%s:I2S:SOUR:CLOC"           },
    { AGX2K3K_ATTR_SBUS_I2S_SOURCE_DATA,                   ":%s:I2S:SOUR:DATA"           },
    { AGX2K3K_ATTR_SBUS_I2S_SOURCE_WS,                     ":%s:I2S:SOUR:WSEL"           },
    { AGX2K3K_ATTR_SBUS_I2S_TRIGGER_DATA,                  ":%s:I2S:TRIG:PATT:DATA"      },
    { AGX2K3K_ATTR_SBUS_IIC_SCL,                           ":%s:IIC:CLOC"                },
    { AGX2K3K_ATTR_SBUS_IIC_SDA,                           ":%s:IIC:DATA"                },
    { AGX2K3K_ATTR_SBUS_LIN_SOURCE,                        ":%s:LIN:SOUR"                },
    { AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA,                  ":%s:LIN:TRIG:PATT:DATA"      },
    { AGX2K3K_ATTR_USB_DPLUS,                              ":TRIG:USB:SOUR:DPL"          },
    { AGX2K3K_ATTR_USB_DMINUS,                             ":TRIG:USB:SOUR:DMIN"         },
    { AGX2K3K_ATTR_SBUS_SPI_MISO_DATA,                     ":%s:SPI:TRIG:PATT:MISO:DATA" },
    { AGX2K3K_ATTR_SBUS_SPI_MOSI_DATA,                     ":%s:SPI:TRIG:PATT:MOSI:DATA" },
    { AGX2K3K_ATTR_SBUS_SPI_CLKSOURCE,                     ":%s:SPI:SOUR:CLOC"           },
    { AGX2K3K_ATTR_SBUS_SPI_DSOURCE,                       ":%s:SPI:SOUR:DATA"           },
    { AGX2K3K_ATTR_SBUS_SPI_FSOURCE,                       ":%s:SPI:SOUR:FRAM"           },
    { AGX2K3K_ATTR_SBUS_UART_SOURCE_RX,                    ":%s:UART:SOUR:RX"            },
    { AGX2K3K_ATTR_SBUS_UART_SOURCE_TX,                    ":%s:UART:SOUR:TX"            },
    { AGX2K3K_ATTR_INSTR_INPUT_IMPEDANCE,                  ":%s:IMP"                     },
    { AGX2K3K_ATTR_INSTR_CHANNEL_LABEL,                    ":%s:LAB"                     },
    { AGX2K3K_ATTR_INSTR_MATH_SOURCE,                      ":FUNC:SOUR"                  },
    { AGX2K3K_ATTR_INSTR_MATH_SOURCE1,                     ":FUNC:SOUR1"                 },
    { AGX2K3K_ATTR_INSTR_MATH_SOURCE2,                     ":FUNC:SOUR2"                 },
    { AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE1,                ":FUNC:GOFT:SOUR1"            },
    { AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE2,                ":FUNC:GOFT:SOUR2"            },
    { AGX2K3K_ATTR_INSTR_MEAS_REF,                         ":MEAS:DEF"                   },
    { AGX2K3K_ATTR_INSTR_MEAS_SOURCE,                      ":MEAS:SOUR"                  },
    { AGX2K3K_ATTR_INSTR_MEAS_DELAY,                       ":MEAS:DEF"                   },
    { AGX2K3K_ATTR_INSTR_DATA_SOURCE,                      ":WAV:SOUR"                   },
    { AGX2K3K_ATTR_RECALL_WMEMORY_FILE_PATH,               ":REC:%s"                     },
    { AGX2K3K_ATTR_SAVE_WMEMORY_SOURCE,                    ":SAVE:%s:SOUR"               },
    { AGX2K3K_ATTR_SAVE_WMEMORY_FILE_PATH,                 ":SAVE:%s"                    },
    { AGX2K3K_ATTR_WMEMORY_COPY,                           ":%s:SAVE"                    },

    /* New attributes added in version 2.0 */
    { AGX2K3K_ATTR_SEARCH_SERIAL_A429_PATTERN_DATA,        ":SEAR:SER:A429:PATT:DATA"    },
    { AGX2K3K_ATTR_SEARCH_SERIAL_A429_PATTERN_SDI,         ":SEAR:SER:A429:PATT:SDI"     },
    { AGX2K3K_ATTR_SEARCH_SERIAL_A429_PATTERN_SSM,         ":SEAR:SER:A429:PATT:SSM"     },
    { AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_DATA,             ":SEAR:SER:FLEX:DATA"         },
    { AGX2K3K_ATTR_SEARCH_SERIAL_M1553_PATTERN_DATA,       ":SEAR:SER:M1553:PATT:DATA"   },
    { AGX2K3K_ATTR_A429_TRIGGER_PATTERN_DATA,              ":%s:A429:TRIG:PATT:DATA"     },
    { AGX2K3K_ATTR_A429_TRIGGER_PATTERN_SDI,               ":%s:A429:TRIG:PATT:SDI"      },
    { AGX2K3K_ATTR_A429_TRIGGER_PATTERN_SSM,               ":%s:A429:TRIG:PATT:SSM"      },
    { AGX2K3K_ATTR_M1553_TRIGGER_PATTERN_DATA,             ":%s:M1553:TRIG:PATT:DATA"    },

    /* New attributes added in version 3.0 */
    { AGX2K3K_ATTR_MEASURE_CONTINUOUSLY_DISPLAYED_RESULTS, ":MEAS:RES?"                  },
    { AGX2K3K_ATTR_POWER_HARMONICS_TABLE,                  ":POW:HARM:DATA"              },
    { AGX2K3K_ATTR_SBUS_A429_TRIGGER_RANGE,                "%s:A429:TRIG:RANG"           },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_ADDRESS_PORTION,       "%s:USB:TRIG:ADDR"            },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_CRC_PORTION,           "%s:USB:TRIG:CRC"             },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PORTION,          "%s:USB:TRIG:DATA"            },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_ENDPOINT_PORTION,      "%s:USB:TRIG:ENDP"            },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_ET_PORTION,            "%s:USB:TRIG:ET"              },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_FRAME_PORTION,         "%s:USB:TRIG:FRAM"            },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_HUB_ADDRESS_PORTION,   "%s:USB:TRIG:HADD"            },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_PID_CHECK_PORTION,     "%s:USB:TRIG:PCH"             },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_PORT_PORTION,          "%s:USB:TRIG:PORT"            },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_SC_PORTION,            "%s:USB:TRIG:SC"              },
    { AGX2K3K_ATTR_SBUS_USB_TRIGGER_SEU_PORTION,           "%s:USB:TRIG:SEU"             },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_ADDRESS_PORTION,      ":SEAR:SER:USB:ADDR"          },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_CRC_PORTION,          ":SEAR:SER:USB:CRC"           },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_PORTION,         ":SEAR:SER:USB:DATA"          },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_ENDPOINT_PORTION,     ":SEAR:SER:USB:ENDP"          },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_ET_PORTION,           ":SEAR:SER:USB:ET"            },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_FRAME_PORTION,        ":SEAR:SER:USB:FRAM"          },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_HUB_ADDRESS_PORTION,  ":SEAR:SER:USB:HADD"          },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_PORT_PORTION,         ":SEAR:SER:USB:PORT"          },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_SC_PORTION,           ":SEAR:SER:USB:SC"            },
    { AGX2K3K_ATTR_SEARCH_SERIAL_USB_SEU_PORTION,          ":SEAR:SER:USB:SEU"           },
    { AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_FLOAT_ARB_WAVEFORM,    "%s:ARB:DATA"                 },
    { AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_DAC_ARB_WAVEFORM,      "%s:ARB:DATA:DAC"             },

    /* New attributes added in version 3.1 */
    { AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_MESSAGE,      "%s:CAN:TRIG:SYMB:MESS"       },
    { AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_SIGNAL,       "%s:CAN:TRIG:SYMB:SIGN"       },
    { AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_FRAME,        "%s:LIN:TRIG:SYMB:FRAM"       },
    { AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_SIGNAL,       "%s:LIN:TRIG:SYMB:SIGN"       },
    { AGX2K3K_ATTR_SBUS_SENT_TRIGGER_FAST_DATA,            "%s:SENT:TRIG:FAST:DATA"      },
    { AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_MESSAGE,     ":SEAR:SER:CAN:SYMB:MESS"     },
    { AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_SIGNAL,      ":SEAR:SER:CAN:SYMB:SIGN"     },
    { AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_FRAME,       ":SEAR:SER:LIN:SYMB:FRAM"     },
    { AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_SIGNAL,      ":SEAR:SER:LIN:SYMB:SIGN"     },
    { AGX2K3K_ATTR_SEARCH_SERIAL_SENT_FAST_DATA,           ":SEAR:SER:SENT:FAST:DATA"    },

    /* New attributes added in version 3.2 */
    { AGX2K3K_ATTR_HISTOGRAM_WINDOW_SOURCE,                ":HIST:WIND:SOUR"             },
    { AGX2K3K_ATTR_RTEYE_SOURCE,                           ":RTEY:SOUR"                  },

    { VI_NULL,                                             VI_NULL                       }
};

/* range tables added in version 3.2 */
static IviRangeTableEntry attrCANFDStandardRangeTableEntries[] =
{
    { AGX2K3K_VAL_ISO,  0, 0, "ISO",  0 },
    { AGX2K3K_VAL_NISO, 0, 0, "NISO", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrCANFDStandardRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrCANFDStandardRangeTableEntries,
};

static IviRangeTableEntry attrChannelBandwidthRangeTableEntries[] =
{
    { 0, 6e9, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrChannelBandwidthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrChannelBandwidthRangeTableEntries,
};

static IviRangeTableEntry attrHistogramAxisRangeTableEntries[] =
{
    { AGX2K3K_VAL_VERTICAL,   0, 0, "VERT", 0 },
    { AGX2K3K_VAL_HORIZONTAL, 0, 0, "HOR",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrHistogramAxisRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrHistogramAxisRangeTableEntries,
};

static IviRangeTableEntry attrHistogramBLimitRangeTableEntries[] =
{
    { -1.15e6, 1.14999e6, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrHistogramBLimitRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrHistogramBLimitRangeTableEntries,
};

static IviRangeTableEntry attrHistogramLLimitRangeTableEntries[] =
{
    { -2e-3, 1.009984, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrHistogramLLimitRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrHistogramLLimitRangeTableEntries,
};

static IviRangeTableEntry attrHistogramRangeTableEntries[] =
{
    { AGX2K3K_VAL_HISTOGRAM_OFF,         0, 0, "OFF",  0 },
    { AGX2K3K_VAL_HISTOGRAM_WAVEFORM,    0, 0, "WAV",  0 },
    { AGX2K3K_VAL_HISTOGRAM_MEASUREMENT, 0, 0, "MEAS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrHistogramRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrHistogramRangeTableEntries,
};

static IviRangeTableEntry attrHistogramRLimitRangeTableEntries[] =
{
    { -1.9984e-3, 1.001, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrHistogramRLimitRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrHistogramRLimitRangeTableEntries,
};

static IviRangeTableEntry attrHistogramTLimitRangeTableEntries[] =
{
    { -1.14999e6, 1.15e6, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrHistogramTLimitRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrHistogramTLimitRangeTableEntries,
};

static IviRangeTableEntry attrMeasurementRangeTableEntries[] =
{
    { AGX2K3K_VAL_MEAS1,  0, 0, "MEAS1",  0 },
    { AGX2K3K_VAL_MEAS2,  0, 0, "MEAS2",  0 },
    { AGX2K3K_VAL_MEAS3,  0, 0, "MEAS3",  0 },
    { AGX2K3K_VAL_MEAS4,  0, 0, "MEAS4",  0 },
    { AGX2K3K_VAL_MEAS5,  0, 0, "MEAS5",  0 },
    { AGX2K3K_VAL_MEAS6,  0, 0, "MEAS6",  0 },
    { AGX2K3K_VAL_MEAS7,  0, 0, "MEAS7",  0 },
    { AGX2K3K_VAL_MEAS8,  0, 0, "MEAS8",  0 },
    { AGX2K3K_VAL_MEAS9,  0, 0, "MEAS9",  0 },
    { AGX2K3K_VAL_MEAS10, 0, 0, "MEAS10", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrMeasurementRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrMeasurementRangeTableEntries,
};

static IviRangeTableEntry attrPrecisionLengthRangeTableEntries[] =
{
    { 100000, 1000000, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrPrecisionLengthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrPrecisionLengthRangeTableEntries,
};

static IviRangeTableEntry attrSubsourceRangeTableEntries[] =
{
    { AGX2K3K_VAL_SUB0, 0, 0, "SUB0", 0 },
    { AGX2K3K_VAL_SUB1, 0, 0, "SUB1", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSubsourceRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSubsourceRangeTableEntries,
};

static IviRangeTableEntry funcCTCWPolarityRangeTableEntries[] =
{
    { AGX2K3K_VAL_CTCW_POSITIVE, 0, 0, ":MEAS:CTCP", 0 },
    { AGX2K3K_VAL_CTCW_NEGATIVE, 0, 0, ":MEAS:CTCN", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable funcCTCWPolarityRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    funcCTCWPolarityRangeTableEntries,
};

static IviRangeTableEntry funcDirectionRangeTableEntries[] =
{
    { AGX2K3K_VAL_RISING,  0, 0, "RIS",  0 },
    { AGX2K3K_VAL_FALLING, 0, 0, "FALL", 0 },
    { AGX2K3K_VAL_BOTH,    0, 0, "BOTH", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable funcDirectionRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    funcDirectionRangeTableEntries,
};


static IviRangeTableEntry funcHistogramMeasureRangeTableEntries[] =
{
    { AGX2K3K_VAL_BWIDTH, 0, 0, "BWID", 0 },
    { AGX2K3K_VAL_HITS,   0, 0, "HITS", 0 },
    { AGX2K3K_VAL_M1S,    0, 0, "M1S",  0 },
    { AGX2K3K_VAL_M2S,    0, 0, "M2S",  0 },
    { AGX2K3K_VAL_M3S,    0, 0, "M3S",  0 },
    { AGX2K3K_VAL_MAX,    0, 0, "MAX",  0 },
    { AGX2K3K_VAL_MEAN,   0, 0, "MEAN", 0 },
    { AGX2K3K_VAL_MED,    0, 0, "MED",  0 },
    { AGX2K3K_VAL_MIN,    0, 0, "MIN",  0 },
    { AGX2K3K_VAL_MODE,   0, 0, "MODE", 0 },
    { AGX2K3K_VAL_PEAK,   0, 0, "PEAK", 0 },
    { AGX2K3K_VAL_PPEAK,  0, 0, "PPE",  0 },
    { AGX2K3K_VAL_SDEV,   0, 0, "SDEV", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable funcHistogramMeasureRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    funcHistogramMeasureRangeTableEntries,
};

static IviRangeTableEntry funcNPeriodDirectionRangeTableEntries[] =
{
    { AGX2K3K_VAL_RISING,  0, 0, "RIS",  0 },
    { AGX2K3K_VAL_FALLING, 0, 0, "FALL", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable funcNPeriodDirectionRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    funcNPeriodDirectionRangeTableEntries,
};

static IviRangeTableEntry funcRTEMeasurementRangeTableEntries[] =
{
    { AGX2K3K_VAL_EYE_HEIGHT, 0, 0, ":MEAS:RTEY:EHE",  0 },
    { AGX2K3K_VAL_EYE_WIDTH,  0, 0, ":MEAS:RTEY:EWID", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable funcRTEMeasurementRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    funcRTEMeasurementRangeTableEntries,
};

static IviRangeTableEntry funcTIEUnitRangeTableEntries[] =
{
    { AGX2K3K_VAL_SECOND,       0, 0, "SEC",  0 },
    { AGX2K3K_VAL_UNITINTERVAL, 0, 0, "UNIT", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable funcTIEUnitRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    funcTIEUnitRangeTableEntries,
};

/*****************************************************************************
 *--- Typedefs for string/string tables used in trigger source callbacks ----*
 *****************************************************************************/

typedef struct
{
    ViString col1;
    ViString col2;
} agx2k3kStringTableEntries;

typedef agx2k3kStringTableEntries*  agx2k3kStringTable;

/*****************************************************************************
 *-------------- Utility Function Declarations (Non-Exported) ---------------*
 *****************************************************************************/
static void RemoveSurroundingWhiteSpace (ViChar string[]);
static ViStatus agx2k3k_GetDriverSetupOption (ViSession vi,
                                              ViInt32*    pModelType,
                                              ViInt32*    pOptions);
static ViStatus agx2k3k_GetRecordModeSetupOption (ViSession vi,
                                                  ViInt32*    recordMode);
static ViStatus agx2k3k_QueryID (ViSession vi,
                                 ViSession io,
                                 ViInt32 bufferSize,
                                 ViChar buffer[]);
static ViStatus agx2k3k_GetModelFromBuffer (ViSession vi,
                                            ViConstString buffer,
                                            ViInt32*        pModelType);
static ViStatus agx2k3k_InitAttributes (ViSession vi,
                                        ViInt32 modelType,
                                        ViInt32 options);
static ViStatus agx2k3k_DefaultInstrSetup (ViSession openInstrSession);
static ViStatus agx2k3k_CheckStatus (ViSession vi);
static ViStatus agx2k3k_WaitForOPC (ViSession vi, ViInt32 maxTime);
static ViStatus agx2k3k_FetchWaveformSafe (ViSession vi,
                                           ViConstString channelName,
                                           ViInt32 waveformSize,
                                           ViReal64 waveform[],
                                           ViInt32 *actualPoints,
                                           ViReal64 *initialX,
                                           ViReal64 *xIncrement);
static ViStatus agx2k3k_FetchMinMaxWaveformSafe (ViSession vi,
                                                 ViConstString channelName,
                                                 ViInt32 waveformSize,
                                                 ViReal64 minWaveform[],
                                                 ViReal64 maxWaveform[],
                                                 ViInt32 *actualPoints,
                                                 ViReal64 *initialX,
                                                 ViReal64 *xIncrement);
static ViStatus agx2k3k_FetchRawWaveform (ViSession vi,
                                          ViConstString dataSource,
                                          ViInt32 segmentNumber,
                                          ViInt32 waveformSize,
                                          ViReal64 waveform[],
                                          ViInt32*        actualPoints,
                                          ViReal64*       initialX,
                                          ViReal64*       xIncrement);
static ViStatus agx2k3k_FetchRawMinMaxWaveformSafe (ViSession vi,
                                                    ViConstString dataSource,
                                                    ViInt32 segmentNumber,
                                                    ViInt32 waveformSize,
                                                    ViReal64 minWaveform[],
                                                    ViReal64 maxWaveform[],
                                                    ViInt32*        actualPoints,
                                                    ViReal64*       initialX,
                                                    ViReal64*       xIncrement);
static ViStatus agx2k3k_IsFFT (ViSession vi,
                               ViConstString dataSource,
                               ViBoolean*      pIsFFT);
static ViStatus agx2k3k_FetchWaveformMeasurementSafe (ViSession vi,
                                                      ViConstString channelName,
                                                      ViInt32 measFunction,
                                                      ViReal64 *measurement);
static ViStatus agx2k3k_GetStr1PtrFromStr2 (ViSession vi, agx2k3kStringTable strTable,
                                            ViConstString *str1, ViConstString str2);
static ViStatus agx2k3k_GetStr2BufFromStr1 (ViSession vi, agx2k3kStringTable strTable,
                                            ViConstString str1, ViConstString* str2);
static ViStatus agx2k3k_IsSourceDisplayed (ViSession vi,
                                           ViSession io,
                                           ViConstString cstrSource,
                                           ViBoolean *   pbDisplayed);
static ViStatus agx2k3k_VerifyWaveformSource (ViSession vi);
static ViStatus agx2k3k_RectifyWaveformSource (ViSession vi,
                                               ViSession io);
static ViStatus agx2k3k_ResetWaveformSource (ViSession vi,
                                             ViSession io,
                                             ViConstString * pstrSources,
                                             size_t iSourceSize,
                                             ViBoolean *     pbHasFound);
static ViStatus agx2k3k_GetMathSourceProperties (ViSession vi,
                                                 ViAttr attributeId,
                                                 ViAttr *            pattrHidden,
                                                 agx2k3kStringTable * pTable);
static ViStatus agx2k3k_CheckPattern (ViInt32 expectedLength,
                                      ViConstString value);
/*****************************************************************************
 *----------------- Callback Declarations (Non-Exported) --------------------*
 *****************************************************************************/

/*- Global Session Callbacks --------------------------------------------*/
static ViStatus _VI_FUNC agx2k3k_CheckStatusCallback (ViSession vi, ViSession io);
static ViStatus _VI_FUNC agx2k3k_WaitForOPCCallback (ViSession vi, ViSession io);

/*- Shared callbacks ----------------------------------------------------*/
static ViStatus _VI_FUNC agx2k3kViInt32_ReadCallback (ViSession vi,
                                                      ViSession io,
                                                      ViConstString channelName,
                                                      ViAttr attributeId,
                                                      ViInt32*        value);
static ViStatus _VI_FUNC agx2k3kViInt32_WriteCallback (ViSession vi,
                                                       ViSession io,
                                                       ViConstString channelName,
                                                       ViAttr attributeId,
                                                       ViInt32 value);

static ViStatus _VI_FUNC agx2k3kViReal64_ReadCallback (ViSession vi,
                                                       ViSession io,
                                                       ViConstString channelName,
                                                       ViAttr attributeId,
                                                       ViReal64*       value);
static ViStatus _VI_FUNC agx2k3kViReal64_WriteCallback (ViSession vi,
                                                        ViSession io,
                                                        ViConstString channelName,
                                                        ViAttr attributeId,
                                                        ViReal64 value);

static ViStatus _VI_FUNC agx2k3kEnum_WriteCallback (ViSession vi,
                                                    ViSession io,
                                                    ViConstString channelName,
                                                    ViAttr attributeId,
                                                    ViInt32 value);
static ViStatus _VI_FUNC agx2k3kEnum_ReadCallback (ViSession vi,
                                                   ViSession io,
                                                   ViConstString channelName,
                                                   ViAttr attributeId,
                                                   ViInt32*        value);

static ViStatus _VI_FUNC agx2k3kViBoolean_WriteCallback (ViSession vi,
                                                         ViSession io,
                                                         ViConstString channelName,
                                                         ViAttr attributeId,
                                                         ViBoolean value);
static ViStatus _VI_FUNC agx2k3kViBoolean_ReadCallback (ViSession vi,
                                                        ViSession io,
                                                        ViConstString channelName,
                                                        ViAttr attributeId,
                                                        ViBoolean*      value);
static ViStatus _VI_FUNC agx2k3kViString_WriteCallback (ViSession vi,
                                                        ViSession io,
                                                        ViConstString channelName,
                                                        ViAttr attributeId,
                                                        ViConstString value);
static ViStatus _VI_FUNC agx2k3kViString_ReadCallback (ViSession vi,
                                                       ViSession io,
                                                       ViConstString channelName,
                                                       ViAttr attributeId,
                                                       const ViConstString cacheValue);

static ViStatus _VI_FUNC agx2k3kViQuotedString_WriteCallback (ViSession vi,
                                                              ViSession io,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViConstString value);

static ViStatus _VI_FUNC agx2k3kViQuotedString_ReadCallback (ViSession vi,
                                                             ViSession io,
                                                             ViConstString channelName,
                                                             ViAttr attributeId,
                                                             const ViConstString cacheValue);

/*- Attribute callbacks -------------------------------------------------*/

static ViStatus _VI_FUNC agx2k3kAttrLINTriggerData_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrI2STriggerData_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViConstString value);

static ViStatus _VI_FUNC agx2k3kAttrLINTriggerData_ReadCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 const ViConstString cacheValue);
static ViStatus _VI_FUNC agx2k3kAttrDriverRevision_ReadCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 const ViConstString cacheValue);
static ViStatus _VI_FUNC agx2k3kAttrInstrumentManufacturer_ReadCallback (ViSession vi,
                                                                         ViSession io,
                                                                         ViConstString channelName,
                                                                         ViAttr attributeId,
                                                                         const ViConstString cacheValue);
static ViStatus _VI_FUNC agx2k3kAttrInstrumentModel_ReadCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  const ViConstString cacheValue);

static ViStatus _VI_FUNC agx2k3kAttrFirmwareRevision_ReadCallback (ViSession vi,
                                                                   ViSession io,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   const ViConstString cacheValue);
static ViStatus _VI_FUNC agx2k3kAttrIdQueryResponse_ReadCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  const ViConstString cacheValue);
static ViStatus _VI_FUNC agx2k3kAttrProbeAttenuation_ReadCallback (ViSession vi,
                                                                   ViSession io,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViReal64 *value);
static ViStatus _VI_FUNC agx2k3kAttrProbeAttenuation_WriteCallback (ViSession vi,
                                                                    ViSession io,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrProbeSenseValue_ReadCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViReal64* value);
static ViStatus _VI_FUNC agx2k3kAttrVerticalRange_CheckCallback (ViSession vi,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViReal64 value);

static ViStatus _VI_FUNC agx2k3kAttrWavegenPulseWidth_CheckCallback (ViSession vi,
                                                                     ViConstString channelName,
                                                                     ViAttr attributeId,
                                                                     ViReal64 value);

static ViStatus _VI_FUNC agx2k3kAttrVerticalOffset_CheckCallback (ViSession vi,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrMaxInputFrequency_CheckCallback (ViSession vi,
                                                                     ViConstString channelName,
                                                                     ViAttr attributeId,
                                                                     ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrMaxInputFrequency_ReadCallback (ViSession vi,
                                                                    ViSession io,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViReal64 *value);
static ViStatus _VI_FUNC agx2k3kAttrMaxInputFrequency_WriteCallback (ViSession vi,
                                                                     ViSession io,
                                                                     ViConstString channelName,
                                                                     ViAttr attributeId,
                                                                     ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrInputImpedance_CheckCallback (ViSession vi,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrInputImpedance_ReadCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViReal64 *value);
static ViStatus _VI_FUNC agx2k3kAttrInputImpedance_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrHorzTimePerRecord_CheckCallback (ViSession vi,
                                                                     ViConstString channelName,
                                                                     ViAttr attributeId,
                                                                     ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrMinNumPts_CheckCallback (ViSession vi,
                                                             ViConstString channelName,
                                                             ViAttr attributeId,
                                                             ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrMinNumPts_WriteCallback (ViSession vi,
                                                             ViSession io,
                                                             ViConstString channelName,
                                                             ViAttr attributeId,
                                                             ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrHorzRecordMode_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrHorzRecordLength_WriteCallback (ViSession vi,
                                                                    ViSession io,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrAcquisitionStartTime_CheckCallback (ViSession vi,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrAcquisitionStartTime_ReadCallback (ViSession vi,
                                                                       ViSession io,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViReal64 *value);
static ViStatus _VI_FUNC agx2k3kAttrAcquisitionStartTime_WriteCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrTriggerSource_ReadCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                const ViConstString cacheValue);
static ViStatus _VI_FUNC agx2k3kAttrTriggerSource_WriteCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrTriggerSource_CheckCallback (ViSession vi,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrWmemoryCopy_CheckCallback (ViSession vi,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrSaveWmemory_CheckCallback (ViSession vi,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrTriggerLevel_CheckCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrTriggerLevel_ReadCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViReal64 *value);
static ViStatus _VI_FUNC agx2k3kAttrTriggerLevel_WriteCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrTriggerHoldoff_CoerceCallback (ViSession vi,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViReal64 value,
                                                                   ViReal64 *coercedValue);
static ViStatus _VI_FUNC agx2k3kAttrLINBandrate_CoerceCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViInt32 value,
                                                                ViInt32 *coercedValue);
static ViStatus _VI_FUNC agx2k3kAttrTriggerCoupling_CheckCallback (ViSession vi,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrTvTriggerLineNumber_CheckCallback (ViSession vi,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrDPlus_CheckCallback (ViSession vi,
                                                         ViConstString channelName,
                                                         ViAttr attributeId,
                                                         ViConstString value);

static ViStatus _VI_FUNC agx2k3kAttrUSBDMinus_CheckCallback (ViSession vi,
                                                             ViConstString channelName,
                                                             ViAttr attributeId,
                                                             ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrAcquisitionMode_CheckCallback (ViSession vi,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrGlitchRange_CheckCallback (ViSession vi,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViConstString value);

static ViStatus _VI_FUNC agx2k3kAttrPattern_CheckCallback (ViSession vi,
                                                           ViConstString channelName,
                                                           ViAttr attributeId,
                                                           ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrSerialBusSource_CheckCallback (ViSession vi,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrI2STriggerRange_CheckCallback (ViSession vi,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrI2STriggerRange_ReadCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViInt32* value);
static ViStatus _VI_FUNC agx2k3kAttrI2STriggerRange_WriteCallback (ViSession vi,
                                                                   ViSession io,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrSetupHoldDataSource_CheckCallback (ViSession vi,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrSPIFrameSource_CheckCallback (ViSession vi,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrSPIDataSource_CheckCallback (ViSession vi,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrI2SDataSource_CheckCallback (ViSession vi,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrI2SWSSource_CheckCallback (ViSession vi,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrUARTCountReset_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViBoolean value);
static ViStatus _VI_FUNC agx2k3kAttrUARTFraming_ReadCallback (ViSession vi,
                                                              ViSession io,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViInt32* value);
static ViStatus _VI_FUNC agx2k3kAttrUARTFraming_WriteCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrUARTSourceTx_CheckCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrPattern_ReadCallback (ViSession vi,
                                                          ViSession io,
                                                          ViConstString channelName,
                                                          ViAttr attributeId,
                                                          const ViConstString cacheValue);
static ViStatus _VI_FUNC agx2k3kAttrPattern_WriteCallback (ViSession vi,
                                                           ViSession io,
                                                           ViConstString channelName,
                                                           ViAttr attributeId,
                                                           ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrPatternRange_CheckCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrIICSda_CheckCallback (ViSession vi,
                                                          ViConstString channelName,
                                                          ViAttr attributeId,
                                                          ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrIICQualifier_CheckCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrIICAddress_CheckCallback (ViSession vi,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrInitiateContinuous_WriteCallback (ViSession vi,
                                                                      ViSession io,
                                                                      ViConstString channelName,
                                                                      ViAttr attributeId,
                                                                      ViBoolean value);
static ViStatus _VI_FUNC agx2k3kAttrChannelLabel_CheckCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrChannelLabel_ReadCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               const ViConstString cacheValue);
static ViStatus _VI_FUNC agx2k3kAttrChannelLabel_WriteCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrTimebasePosition_CheckCallback (ViSession vi,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrWindowTimebasePosition_CheckCallback (ViSession vi,
                                                                          ViConstString channelName,
                                                                          ViAttr attributeId,
                                                                          ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrWindowTimebaseRange_CheckCallback (ViSession vi,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrWindowTimebaseScale_CheckCallback (ViSession vi,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrMeasLowRef_CheckCallback (ViSession vi,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrMeasMidRef_CheckCallback (ViSession vi,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrSampleMode_ReadCallback (ViSession vi,
                                                             ViSession io,
                                                             ViConstString channelName,
                                                             ViAttr attributeId,
                                                             ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kAttrMeasureSource_CheckCallback (ViSession vi,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrMeasureSource_ReadCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                const ViConstString cacheValue);
static ViStatus _VI_FUNC agx2k3kAttrMeasureSource_WriteCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrMeasureDelay_CheckCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrMeasureDelay_ReadCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               const ViConstString cacheValue);
static ViStatus _VI_FUNC agx2k3kAttrMeasureDelay_WriteCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrMeasureRef_CheckCallback (ViSession vi,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViConstString value);
static ViStatus _VI_FUNC agx2k3kAttrMeasureRef_WriteCallback (ViSession vi,
                                                              ViSession io,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViConstString value);

static ViStatus _VI_FUNC agx2k3kAttrMathOperation_ReadCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kAttrMathOperation_WriteCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrMathScale_CheckCallback (ViSession vi,
                                                             ViConstString channelName,
                                                             ViAttr attributeId,
                                                             ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrMathOffset_CheckCallback (ViSession vi,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViReal64 value);

static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsDisplayEnabled_ReadCallback (ViSession vi,
                                                                                ViSession io,
                                                                                ViConstString channelName,
                                                                                ViAttr attributeId,
                                                                                ViBoolean *value);
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsDisplayEnabled_WriteCallback (ViSession vi,
                                                                                 ViSession io,
                                                                                 ViConstString channelName,
                                                                                 ViAttr attributeId,
                                                                                 ViBoolean value);
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsLength_ReadCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsLength_WriteCallback (ViSession vi,
                                                                         ViSession io,
                                                                         ViConstString channelName,
                                                                         ViAttr attributeId,
                                                                         ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsMultiplier_ReadCallback (ViSession vi,
                                                                            ViSession io,
                                                                            ViConstString channelName,
                                                                            ViAttr attributeId,
                                                                            ViReal64 *value);
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsMultiplier_WriteCallback (ViSession vi,
                                                                             ViSession io,
                                                                             ViConstString channelName,
                                                                             ViAttr attributeId,
                                                                             ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsOffset_ReadCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViReal64 *value);
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsOffset_WriteCallback (ViSession vi,
                                                                         ViSession io,
                                                                         ViConstString channelName,
                                                                         ViAttr attributeId,
                                                                         ViReal64 value);
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsOrder_ReadCallback (ViSession vi,
                                                                       ViSession io,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsOrder_WriteCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsStart_ReadCallback (ViSession vi,
                                                                       ViSession io,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsStart_WriteCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViInt32 value);

static ViStatus _VI_FUNC agx2k3kAttrChannels_RangeTableCallback (ViSession vi,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 IviRangeTablePtr *rangeTablePtr);
static ViStatus _VI_FUNC agx2k3kAttrSBusSENTSource_RangeTableCallback (ViSession vi,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       IviRangeTablePtr *rangeTablePtr);
static ViStatus _VI_FUNC agx2k3kAttrCounterSource_RangeTableCallback (ViSession vi,
                                                                      ViConstString channelName,
                                                                      ViAttr attributeId,
                                                                      IviRangeTablePtr *rangeTablePtr);

static ViStatus _VI_FUNC agx2k3kAttrSBusSENTTriggerSLOWData_RangeTableCallback (ViSession vi,
                                                                                ViConstString channelName,
                                                                                ViAttr attributeId,
                                                                                IviRangeTablePtr *rangeTablePtr);

static ViStatus _VI_FUNC agx2k3kAttrSBusSENTTriggerSLOWID_RangeTableCallback (ViSession vi,
                                                                              ViConstString channelName,
                                                                              ViAttr attributeId,
                                                                              IviRangeTablePtr *rangeTablePtr);

static ViStatus _VI_FUNC agx2k3kAttrTimebaseScale_RangeTableCallback (ViSession vi,
                                                                      ViConstString channelName,
                                                                      ViAttr attributeId,
                                                                      IviRangeTablePtr *rangeTablePtr);

static ViStatus _VI_FUNC agx2k3kAttrTriggerHFReject_CheckCallback (ViSession vi,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViBoolean value);

static ViStatus _VI_FUNC agx2k3kAttrTriggerType_RangeTableCallback (ViSession vi,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    IviRangeTablePtr *rangeTablePtr);

static ViStatus _VI_FUNC agx2k3kAttrMathChannel_CheckCallback (ViSession vi,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViConstString value);

static ViStatus _VI_FUNC agx2k3kAttrMathChannel_ReadCallback (ViSession vi,
                                                              ViSession io,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              const ViConstString cacheValue);

static ViStatus _VI_FUNC agx2k3kAttrMathChannel_WriteCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViConstString value);

static ViStatus _VI_FUNC agx2k3kAttrSegmentAnalyzeEnable_WriteCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViBoolean value);

static ViStatus _VI_FUNC agx2k3kAttrUARTTriggerBurst_CheckCallback (ViSession vi,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViInt32 value);

static ViStatus _VI_FUNC agx2k3kAttrUARTTriggerBurst_ReadCallback (ViSession vi,
                                                                   ViSession io,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViInt32 *value);

static ViStatus _VI_FUNC agx2k3kAttrUARTTriggerBurst_WriteCallback (ViSession vi,
                                                                    ViSession io,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViInt32 value);

static ViStatus _VI_FUNC agx2k3kAttrWavegenReset_WriteCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViBoolean value);

static ViStatus _VI_FUNC agx2k3kAttrCounterMode_RangeTableCallback (ViSession vi,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    IviRangeTablePtr *rangeTablePtr);

static ViStatus _VI_FUNC agx2k3kAttrRuntHighThreshold_WriteCallback (ViSession vi,
                                                                     ViSession io,
                                                                     ViConstString channelName,
                                                                     ViAttr attributeId,
                                                                     ViReal64 value);

static ViStatus _VI_FUNC agx2k3kAttrRuntHighThreshold_ReadCallback (ViSession vi,
                                                                    ViSession io,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViReal64 *value);

static ViStatus _VI_FUNC agx2k3kAttrRuntLowThreshold_WriteCallback (ViSession vi,
                                                                    ViSession io,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViReal64 value);

static ViStatus _VI_FUNC agx2k3kAttrRuntLowThreshold_ReadCallback (ViSession vi,
                                                                   ViSession io,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViReal64 *value);

/*****************************************************************************
 *------------ User-Callable Functions (Exportable Functions) ---------------*
 *****************************************************************************/

/*****************************************************************************
 * Function: agx2k3k_init
 * Purpose:  VXIplug&play required function.  Calls the
 *           agx2k3k_InitWithOptions function.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_init (ViRsrc resourceName, ViBoolean IDQuery,
                                ViBoolean resetDevice, ViSession *newVi)
{
    ViStatus error = VI_SUCCESS;

    if (newVi == VI_NULL)
    {
        Ivi_SetErrorInfo (VI_NULL, VI_FALSE, IVI_ERROR_INVALID_PARAMETER,
                          VI_ERROR_PARAMETER4, "Null address for Instrument Handle");
        checkErr (IVI_ERROR_INVALID_PARAMETER);
    }

    checkErr (agx2k3k_InitWithOptions (resourceName, IDQuery, resetDevice,
                                       "", newVi));

Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_InitWithOptions
 * Purpose:  This function creates a new IVI session and calls the
 *           IviInit function.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_InitWithOptions (ViRsrc resourceName,
                                           ViBoolean IDQuery,
                                           ViBoolean resetDevice,
                                           ViConstString optionString,
                                           ViSession      *newVi)
{
    ViStatus  error = VI_SUCCESS;
    ViSession vi    = VI_NULL;
    ViChar    newResourceName[IVI_MAX_MESSAGE_BUF_SIZE];
    ViChar    newOptionString[IVI_MAX_MESSAGE_BUF_SIZE];
    ViBoolean isLogicalName;

    if (newVi == VI_NULL)
    {
        Ivi_SetErrorInfo (VI_NULL, VI_FALSE, IVI_ERROR_INVALID_PARAMETER,
                          VI_ERROR_PARAMETER5, "Null address for Instrument Handle");
        checkErr (IVI_ERROR_INVALID_PARAMETER);
    }

    *newVi = VI_NULL;

    checkErr (Ivi_GetInfoFromResourceName (resourceName, (ViString) optionString,
                                           newResourceName,
                                           newOptionString,
                                           &isLogicalName));

    /* create a new interchangeable driver */
    checkErr (Ivi_SpecificDriverNew ("agx2k3k", newOptionString, &vi));
    if (!isLogicalName)
    {
        ViInt32 oldFlag = 0;

        checkErr (Ivi_GetAttributeFlags (vi, IVI_ATTR_IO_RESOURCE_DESCRIPTOR, &oldFlag));
        checkErr (Ivi_SetAttributeFlags (vi, IVI_ATTR_IO_RESOURCE_DESCRIPTOR, oldFlag & 0xfffb | 0x0010));
        checkErr (Ivi_SetAttributeViString (vi, "", IVI_ATTR_IO_RESOURCE_DESCRIPTOR, 0, newResourceName));
    }
    /* init the driver */
    checkErr (agx2k3k_IviInit (newResourceName, IDQuery, resetDevice, vi));
    if (isLogicalName)
        checkErr (Ivi_ApplyDefaultSetup (vi));
    *newVi = vi;

Error:
    if (error < VI_SUCCESS)
        Ivi_Dispose (vi);

    return error;
}

/*****************************************************************************
 * Function: agx2k3k_IviInit
 * Purpose:  This function is called by agx2k3k_InitWithOptions
 *           or by an IVI class driver.  This function initializes the I/O
 *           interface, optionally resets the device, optionally performs an
 *           ID query, and sends a default setup to the instrument.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_IviInit (ViRsrc resourceName,
                                   ViBoolean IDQuery,
                                   ViBoolean reset,
                                   ViSession vi)
{
    ViStatus  error      = VI_SUCCESS;
    ViInt32   model_type = UNKNOWN;
    ViSession io         = VI_NULL;
    ViInt32   options    = 0;
    ViChar    id_query_buffer[BUFFER_SIZE];

    id_query_buffer[0] = '\0';
    checkErr (agx2k3k_GetDriverSetupOption (vi, &model_type, &options));

    /* Add attributes */
    if (!Ivi_Simulating (vi))
    {
        ViSession rmSession = VI_NULL;

        /* Open instrument session */
        checkErr (Ivi_GetAttributeViSession (vi, VI_NULL, IVI_ATTR_VISA_RM_SESSION, 0,
                                             &rmSession));
        viCheckErr (viOpen (rmSession, resourceName, VI_NULL, VI_NULL, &io));
        /* io session owned by driver now */
        checkErr (Ivi_SetAttributeViSession (vi, VI_NULL, IVI_ATTR_IO_SESSION, 0, io));

        /* Configure VISA Formatted I/O */
        viCheckErr (viSetAttribute (io, VI_ATTR_TMO_VALUE, 5000));
        viCheckErr (viSetBuf (io, VI_READ_BUF | VI_WRITE_BUF, 4000));
        viCheckErr (viSetAttribute (io, VI_ATTR_WR_BUF_OPER_MODE, VI_FLUSH_ON_ACCESS));
        viCheckErr (viSetAttribute (io, VI_ATTR_RD_BUF_OPER_MODE, VI_FLUSH_ON_ACCESS));

        if (IDQuery && model_type == UNKNOWN)
        {
            checkErr (agx2k3k_QueryID (vi, io, BUFFER_SIZE, id_query_buffer));
            checkErr (agx2k3k_GetModelFromBuffer (vi, id_query_buffer, &model_type));
        }
    }


    if (model_type == UNKNOWN)
    {
        model_type = DSOX2002A;
    }

    {   /* inner block */
        ViChar channels[BUFFER_SIZE] = "";

        strcat (channels, (HAS_2CHANNELS (model_type)) ? CHANNEL_LIST_2 : CHANNEL_LIST_4);
        /* Determine the DSO/MSO data sources */
        if (IS_MSO_INSTR (model_type))
        {
            strcat (channels, ",");
            strcat (channels, LOGIC_CHANNELS);
            strcat (channels, ",");
            strcat (channels, MATH_MSO_CHANNELS);
        }
        else if (IS_DSO_INSTR (model_type))
        {
            strcat (channels, ",");
            strcat (channels, MATH_DSO_CHANNELS);
        }
        strcat (channels, ",");
        strcat (channels, WMEMORY_CHANNELS);
        strcat (channels, ",");
        strcat (channels, EXTERNAL_CHANNELS);
        strcat (channels, ",");
        strcat (channels, ZONE_CHANNELS);

        /* if (IS_4000_SERIES(model_type))   / * 3000T X-Series may have some attributes of the two below as well. * / */
        {
            strcat (channels, ",");
            strcat (channels, WGEN_CHANNELS);
            strcat (channels, ",");
            strcat (channels, FUNCTION_CHANNELS);
        }

        strcat (channels, ",");
        strcat (channels, SIGNAL_CHANNELS);

        checkErr (Ivi_BuildChannelTable (vi,
                                         channels,
                                         VI_FALSE,
                                         VI_NULL));
    } /* inner block */


    /* Add attributes */
    checkErr (agx2k3k_InitAttributes (vi, model_type, options));

    /* Record the model type */
    checkErr (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       IVI_VAL_SET_CACHE_ONLY,
                                       model_type));

    /*- Reset instrument ----------------------------------------------------*/
    if (reset)
    {
        error = agx2k3k_reset (vi);
    }
    else  /*- Send Default Instrument Setup ---------------------------------*/
    {
        error = agx2k3k_DefaultInstrSetup (vi);
    }
    checkErr (error);

    /*- Identification Query ------------------------------------------------*/
    if (IDQuery)
    {
        ViInt32 actual_model = model_type;

        if (!id_query_buffer[0])
        {
            checkErr (Ivi_GetAttributeViString (vi,
                                                VI_NULL,
                                                AGX2K3K_ATTR_ID_QUERY_RESPONSE,
                                                0, BUFFER_SIZE,
                                                id_query_buffer));
            checkErr (agx2k3k_GetModelFromBuffer (vi, id_query_buffer, &actual_model));
        }
        else
        {
            checkErr (Ivi_SetAttributeViString (vi,
                                                VI_NULL,
                                                AGX2K3K_ATTR_ID_QUERY_RESPONSE,
                                                IVI_VAL_DONT_MARK_AS_SET_BY_USER,
                                                id_query_buffer));
        }

        if (actual_model != model_type)
        {
            viCheckErr (VI_ERROR_FAIL_ID_QUERY);
        }
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    if (error < VI_SUCCESS)
    {
        if (!Ivi_Simulating (vi) && io)
            viClose (io);
    }
    return error;
}

/*****************************************************************************
 * Function: viWrite and viRead Functions
 * Purpose:  These functions enable the instrument driver user to
 *           write and read commands directly to and from the instrument.
 *
 *           Notes: 1) These functions bypass the IVI attribute state caching.
 *                  viWrite invalidates the cached values for all
 *                  attributes.
 *                  2) These functions are supported with the IVI Compliance
 *                  Package (ICP) 4.6.1 and later. If you are using an
 *                  earlier version of ICP, you can still use the agx2k3k_WriteInstrData
 *                  and agx2k3k_ReadInstrData functions under the Obsolete folder.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_viWrite (ViSession vi, ViByte buffer[], ViInt64 count, ViInt64 *returnCount)
{
    return Ivi_viWrite (vi, buffer, count, returnCount);
}
DllExport ViStatus _VI_FUNC agx2k3k_viRead (ViSession vi, ViInt64 bufferSize, ViByte buffer[], ViInt64 *returnCount)
{
    return Ivi_viRead (vi, bufferSize, buffer, returnCount);
}

/*****************************************************************************
 * Function: agx2k3k_close
 * Purpose:  This function closes the instrument.
 *
 *           Note:  This function must unlock the session before calling
 *           Ivi_Dispose.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_close (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    checkErr (agx2k3k_IviClose (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    Ivi_Dispose (vi);

    return error;
}

/*****************************************************************************
 * Function: agx2k3k_IviClose
 * Purpose:  This function performs all of the drivers clean-up operations
 *           except for closing the IVI session.  This function is called by
 *           agx2k3k_close or by an IVI class driver.
 *
 *           Note:  This function must close the I/O session and set
 *           IVI_ATTR_IO_SESSION to 0.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_IviClose (ViSession vi)
{
    ViStatus  error = VI_SUCCESS;
    ViSession io    = VI_NULL;

    checkErr (Ivi_GetAttributeViSession (vi, VI_NULL, IVI_ATTR_IO_SESSION, 0, &io));

Error:
    Ivi_SetAttributeViSession (vi, VI_NULL, IVI_ATTR_IO_SESSION, 0, VI_NULL);
    if (io)
    {
        viClose (io);
    }
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_reset
 * Purpose:  This function resets the instrument.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_reset (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));
        viCheckErr (viPrintf (io, "*RST"));
    }

    checkErr (agx2k3k_DefaultInstrSetup (vi));

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_ResetWithDefaults
 * Purpose:  This function resets the instrument and applies default settings
 *           from the IVI Configuration Store based on the logical name
 *           from which the session was created.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ResetWithDefaults (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (agx2k3k_reset (vi));
    checkErr (Ivi_ApplyDefaultSetup (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/****************************************************************************
 *  Function: agx2k3k_Disable
 *  Purpose:  This function places the instrument in a quiescent state as
 *            quickly as possible.
 ****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_Disable (ViSession vi)
{
    return VI_SUCCESS;
}

/*****************************************************************************
 * Function: agx2k3k_self_test
 * Purpose:  This function executes the instrument self-test and returns the
 *           result.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_self_test (ViSession vi,
                                     ViInt16*    testResult,
                                     ViChar testMessage[])
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (testResult == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Test Result");

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));
        viCheckErr (viPrintf (io, "*TST?"));
        viCheckErr (viScanf (io, "%hd", testResult));
    }
    else
    {
        /* Simulate Self Test */
        *testResult = 0;
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_revision_query
 * Purpose:  This function returns the driver and instrument revisions.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_revision_query (ViSession vi,
                                          ViChar driverRev[],
                                          ViChar instrRev[])
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (driverRev == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Driver Revision");
    if (instrRev == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Instrument Revision");

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SPECIFIC_DRIVER_REVISION,
                                        0, 256, driverRev));
    checkErr (Ivi_GetAttributeViString (vi, "", AGX2K3K_ATTR_INSTRUMENT_FIRMWARE_REVISION,
                                        0, 256, instrRev));
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_error_query
 * Purpose:  This function queries the instrument error queue and returns
 *           the result.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_error_query (ViSession vi,
                                       ViInt32*        errCode,
                                       ViChar errMessage[])
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (errCode == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error Code");
    if (errMessage == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error Message");

    if (!Ivi_Simulating (vi))               /* call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);  /* call only when locked */

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));
        viCheckErr (viPrintf (io, ":SYST:ERR?"));
        viCheckErr (viScanf (io, "%ld,\"%256[^\"]", errCode, errMessage));
    }
    else
    {
        /* Simulate Error Query */
        *errCode = 0;
        strcpy (errMessage, "No error.");
    }

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_error_message
 * Purpose:  This function translates the error codes returned by this
 *           instrument driver into user-readable strings.
 *
 *           Note:  The caller can pass VI_NULL for the vi parameter.  This
 *           is useful if one of the init functions fail.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_error_message (ViSession vi, ViStatus errorCode,
                                         ViChar errorMessage[256])
{
    ViStatus                   error = VI_SUCCESS;

    static IviStringValueTable errorTable =
    {
        IVISCOPE_ERROR_CODES_AND_MSGS,
        { VI_NULL,                    VI_NULL}
    };

    if (vi)
        Ivi_LockSession (vi, VI_NULL);

    /* all VISA and IVI error codes are handled as well as codes in the table */
    if (errorMessage == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error Message");

    checkErr (Ivi_GetSpecificDriverStatusDesc (vi, errorCode, errorMessage, errorTable));

Error:
    if (vi)
        Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_InvalidateAllAttributes
 * Purpose:  This function invalidates the cached value of all attributes.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_InvalidateAllAttributes (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_InvalidateAllAttributes (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_GetError and agx2k3k_ClearError Functions
 * Purpose:  These functions enable the instrument driver user to
 *           get or clear the error information the driver associates with the
 *           IVI session.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_GetError (ViSession vi,
                                    ViStatus *errorCode,
                                    ViInt32 bufferSize,
                                    ViChar description[])
{
    ViStatus  error              = VI_SUCCESS;
    ViStatus  primary            = VI_SUCCESS,
              secondary          = VI_SUCCESS;
    ViChar    elaboration[256]   = "";
    ViChar    errorMessage[1024] = "";
    ViChar    *appendPoint       = errorMessage;
    ViInt32   actualSize         = 0;
    ViBoolean locked             = VI_FALSE;

    /* Lock Session */
    if (vi != VI_NULL)
    {
        checkErr (Ivi_LockSession (vi, &locked));
    }

    /* Test for nulls and acquire error data */
    if (bufferSize != 0)
    {
        if (errorCode == VI_NULL)
        {
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");
        }
        if (description == VI_NULL)
        {
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for Description");
        }
        checkErr (Ivi_GetErrorInfo (vi, &primary, &secondary, elaboration));
    }

    else
    {
        checkErr (Ivi_GetAttributeViString (vi, VI_NULL, IVI_ATTR_ERROR_ELABORATION, 0, 256, elaboration));
        checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, IVI_ATTR_SECONDARY_ERROR, 0, &secondary));
        checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, IVI_ATTR_PRIMARY_ERROR, 0, &primary));
    }

    /* Format data */
    if (primary != VI_SUCCESS)
    {
        ViChar msg[256] = "";
        checkErr (agx2k3k_error_message (vi, primary, msg));
        appendPoint += sprintf (appendPoint, "Primary Error: (Hex 0x%08X) %s\n", primary, msg);
    }

    if (secondary != VI_SUCCESS)
    {
        ViChar msg[256] = "";
        checkErr (agx2k3k_error_message (vi, secondary, msg));
        appendPoint += sprintf (appendPoint, "Secondary Error: (Hex 0x%08X) %s\n", secondary, msg);
    }

    if (elaboration[0])
    {
        sprintf (appendPoint, "Elaboration: %s", elaboration);
    }

    actualSize = (ViInt32) strlen (errorMessage) + 1;

    /* Prepare return values */
    if (bufferSize == 0)
    {
        error = actualSize;
    }
    else
    {
        if (bufferSize > 0)
        {
            if (actualSize > bufferSize)
            {
                error      = actualSize;
                actualSize = bufferSize;
            }
        }
        memcpy (description, errorMessage, actualSize - 1);
        description[actualSize - 1] = '\0';
    }

    if (errorCode)
    {
        *errorCode = primary;
    }

Error:
    /* Unlock Session */
    Ivi_UnlockSession (vi, &locked);
    return error;
}

DllExport ViStatus _VI_FUNC agx2k3k_ClearError (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_ClearErrorInfo (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_DeviceClear
 * Purpose:  This function clears the device input and output buffers.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_DeviceClear (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        viCheckErr (viClear (io));
    }

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_GetNextCoercionRecord
 * Purpose:  This function enables the instrument driver user to obtain
 *           the coercion information associated with the IVI session.
 *           This function retrieves and clears the oldest instance in which
 *           the instrument driver coerced a value the instrument driver user
 *           specified to another value.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_GetNextCoercionRecord (ViSession vi,
                                                 ViInt32 bufferSize,
                                                 ViChar record[])
{
    return Ivi_GetNextCoercionString (vi, bufferSize, record);
}

/****************************************************************************
 *  Function: agx2k3k_GetNextInterchangeWarning,
 *            agx2k3k_ResetInterchangeCheck, and
 *            agx2k3k_ClearInterchangeWarnings
 *  Purpose:  These functions allow the user to retrieve interchangeability
 *            warnings, reset the driver's interchangeability checking
 *            state, and clear all previously logged interchangeability warnings.
 ****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_GetNextInterchangeWarning (ViSession vi,
                                                     ViInt32 bufferSize,
                                                     ViChar warnString[])
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_GetNextInterchangeCheckString (vi, bufferSize, warnString));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

DllExport ViStatus _VI_FUNC agx2k3k_ResetInterchangeCheck (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_ResetInterchangeCheck (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

DllExport ViStatus _VI_FUNC agx2k3k_ClearInterchangeWarnings (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_ClearInterchangeWarnings (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_LockSession and agx2k3k_UnlockSession Functions
 * Purpose:  These functions enable the instrument driver user to lock the
 *           session around a sequence of driver calls during which other
 *           execution threads must not disturb the instrument state.
 *
 *           NOTE:  The callerHasLock parameter must be a local variable
 *           initialized to VI_FALSE and passed by reference, or you can pass
 *           VI_NULL.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_LockSession (ViSession vi, ViBoolean *callerHasLock)
{
    return Ivi_LockSession (vi, callerHasLock);
}
DllExport ViStatus _VI_FUNC agx2k3k_UnlockSession (ViSession vi, ViBoolean *callerHasLock)
{
    return Ivi_UnlockSession (vi, callerHasLock);
}

/****************************************************************************
 *  Function: agx2k3k_GetChannelName
 *  Purpose:  This function returns the highest-level channel name that
 *            corresponds to the specific driver channel string that is in
 *            the channel table at an index you specify.
 ****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_GetChannelName (ViSession vi,
                                          ViInt32 index,
                                          ViInt32 bufferSize,
                                          ViChar name[])
{
    ViStatus      error = VI_SUCCESS;
    ViConstString channelName;
    ViInt32       actualSize = 0;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (bufferSize != 0)
    {
        if (name == VI_NULL)
        {
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for Channel Name");
        }
    }

    /* Get channel name */
    viCheckParm (Ivi_GetNthChannelString (vi, index, &channelName), 2, "Index");
    checkErr (Ivi_GetUserChannelName (vi, channelName, &channelName));

    actualSize = (ViInt32) strlen (channelName) + 1;

    /* Prepare return values */
    if (bufferSize == 0)
    {
        error = actualSize;
    }
    else
    {
        if (bufferSize > 0)
        {
            if (actualSize > bufferSize)
            {
                error      = actualSize;
                actualSize = bufferSize;
            }
        }
        memcpy (name, channelName, actualSize - 1);
        name[actualSize - 1] = '\0';
    }

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*****************************************************************************
 *  Function: agx2k3k_ConfigureAcquisitionType
 *  Purpose:  This function sets the waveform acquisition type.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC  agx2k3k_ConfigureAcquisitionType (ViSession vi,
                                                     ViInt32 acquisitionType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi,
                                          VI_NULL,
                                          AGX2K3K_ATTR_ACQUISITION_TYPE,
                                          IVI_VAL_DIRECT_USER_CALL,
                                          acquisitionType), 2, "Acquisition Type");
    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureAcquisitionMode
 *  Purpose:  This function configures the acquisition mode.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureAcquisitionMode (ViSession vi,
                                                    ViInt32 acquisitionMode)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_ACQUISITION_MODE,
                                          IVI_VAL_DIRECT_USER_CALL, acquisitionMode), 2, "Acquisition Mode");
    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*****************************************************************************
 *  Function: agx2k3k_ConfigureAcquisitionRecord
 *  Purpose:  This function configures the most common attributes of
 *            the oscilloscope horizontal subsystem.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureAcquisitionRecord (ViSession vi,
                                                      ViReal64 timePerRecord,
                                                      ViInt32 minimumRecordLength,
                                                      ViReal64 acqStartTime)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_HORZ_TIME_PER_RECORD,
                                           0, timePerRecord),
                 2, "Time Per Record");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_HORZ_MIN_NUM_PTS,
                                          0, minimumRecordLength),
                 3, "Minimum Record Length");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_ACQUISITION_START_TIME,
                                           0, acqStartTime),
                 4, "Acquisition Start Time");
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureRecordMode
 *  Purpose:  This function configures the horizontal record mode.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureRecordMode (ViSession vi,
                                               ViInt32 horizontalRecordMode)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_HORZ_RECORD_MODE,
                                          0, horizontalRecordMode),
                 2, "Horizontal Record Mode");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureNumAverages
 *  Purpose:  This function sets the number of averages for the averaging
 *            acquisition type.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC  agx2k3k_ConfigureNumAverages (ViSession vi,
                                                 ViInt32 numberOfAverages)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi,
                                          VI_NULL,
                                          AGX2K3K_ATTR_NUM_AVERAGES,
                                          IVI_VAL_DIRECT_USER_CALL,
                                          numberOfAverages), 2, "Number Of Averages");
    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureInitiateContinuous
 *  Purpose:  This function configures the continous acquisition.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC  agx2k3k_ConfigureInitiateContinuous (ViSession vi,
                                                        ViBoolean continuous)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViBoolean (vi,
                                            VI_NULL,
                                            AGX2K3K_ATTR_INITIATE_CONTINUOUS,
                                            IVI_VAL_DIRECT_USER_CALL,
                                            continuous), 2, "Continuous");
    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureAcquisitionSegment
 *  Purpose:  This function configures the segmented acquisition.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureAcquisitionSegment (ViSession vi,
                                                       ViBoolean segmentAnalyzeEnable,
                                                       ViInt32 segmentCount,
                                                       ViInt32 segmentIndex)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_SEGMENT_COUNT,
                                          0, segmentCount),
                 3, "Segment Count");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_SEGMENT_INDEX,
                                          0, segmentIndex),
                 4, "Segment Index");

    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL,
                                            AGX2K3K_ATTR_SEGMENT_ANALYZE_ENABLE,
                                            0, segmentAnalyzeEnable),
                 2, "Segment Analyze Enable");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureChannel
 *  Purpose:  This function configures the most common attributes of
 *            the oscilloscope channel subsystem.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureChannel (ViSession vi,
                                            ViConstString channel,
                                            ViReal64 range,
                                            ViReal64 offset,
                                            ViInt32 coupling,
                                            ViReal64 probeAttenuation,
                                            ViBoolean enabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    if (Ivi_RangeChecking (vi))
    {
        if (channel == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (channel) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViReal64 (vi, channel,
                                           AGX2K3K_ATTR_PROBE_ATTENUATION,
                                           0, probeAttenuation),
                 6, "Probe Attenuation");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, channel,
                                           AGX2K3K_ATTR_VERTICAL_RANGE,
                                           0, range), 3, "Range");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, channel,
                                           AGX2K3K_ATTR_VERTICAL_OFFSET,
                                           0, offset), 4, "Offset");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, channel,
                                          AGX2K3K_ATTR_VERTICAL_COUPLING,
                                          0, coupling), 5, "Coupling");

    viCheckParm (Ivi_SetAttributeViBoolean (vi, channel,
                                            AGX2K3K_ATTR_CHANNEL_ENABLED,
                                            0, enabled), 7, "Channel Enabled");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureDigitalChannel
 *  Purpose:  This function configures the most common attributes of
 *            the oscilloscope digital channel subsystem.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureDigitalChannel (ViSession vi,
                                                   ViConstString channelName,
                                                   ViInt32 size,
                                                   ViReal64 threshold,
                                                   ViBoolean channelEnabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (channelName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (channelName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, channelName,
                                          AGX2K3K_ATTR_DIG_SIZE,
                                          0, size), 3, "Size");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, channelName,
                                           AGX2K3K_ATTR_DIG_THRESHOLD,
                                           0, threshold), 4, "Threshold");

    viCheckParm (Ivi_SetAttributeViBoolean (vi, channelName,
                                            AGX2K3K_ATTR_DIG_CHANNEL_ENABLED,
                                            0, channelEnabled), 5, "Channel Enabled");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureChanCharacteristics
 *  Purpose:  This function configures the less common attributes of
 *            the oscilloscope channel subsystem.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureChanCharacteristics (ViSession vi,
                                                        ViConstString channel,
                                                        ViReal64 inputImpedance,
                                                        ViReal64 maxInputFrequency)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (channel == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (channel) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViReal64 (vi, channel,
                                           AGX2K3K_ATTR_INPUT_IMPEDANCE,
                                           0, inputImpedance),
                 3, "Input Impedance");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, channel,
                                           AGX2K3K_ATTR_MAX_INPUT_FREQUENCY,
                                           0, maxInputFrequency),
                 4, "Max Input Frequency");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_AutoProbeSenseValue
 *  Purpose:  This function returns the actual probe attenuation when you
 *            configure the oscilloscope to sense the probe attenuation.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_AutoProbeSenseValue (ViSession vi,
                                               ViConstString channel,
                                               ViReal64 *autoProbeSenseValue)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (autoProbeSenseValue == VI_NULL)
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3,
                     "Null address for Auto Probe Sense Value");
    }
    checkErr (Ivi_GetAttributeViReal64 (vi, channel,
                                        AGX2K3K_ATTR_PROBE_SENSE_VALUE,
                                        0, autoProbeSenseValue));
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureChannelInvert
 *  Purpose:  This function inverts the input signal for the specified
 *            channel.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureChannelInvert (ViSession vi,
                                                  ViConstString channel,
                                                  ViBoolean invert)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (channel == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (channel) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViBoolean (vi, channel, AGX2K3K_ATTR_INVERT,
                                            0, invert),
                 3, "Invert");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureChannelVernier
 *  Purpose:  This function specifies whether the channel's vernier (fine
 *            vertical adjustment) setting is ON (1) or OFF (0).
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureChannelVernier (ViSession vi,
                                                   ViConstString channel,
                                                   ViBoolean vernier)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (channel == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (channel) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViBoolean (vi, channel,
                                            AGX2K3K_ATTR_VERNIER,
                                            0, vernier),
                 3, "Vernier");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureChannelProbe
 *  Purpose:  This function configures the probe.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureChannelProbe (ViSession vi,
                                                 ViConstString channel,
                                                 ViReal64 skew, ViInt32 units)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (channel == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (channel) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViReal64 (vi, channel, AGX2K3K_ATTR_PROBE_SKEW,
                                           0, skew), 3, "Skew");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, channel, AGX2K3K_ATTR_PROBE_UNITS,
                                          0, units), 4, "Units");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}



/*******************************************************************************
 * Function:  agx2k3k_ConfigureChannelProbeTek
 * Purpose:   Configures the model number of the supported Tektronix probe.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureChannelProbeTek (ViSession vi, ViConstString ChannelName, ViInt32 ProbeModel)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (ChannelName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (ChannelName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }
    viCheckParm (Ivi_SetAttributeViInt32 (vi, ChannelName, AGX2K3K_ATTR_CHANNEL_PROBE_TEK_MODEL,
                                          0, ProbeModel), 3, "Probe Model");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureChannelLabel
 *  Purpose:  This function configures the channel label.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureChannelLabel (ViSession vi,
                                                 ViConstString channel,
                                                 ViConstString label)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (channel == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");
        if (label == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");

        if ((strlen (channel) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
        if ((strlen (label) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, channel, AGX2K3K_ATTR_CHANNEL_LABEL,
                                           0, label), 3, "Label");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureDigitalPosition
 *  Purpose:  This function configures digital channel position.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureDigitalPosition (ViSession vi,
                                                    ViConstString channelName,
                                                    ViInt32 position)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (channelName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (channelName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, channelName, AGX2K3K_ATTR_DIG_POSITION,
                                          0, position), 3, "Position");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureTimebaseMode
 *  Purpose:  This function configures timebase mode.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTimebaseMode (ViSession vi,
                                                 ViInt32 timebaseMode)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TIMEBASE_MODE,
                                          0, timebaseMode), 2, "Timebase Mode");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureTimebase
 *  Purpose:  This function configures timebase parameters.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTimebase (ViSession vi,
                                             ViInt32 reference,
                                             ViBoolean vernier)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  timebaseMode;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_TIMEBASE_MODE,
                                       0,
                                       &timebaseMode));

    if (timebaseMode != AGX2K3K_VAL_TIMEBASE_XY && timebaseMode != AGX2K3K_VAL_TIMEBASE_ROLL)
    {
        viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TIMEBASE_REFERENCE,
                                              0, reference), 2, "Reference");
    }

    if (timebaseMode != AGX2K3K_VAL_TIMEBASE_XY)
    {
        viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_TIMEBASE_VERNIER,
                                                0, vernier), 3, "Vernier");
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureWindowTimebase
 *  Purpose:  This function configures window timebase parameters.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureWindowTimebase (ViSession vi,
                                                   ViReal64 position,
                                                   ViReal64 range,
                                                   ViReal64 scale)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_WIN_TIMEBASE_POSITION,
                                           0, position), 2, "Position");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_WIN_TIMEBASE_RANGE,
                                           0, range), 3, "Range");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_WIN_TIMEBASE_SCALE,
                                           0, scale), 3, "Scale");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureTrigger
 *  Purpose:  This function configures the common triggering attributes such
 *            as trigger type and holdoff.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC  agx2k3k_ConfigureTrigger (ViSession vi,
                                             ViInt32 triggerType,
                                             ViReal64 holdoff)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_TYPE,
                                          0, triggerType), 2, "Trigger Type");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_HOLDOFF,
                                           0, holdoff), 3, "Trigger Holdoff");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureTriggerCoupling
 *  Purpose:  This function configures the trigger coupling.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC  agx2k3k_ConfigureTriggerCoupling (ViSession vi,
                                                     ViInt32 coupling)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_COUPLING,
                                          0, coupling), 2, "Trigger Coupling");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureTriggerModifier
 *  Purpose:  This function configures the trigger modifier.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC  agx2k3k_ConfigureTriggerModifier (ViSession vi,
                                                     ViInt32 modifier)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_MODIFIER,
                                          0, modifier), 2, "Trigger Modifier");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureTriggerReject
 *  Purpose:  This function configures the trigger modifier.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTriggerReject (ViSession vi,
                                                  ViBoolean noiseReject,
                                                  ViBoolean HFReject)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_NOISE_REJECT,
                                            0, noiseReject), 2, "Noise Reject");

    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_HF_REJECT,
                                            0, HFReject), 3, "HF Reject");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureTriggerZone
 * Purpose:   Configures trigger zone source, multi-zones state, single zone state and zone mode.
 *
 *            Note:
 *			  It's applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTriggerZone (ViSession vi, ViConstString Zones, ViInt32 ZoneSource,
                                                ViBoolean ZoneStateEnable, ViInt32 ZoneMode, ViBoolean MultiChanZoneStateEnabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (Zones == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (Zones) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_ZONE_SOURCE,
                                          0, ZoneSource), 3, "Zone Source");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_ZONE_STATE_ENABLED,
                                            0, ZoneStateEnable), 4, "Zone State Enable");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, Zones, AGX2K3K_ATTR_TRIGGER_ZONE_MODE,
                                          0, ZoneMode), 5, "Zone Mode");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, Zones, AGX2K3K_ATTR_MULTICHANNEL_TRIGGER_ZONE_STATE_ENABLED,
                                            0, MultiChanZoneStateEnabled), 6, "Multi Chan Zone State Enabled");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureTriggerZonePlacement
 * Purpose:   Configures trigger zone placement.
 *
 *			  Note:
 *			  It's applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTriggerZonePlacement (ViSession vi, ViConstString Zones,
                                                         ViReal64 ZoneWidth, ViReal64 ZoneHeight, ViReal64 ZoneXCenter,
                                                         ViReal64 ZoneYCenter)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (Zones == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (Zones) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }


    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);


        viCheckErr (viPrintf (io, ":TRIG:%s:PLAC %lf,%lf,%lf,%lf", Zones, ZoneWidth, ZoneHeight, ZoneXCenter, ZoneYCenter));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}



/*******************************************************************************
 * Function:  agx2k3k_ReadTriggerZoneValidity
 * Purpose:   Reads the validity of trigger zone.
 *
 *			  Note:
 *			  It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadTriggerZoneValidity (ViSession vi, ViConstString Zones, ViChar ZoneValidity[256])
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (Zones == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (Zones) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        viCheckErr (viQueryf (io, ":TRIG:%s:VAL?", "%s", Zones, ZoneValidity));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureTriggerLevel
 *  Purpose:  This function configures the trigger level.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTriggerLevel (ViSession vi,
                                                 ViReal64 levelHigh,
                                                 ViReal64 levelLow)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_LEVEL_HIGH,
                                           0, levelHigh), 2, "Level High");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_LEVEL_LOW,
                                           0, levelLow), 3, "Level Low");

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*************************************************************************************************************************
 * Function:  agx2k3k_AutoSetupTriggerLevel
 * Purpose:   Automatically sets the trigger levels of all displayed analog channels to their waveforms' 50% values.
 *            If AC coupling is used, the trigger levels are set to 0 V. When High and Low (dual) trigger levels are used
 *			  (as with Rise/Fall Time and Runt triggers, for example), this command has no effect.
 *
 *			  Note:
 *			  It is applicable for 3000T X-Series and 4000 X-Series only.
 ***************************************************************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_AutoSetupTriggerLevel (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        checkErr (viPrintf (io, ":TRIG:LEV:ASET;"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureEdgeTriggerSource
 *  Purpose:  This function configures the edge triggering attributes.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC  agx2k3k_ConfigureEdgeTriggerSource (ViSession vi,
                                                       ViConstString source,
                                                       ViReal64 level,
                                                       ViInt32 slope)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (source == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (source) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                           AGX2K3K_ATTR_TRIGGER_SOURCE,
                                           0, source), 2, "Trigger Source");
    if (strcmp (source, AGX2K3K_VAL_LINE) != 0)
    {
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                               AGX2K3K_ATTR_TRIGGER_LEVEL,
                                               0, level), 3, "Trigger Level");
    }
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_TRIGGER_SLOPE,
                                          0, slope), 4, "Trigger Slope");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureEdgeTriggerReject
 *  Purpose:  This function configures the edge trigger reject filter.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureEdgeTriggerReject (ViSession vi,
                                                      ViInt32 triggerRejectFilter)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_REJECT_FILTER,
                                          0, triggerRejectFilter), 2, "Trigger Reject Filter");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureEdgeBurstTrigger
 *  Purpose:  This function configures the edge burst trigger.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureEdgeBurstTrigger (ViSession vi,
                                                     ViConstString triggerSource,
                                                     ViInt32 slope,
                                                     ViInt32 count,
                                                     ViReal64 idleTime)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (triggerSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (triggerSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                           AGX2K3K_ATTR_TRIGGER_SOURCE,
                                           0, triggerSource),
                 2, "Trigger Source");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_EBURST_SLOPE,
                                          0, slope),
                 3, "Slope");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_EBURST_COUNT,
                                          0, count),
                 4, "Count");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_EBURST_IDLE,
                                           0, idleTime),
                 5, "Idle Time");
    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureGlitchTriggerSource
 *  Purpose:  This function configures the scope for glitch triggering.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureGlitchTriggerSource (ViSession vi,
                                                        ViConstString source,
                                                        ViReal64 level,
                                                        ViReal64 glitchWidth,
                                                        ViInt32 glitchPolarity,
                                                        ViInt32 glitchCondition)

{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (source == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (source) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                           AGX2K3K_ATTR_TRIGGER_SOURCE,
                                           0, source),
                 2, "Trigger Source");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_TRIGGER_LEVEL,
                                           0, level),
                 3, "Trigger Level");
    /* Maximum Width */
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_GLITCH_WIDTH,
                                           0, glitchWidth),
                 4, "Glitch Width");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_GLITCH_POLARITY,
                                          0, glitchPolarity),
                 5, "Glitch Polarity");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_GLITCH_CONDITION,
                                          0, glitchCondition),
                 6, "Glitch Condition");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureGlitchWidth
 *  Purpose:  This function configures the pulse width.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureGlitchWidth (ViSession vi,
                                                ViReal64 minWidth)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    /* Minimum Width */
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_GLITCH_MIN_WIDTH,
                                           0, minWidth),
                 2, "Minimum Pulse Width");


    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureGlitchRange
 *  Purpose:  This function configures the pulse width duration.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureGlitchRange (ViSession vi,
                                                ViReal64 greaterThanTime,
                                                ViReal64 lessThanTime)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    checkErr (Ivi_LockSession (vi, VI_NULL));

    sprintf (buffer, "%Le, %Le", greaterThanTime, lessThanTime);

    checkErr (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_GLITCH_RANGE, 0, buffer));

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigurePatternTrigger
 *  Purpose:  This function configures Pattern Trigger.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePatternTrigger (ViSession vi,
                                                   ViConstString patternValue,
                                                   ViInt32 triggerCondition,
                                                   ViReal64 greaterThanTime,
                                                   ViReal64 lessThanTime)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (patternValue == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (patternValue) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                           AGX2K3K_ATTR_PATTERN,
                                           0, patternValue),
                 2, "Pattern Value");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_PATTERN_QUALIFIER,
                                          0, triggerCondition),
                 3, "Trigger Condition");

    switch (triggerCondition)
    {
    case AGX2K3K_VAL_PATTERN_GREATERTHAN:
    case AGX2K3K_VAL_PATTERN_TIMEOUT:
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                               AGX2K3K_ATTR_PATTERN_MIN,
                                               0, greaterThanTime),
                     4, "Greater Than Time");
        break;

    case AGX2K3K_VAL_PATTERN_INRANGE:
    case AGX2K3K_VAL_PATTERN_OUTRANGE:
        sprintf (buffer, "%Le, %Le", greaterThanTime, lessThanTime);
        checkErr (Ivi_SetAttributeViString (vi, VI_NULL,
                                            AGX2K3K_ATTR_PATTERN_RANGE,
                                            0, buffer));

        break;

    case AGX2K3K_VAL_PATTERN_LESSTHAN:
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                               AGX2K3K_ATTR_PATTERN_MAX,
                                               0, lessThanTime),
                     5, "Less Than Time");
        break;

    default:
        break;
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureCANBus
 *  Purpose:  This function configures CAN bus.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureCANBus (ViSession vi,
                                           ViConstString busName,
                                           ViConstString source,
                                           ViInt32 baudRate,
                                           ViInt32 signal)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (source == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (source) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_CAN_SOURCE,
                                           0, source),
                 2, "Source");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_CAN_BAUDRATE,
                                          0, baudRate),
                 3, "Baud Rate");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_CAN_SIGNAL,
                                          0, signal),
                 4, "Signal");
    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}




/*******************************************************************************
 * Function:  agx2k3k_ConfigureCANFDBus
 * Purpose:   Configures CAN FD sample points and FD Baud rate.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureCANFDBus (ViSession vi, ViConstString BusName, ViReal64 SamplePoint,
                                             ViInt32 BaudRate)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (BusName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (BusName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViReal64 (vi, BusName, AGX2K3K_ATTR_SBUS_CAN_FD_SAMPLE_POINT,
                                           0, SamplePoint), 3, "Sample Point");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_CAN_SIGNAL_FD_BAUDRATE,
                                          0, BaudRate), 4, "Baud Rate");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureCANTrigger
 *  Purpose:  This function configures CAN Trigger.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureCANTrigger (ViSession vi,
                                               ViConstString busName,
                                               ViInt32 trigger,
                                               ViInt32 dataLength,
                                               ViConstString patternData,
                                               ViInt32 idType,
                                               ViConstString idValue)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (patternData == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for Error");

        if ((strlen (patternData) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (idValue == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 7, "Null address for Error");

        if ((strlen (idValue) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_CAN_TRIGGER,
                                          0, trigger),
                 3, "Trigger");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_CAN_DATA_LENGTH,
                                          0, dataLength),
                 4, "Data Length");

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_CAN_DATA,
                                           0, patternData),
                 5, "Pattern Data");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_CAN_ID_MODE,
                                          0, idType),
                 6, "ID Type");

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_CAN_ID,
                                           0, idValue),
                 7, "ID Value");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************************************************************************
 * Function:  agx2k3k_ConfigureCANDisplay
 * Purpose:   Sets when CAN symbolic data is loaded into the oscilloscope, whether symbolic values (from the DBC file) or hexadecimal values
 *			  are displayed in the decode waveform and the Lister window.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureCANDisplay (ViSession vi, ViConstString BusName, ViInt32 DisplayType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (BusName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (BusName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_CAN_DISPLAY,
                                          0, DisplayType), 3, "Display Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}



/*******************************************************************************
 * Function:  agx2k3k_ConfigureCANTriggerPattern
 * Purpose:   Configures CAN trigger pattern data length value and start position for data triggers.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureCANTriggerPattern (ViSession vi, ViConstString BusName, ViInt32 DataLengthCode,
                                                      ViInt32 StartPosition)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (BusName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (BusName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_CAN_TRIGGER_PATTERN_DATA_DLC,
                                          0, DataLengthCode), 3, "Data Length Code");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_CAN_TRIGGER_PATTERN_DATA_START,
                                          0, StartPosition), 4, "Start Position");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureCANTriggerSymbolic
 * Purpose:   Configures CAN trigger symbolic message, signal name and signal value.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureCANTriggerSymbolic (ViSession vi, ViConstString BusName, ViConstString Message,
                                                       ViConstString SignalName, ViReal64 SignalValue)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (BusName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (BusName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (Message == NULL || strcmp (Message, "") == 0)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");

        if ((strlen (Message) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (SignalName == NULL || strcmp (SignalName, "") == 0)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for Error");

        if ((strlen (SignalName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_MESSAGE,
                                           0, Message), 3, "Message");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_SIGNAL,
                                           0, SignalName), 4, "Signal Name");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, BusName, AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_VALUE,
                                           0, SignalValue), 5, "Signal Value");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_EnableCANTriggerIDFilter
 * Purpose:   Specifies in certain error and bit trigger modes, whether triggers are filtered by CAN IDs.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_EnableCANTriggerIDFilter (ViSession vi, ViConstString BusName, ViBoolean IDFilterEnabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (BusName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (BusName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViBoolean (vi, BusName, AGX2K3K_ATTR_SBUS_CAN_TRIGGER_IDFILTER_ENABLED,
                                            0, IDFilterEnabled), 3, "IDFilter Enabled");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*****************************************************************************
 *  Function: agx2k3k_ConfigureIICBusSource
 *  Purpose:  This function configures the scope for IIC bus .
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureIICBusSource (ViSession vi,
                                                 ViConstString busName,
                                                 ViConstString serialClockSource,
                                                 ViConstString serialDataSource,
                                                 ViInt32 type)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (serialClockSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");
        if (serialDataSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");

        if ((strlen (serialClockSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
        if ((strlen (serialDataSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_IIC_SCL,
                                           0, serialClockSource),
                 3, "Serial Clock Source");
    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_IIC_SDA,
                                           0, serialDataSource),
                 4, "Serial Data Source");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_IIC_TYPE,
                                          0, type),
                 5, "Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureIICEEPROMQualifier
 *  Purpose:  This function configures the EEPROM qualifier.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureIICEEPROMQualifier (ViSession vi,
                                                       ViConstString busName,
                                                       ViInt32 qualifier)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_IIC_QUALIFIER,
                                          0, qualifier),
                 2, "Qualifier");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureIICData
 *  Purpose:  This function configures IIC Data.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureIICData (ViSession vi,
                                            ViConstString busName,
                                            ViInt32 address,
                                            ViInt32 addressSize,
                                            ViInt32 data,
                                            ViInt32 data2)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_IIC_ADDRESS,
                                          0, address),
                 3, "Address");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_IIC_SIZE,
                                          0, addressSize),
                 4, "Address Size");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_IIC_DATA,
                                          0, data),
                 5, "Data");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_IIC_DATA2,
                                          0, data2),
                 6, "Data 2");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureI2SBusSource
 *  Purpose:  This function configures I2S bus source.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureI2SBusSource (ViSession vi,
                                                 ViConstString busName,
                                                 ViConstString clockSource,
                                                 ViConstString dataSource,
                                                 ViConstString wsSource)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (clockSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");

        if ((strlen (clockSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (dataSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for Error");

        if ((strlen (dataSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (wsSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for Error");

        if ((strlen (wsSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_I2S_SOURCE_CLOCK,
                                           0, clockSource),
                 3, "Clock Source");

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_I2S_SOURCE_DATA,
                                           0, dataSource),
                 4, "Data Source");

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_I2S_SOURCE_WS,
                                           0, wsSource),
                 5, "WS Source");

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureI2SBus
 *  Purpose:  This function configures I2S bus.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureI2SBus (ViSession vi,
                                           ViConstString busName,
                                           ViInt32 rxWidth,
                                           ViInt32 txWidth,
                                           ViInt32 wsPolarity,
                                           ViInt32 clockSlope,
                                           ViInt32 alignment)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_I2S_RECEIVER_WIDTH,
                                          0, rxWidth),
                 3, "Rx Width");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_I2S_TRANSMIT_WIDTH,
                                          0, txWidth),
                 4, "Tx Width");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_I2S_WS_LOW,
                                          0, wsPolarity),
                 5, "WS Polarity");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_I2S_CLOCK_SLOPE,
                                          0, clockSlope),
                 6, "Clock Slope");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_I2S_ALIGNMENT,
                                          0, alignment),
                 7, "Alignment");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureI2STrigger
 *  Purpose:  This function configures I2S trigger.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureI2STrigger (ViSession vi,
                                               ViConstString busName,
                                               ViInt32 triggerCondition,
                                               ViInt32 triggerAudio,
                                               ViConstString patternData,
                                               ViInt32 rangeLow,
                                               ViInt32 rangeHigh)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (patternData == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for Error");

        if ((strlen (patternData) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_I2S_TRIGGER,
                                          0, triggerCondition),
                 3, "Trigger Condition");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_I2S_TRIGGER_AUDIO,
                                          0, triggerAudio),
                 4, "Trigger Audio");

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_I2S_TRIGGER_DATA,
                                           0, patternData),
                 5, "Pattern Data");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW,
                                          0, rangeLow),
                 6, "Range Low");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH,
                                          0, rangeHigh),
                 7, "Range High");


    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureLINBus
 *  Purpose:  This function configures LIN bus.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureLINBus (ViSession vi,
                                           ViConstString busName,
                                           ViConstString LINSource,
                                           ViInt32 baudRate,
                                           ViInt32 standard,
                                           ViInt32 syncBreak,
                                           ViBoolean parity)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (LINSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");

        if ((strlen (LINSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_LIN_SOURCE,
                                           /*AGX2K3K_ATTR_SBUS_LIN_TRIGGER,   */
                                           0, LINSource),
                 3, "LIN Source");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_LIN_BAUDRATE,
                                          0, baudRate),
                 4, "Baud Rate");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_LIN_STANDARD,
                                          0, standard),
                 5, "Standard");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_LIN_SYNC_BREAK,
                                          0, syncBreak),
                 6, "Sync Break");

    viCheckParm (Ivi_SetAttributeViBoolean (vi, busName,
                                            AGX2K3K_ATTR_SBUS_LIN_TRIGGER_ID,
                                            0, parity),
                 6, "Parity");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureLINSource
 *  Purpose:  This function configures the LIN triggering.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureLINTrigger (ViSession vi,
                                               ViConstString busName,
                                               ViInt32 triggerCondition,
                                               ViInt32 patternDataLength,
                                               ViConstString patternData,
                                               ViInt32 patternID)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (patternData == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for Error");

        if ((strlen (patternData) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_LIN_TRIGGER,
                                          0, triggerCondition),
                 3, "Trigger Condition");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA_LENGTH,
                                          0, patternDataLength),
                 4, "Pattern Data Length");

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA,
                                           0, patternData),
                 5, "Pattern Data");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_LIN_TRIGGER_ID,
                                          0, patternID),
                 6, "Pattern ID");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureLINTriggerSymbolic
 * Purpose:   Configures LIN symbolic characteristics.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureLINTriggerSymbolic (ViSession vi, ViConstString BusName, ViConstString Message,
                                                       ViConstString SignalName, ViReal64 SignalValue)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (BusName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (BusName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (Message == NULL || strcmp (Message, "") == 0)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");

        if ((strlen (Message) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (SignalName == NULL || strcmp (SignalName, "") == 0)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for Error");

        if ((strlen (SignalName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_FRAME,
                                           0, Message), 3, "Message");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_SIGNAL,
                                           0, SignalName), 4, "Signal Name");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, BusName, AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_VALUE,
                                           0, SignalValue), 5, "Signal Value");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureLINDisplay
 * Purpose:   Specifies when LIN symbolic data is loaded into the oscilloscope, whether symbolic values (from the LDF file) or hexadecimal values are displayed in the decode waveform and the Lister window.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureLINDisplay (ViSession vi, ViConstString BusName, ViInt32 DisplayType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (BusName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (BusName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_LIN_DISPLAY,
                                          0, DisplayType), 3, "Display Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/**************************************************************************************************************
 * Function:  agx2k3k_ConfigureSENT
 * Purpose:   Configures basic setting of serial bus SENT, including clock period, CRC format, number base, message
 *            format, idle state, nibbles length, whether to enable or disable pause pulse, input source and tolerance.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 **************************************************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSENT (ViSession vi, ViConstString BusName, ViReal64 NormalClockPeriod,
                                         ViInt32 CRCFormat, ViInt32 NumberBase, ViInt32 MessageFormat,
                                         ViInt32 IdleState, ViInt32 NibblesLength, ViBoolean PausePulseEnabled,
                                         ViInt32 InputSource, ViInt32 Tolerance)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (BusName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (BusName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViReal64 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_CLOCK,
                                           0, NormalClockPeriod), 3, "Normal Clock Period");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_CRC,
                                          0, CRCFormat), 4, "CRC Format");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_DISPLAY,
                                          0, NumberBase), 5, "Number Base");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_FORMAT,
                                          0, MessageFormat), 6, "Message Format");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_IDLE,
                                          0, IdleState), 7, "Idle State");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_LENGTH,
                                          0, NibblesLength), 8, "Nibbles Length");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_PPULSE_ENABLED,
                                            0, PausePulseEnabled), 9, "Pause Pulse Enabled");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_SOURCE,
                                          0, InputSource), 10, "Input Source");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_TOLERANCE,
                                          0, Tolerance), 11, "Tolerance");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureSENTTrigger
 * Purpose:   Configures the characteristics of SENT trigger.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSENTTrigger (ViSession vi, ViConstString BusName, ViInt32 TriggerMode,
                                                ViConstString FastData, ViInt32 SlowLength, ViInt32 SlowData, ViInt32 SlowID,
                                                ViInt32 Tolerance)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (BusName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (BusName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (FastData == NULL || strcmp (FastData, "") == 0)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for Error");

        if ((strlen (FastData) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_TRIGGER,
                                          0, TriggerMode), 3, "Trigger Mode");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_FAST_DATA,
                                           0, FastData), 4, "Fast Data");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_LENGTH,
                                          0, SlowLength), 7, "Slow Length");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_DATA,
                                          0, SlowData), 5, "Slow Data");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_ID,
                                          0, SlowID), 6, "Slow ID");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_TOLERANCE,
                                          0, Tolerance), 8, "Tolerance");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSENTSignal
 * Purpose:   Configures SENT signal characteristics of serial bus.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSENTSignal (ViSession vi, ViConstString BusName, ViConstString SignalName,
                                               ViBoolean DisplayEnabled, ViInt32 SignalLength, ViReal64 Multiplier,
                                               ViReal64 Offset, ViInt32 Order, ViInt32 StartBit)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (BusName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (BusName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (SignalName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");

        if ((strlen (SignalName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                           0, SignalName), 3, "Signal Name");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_DISPLAY_ENABLED,
                                            0, DisplayEnabled), 4, "Display Enabled");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_LENGTH,
                                          0, SignalLength), 5, "Signal Length");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_MULTIPLIER,
                                           0, Multiplier), 6, "Multiplier");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_OFFSET,
                                           0, Offset), 7, "Offset");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_ORDER,
                                          0, Order), 8, "Order");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_START,
                                          0, StartBit), 9, "Start Bit");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);

    return error;
}
/*****************************************************************************
 *  Function: agx2k3k_ConfigureSPITrigger
 *  Purpose:  This function configures the scope for SPI triggering.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSPITrigger (ViSession vi,
                                               ViConstString busName,
                                               ViInt32 triggerType,
                                               ViInt32 MISODataWidth,
                                               ViConstString MISODataValue,
                                               ViInt32 MOSIDataWidth,
                                               ViConstString MOSIDataValue)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");
        if (MISODataValue == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for Error");
        if (MOSIDataValue == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 7, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
        if ((strlen (MISODataValue) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
        if ((strlen (MOSIDataValue) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_SPI_TRIGGER_TYPE,
                                          0, triggerType),
                 3, "Trigger Type");

    switch (triggerType)
    {
    case AGX2K3K_VAL_SPI_TRIGGER_MOSI:
        viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                              AGX2K3K_ATTR_SBUS_SPI_MOSI_WIDTH,
                                              0, MOSIDataWidth),
                     3, "MOSI Data Width");

        viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                               AGX2K3K_ATTR_SBUS_SPI_MOSI_DATA,
                                               0, MOSIDataValue),
                     3, "MOSI Data Value");
        break;

    case AGX2K3K_VAL_SPI_TRIGGER_MISO:
        viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                              AGX2K3K_ATTR_SBUS_SPI_MISO_WIDTH,
                                              0, MISODataWidth),
                     3, "MISO Data Width");

        viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                               AGX2K3K_ATTR_SBUS_SPI_MISO_DATA,
                                               0, MISODataValue),
                     3, "MISO Data Value");
        break;

    default:
        break;
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*****************************************************************************
 *  Function: agx2k3k_ConfigureSPIBus
 *  Purpose:  This function configures the scope for SPI bus.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSPIBus (ViSession vi,
                                           ViConstString busName,
                                           ViConstString clockSource,
                                           ViConstString dataSource,
                                           ViConstString frameSource,
                                           ViInt32 frameBy,
                                           ViInt32 slope,
                                           ViInt32 bitOrder,
                                           ViInt32 wordWidth)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");
        if (clockSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");
        if (dataSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for Error");
        if (frameSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
        if ((strlen (clockSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
        if ((strlen (dataSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
        if ((strlen (frameSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_SPI_CLKSOURCE,
                                           0, clockSource),
                 3, "Clock Source");

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_SPI_DSOURCE,
                                           0, dataSource),
                 4, "Data Source");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_SPI_FRAME,
                                          0, frameBy),
                 6, "Frame by");

    if (frameBy == AGX2K3K_VAL_SPI_FRAME_CHIP || frameBy == AGX2K3K_VAL_SPI_FRAME_NCHIP)
    {
        viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                               AGX2K3K_ATTR_SBUS_SPI_FSOURCE,
                                               0, frameSource),
                     5, "Frame Source");
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_SPI_SLOPE,
                                          0, slope),
                 7, "Slope");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_SPI_BIT_ORDER,
                                          0, bitOrder),
                 8, "bitOrder");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_SPI_WORD_WIDTH,
                                          0, wordWidth),
                 9, "Word Width");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureSPITriggerTimeout
 *  Purpose:  This function configures the scope for SPI timeout.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSPITriggerTimeout (ViSession vi,
                                                      ViConstString busName,
                                                      ViReal64 timeout)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViReal64 (vi, busName,
                                           AGX2K3K_ATTR_SBUS_SPI_TIMEOUT,
                                           0, timeout),
                 3, "Timeout");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureRuntTriggerSource
 *  Purpose:  This function configures the runt triggering.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureRuntTriggerSource (ViSession vi,
                                                      ViConstString triggerSource,
                                                      ViReal64 runtLowThreshold,
                                                      ViReal64 runtHighThreshold,
                                                      ViInt32 runtPolarity)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                           AGX2K3K_ATTR_TRIGGER_SOURCE,
                                           0, triggerSource),
                 2, "Trigger Source");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_RUNT_LOW_THRESHOLD,
                                           0, runtLowThreshold),
                 3, "Runt Low Threshold");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_RUNT_HIGH_THRESHOLD,
                                           0, runtHighThreshold),
                 4, "Runt High Threshold");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_RUNT_POLARITY,
                                          0, runtPolarity),
                 5, "Runt Polarity");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureRuntTriggerWidth
 *  Purpose:  This function configures the runt trigger width.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureRuntTriggerWidth (ViSession vi,
                                                     ViInt32 triggerCondition,
                                                     ViReal64 runtTime)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_RUNT_QUALIFIER,
                                          0, triggerCondition),
                 2, "Trigger Condition");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_RUNT_TIME,
                                           0, runtTime),
                 3, "Runt Time");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureTransitionTrigger
 *  Purpose:  This function configures the transition triggering.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTransitionTrigger (ViSession vi,
                                                      ViConstString triggerSource,
                                                      ViInt32 slope,
                                                      ViInt32 triggerCondition,
                                                      ViReal64 transitionTime)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                           AGX2K3K_ATTR_TRIGGER_SOURCE,
                                           0, triggerSource),
                 2, "Trigger Source");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_TRANSITION_SLOPE,
                                          0, slope),
                 3, "Slope");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_TRANSITION_QUALIFIER,
                                          0, triggerCondition),
                 4, "Trigger Condition");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_TRANSITION_TIME,
                                           0, transitionTime),
                 5, "Transition Time");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureSetupHoldTrigger
 *  Purpose:  This function configures the setup-hold triggering.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSetupHoldTrigger (ViSession vi,
                                                     ViConstString clockSource,
                                                     ViConstString dataSource,
                                                     ViInt32 slope,
                                                     ViReal64 holdTime,
                                                     ViReal64 setupTime)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (clockSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Clock Source");

        if ((strlen (clockSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (dataSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Data Source");

        if ((strlen (dataSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                           AGX2K3K_ATTR_SETUPHOLD_CLKSRC,
                                           0, clockSource),
                 2, "Clock Source");

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                           AGX2K3K_ATTR_SETUPHOLD_DATASRC,
                                           0, dataSource),
                 3, "Data Source");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_SETUPHOLD_SLOPE,
                                          0, slope),
                 4, "Slope");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_SETUPHOLD_HOLD_TIME,
                                           0, holdTime),
                 5, "Hold Time");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_SETUPHOLD_SETUP_TIME,
                                           0, setupTime),
                 6, "Setup Time");

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureTVTriggerSource
 *  Purpose:  This function configures the scope for TV triggering.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTVTriggerSource (ViSession vi,
                                                    ViConstString source,
                                                    ViInt32 TVSignalFormat,
                                                    ViInt32 TVEvent,
                                                    ViInt32 TVPolarity)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (source == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (source) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                           AGX2K3K_ATTR_TRIGGER_SOURCE,
                                           0, source),
                 2, "Trigger Source");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_TV_TRIGGER_SIGNAL_FORMAT,
                                          0, TVSignalFormat),
                 3, "TV Signal Format");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_TV_TRIGGER_EVENT,
                                          0, TVEvent),
                 4, "TV Trigger Event");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_TV_TRIGGER_POLARITY,
                                          0, TVPolarity),
                 5, "TV Trigger Polarity");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureTVTriggerLineNumber
 *  Purpose:  This function configures the scope for TV triggering when the
 *            TV trigger event is a line number.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTVTriggerLineNumber (ViSession vi,
                                                        ViInt32 lineNumber)

{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_TV_TRIGGER_LINE_NUMBER,
                                          0, lineNumber),
                 2, "TV Trigger Line Number");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureUSBTriggerSource
 *  Purpose:  This function configures the scope for width triggering.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureUSBTriggerSource (ViSession vi,
                                                     ViInt32 trigger, ViInt32 speed,
                                                     ViConstString dPlus, ViConstString dMinus)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (dPlus == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for Error");
        if (dMinus == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for Error");

        if ((strlen (dPlus) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
        if ((strlen (dMinus) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_USB_TRIGGER,
                                          0, trigger),
                 2, "Trigger");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_USB_SPEED,
                                          0, speed),
                 3, "Speed");

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                           AGX2K3K_ATTR_USB_DPLUS,
                                           0, dPlus),
                 4, "D+");

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                           AGX2K3K_ATTR_USB_DMINUS,
                                           0, dMinus),
                 5, "D-");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureMathChannelEnabled
 *  Purpose:  This function configures math channel enabled
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMathChannelEnabled (ViSession vi,
                                                       ViBoolean channelEnabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL,
                                            AGX2K3K_ATTR_MATH_CHANNEL_ENABLED,
                                            0, channelEnabled),
                 2, "Channel Enabled");
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureMathChanMultiChan
 *  Purpose:  This function configures math channel enabled
 *            Note: This function is available only in 4000 series.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMathChanMultiChan (ViSession vi, ViChar functionChannel[],
                                                      ViBoolean channelEnabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViBoolean (vi, functionChannel,
                                            AGX2K3K_ATTR_MATH_CHANNEL_ENABLED_MULTICHANNEL,
                                            0, channelEnabled),
                 3, "Channel Enabled");
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureMathFunction
 *  Purpose:  This function configures the math channel.
 *  Note:     The source2 is ignored if the source1 is set to "GOFT", i.e. g(t)
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMathFunction (ViSession vi,
                                                 ViConstString source1,
                                                 ViConstString source2,
                                                 ViInt32 operation)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  iCurrentOp;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (source1 == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (source1) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (source2 == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");

        if ((strlen (source2) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    /* Get the current math operation before applying new operation so as *
     * to see whether we need to invalidate the sources.                  */
    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                       AGX2K3K_ATTR_MATH_OPERATION,
                                       0, &iCurrentOp));
    if ((agx2k3k_IsGtOperation (iCurrentOp) && !agx2k3k_IsGtOperation (operation))
        ||
        (!agx2k3k_IsGtOperation (iCurrentOp) && agx2k3k_IsGtOperation (operation)))
    {
        /* Since the current operation and the requesting operation refer to *
         * different commands, thus, we need to invalidate the sources       *
         * attributres so as to ensure they are set correctly.               */
        checkErr (Ivi_InvalidateAttribute (vi, VI_NULL, AGX2K3K_ATTR_MATH_SOURCE1));
        checkErr (Ivi_InvalidateAttribute (vi, VI_NULL, AGX2K3K_ATTR_MATH_SOURCE2));
    }

    /* Configure operation first, so that we can make decision for *
     * MATH_SOURCE1 & SOURCE2 base on the current operation.       */
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_MATH_OPERATION,
                                          0, operation),
                 4, "Operation");

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                           AGX2K3K_ATTR_MATH_SOURCE1,
                                           0, source1),
                 2, "Source1");

    /* If requesting operation is complex ones, i.e. integrate, Differentiate *
     * FFT or Square Root, set SOURCE2 to NONE automatically.                 */
    if (agx2k3k_IsComplexMathOperation (operation))
    {
        viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                               AGX2K3K_ATTR_MATH_SOURCE2,
                                               0, AGX2K3K_VAL_MATH_SOURCE2_NONE),
                     3, "Source2");
    }
    else
    {
        viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL,
                                               AGX2K3K_ATTR_MATH_SOURCE2,
                                               0, source2),
                     3, "Source2");
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureMathSettings
 *  Purpose:  This function configures math settings.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMathSettings (ViSession vi,
                                                 ViReal64 scale, ViReal64 offset)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_MATH_SCALE,
                                           0, scale), 2, "Scale");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_MATH_OFFSET,
                                           0, offset), 3, "Offset");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureMathMultiChan
 *  Purpose:  This function configures math settings.
 *            Note: This function is available only in 4000 series.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMathMultiChan (ViSession vi, ViChar functionChannel[],
                                                  ViReal64 scale, ViReal64 offset)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel,
                                           AGX2K3K_ATTR_MATH_SCALE_MULTICHANNEL,
                                           0, scale), 3, "Scale");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel,
                                           AGX2K3K_ATTR_MATH_OFFSET_MULTICHANNEL,
                                           0, offset), 4, "Offset");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureMathSmoothPointsNumber
 * Purpose:   Sets the number of smoothing points to use.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMathSmoothPointsNumber (ViSession vi, ViConstString FunctionChannels, ViInt32 PointsNumber)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (FunctionChannels == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (FunctionChannels) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, FunctionChannels, AGX2K3K_ATTR_MATH_SMOOTH_POINTS,
                                          0, PointsNumber), 3, "Points Number");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureMathFFTFrequency
 * Purpose:   Configures the start and stop frequency in the FFT math function's displayed range.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMathFFTFrequency (ViSession vi, ViConstString FunctionChannels, ViReal64 StartFrequency,
                                                     ViReal64 StopFrequency)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (FunctionChannels == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (FunctionChannels) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }


    viCheckParm (Ivi_SetAttributeViReal64 (vi, FunctionChannels, AGX2K3K_ATTR_MATH_FFT_FREQUENCY_START,
                                           0, StartFrequency), 3, "Start Frequency");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, FunctionChannels, AGX2K3K_ATTR_MATH_FFT_FREQUENCY_STOP,
                                           0, StopFrequency), 4, "Stop Frequency");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*****************************************************************************
 *  Function: agx2k3k_ConfigureMathFFT
 *  Purpose:  This function configures math FFT.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMathFFT (ViSession vi,
                                            ViReal64 span,
                                            ViReal64 center,
                                            ViInt32 window)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_MATH_SPAN,
                                           0, span), 2, "Span");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_MATH_CENTER,
                                           0, center), 3, "Center");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_MATH_WINDOW,
                                          0, window), 4, "Window");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureMathFFTMultiChan
 *  Purpose:  This function configures math FFT.
 *            Note: This function is available only in 4000 series.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMathFFTMultiChan (ViSession vi,
                                                     ViChar functionChannel[],
                                                     ViReal64 span,
                                                     ViReal64 center,
                                                     ViInt32 window)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel,
                                           AGX2K3K_ATTR_MATH_SPAN_MULTICHANNEL,
                                           0, span), 3, "Span");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel,
                                           AGX2K3K_ATTR_MATH_CENTER_MULTICHANNEL,
                                           0, center), 4, "Center");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, functionChannel,
                                          AGX2K3K_ATTR_MATH_WINDOW_MULTICHANNEL,
                                          0, window), 5, "Window");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ActualRecordLength
 *  Purpose:  This function returns the actual waveform record length the
 *            oscilloscope acquires.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ActualRecordLength (ViSession vi,
                                              ViInt32*    actualRecordLength)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (actualRecordLength == VI_NULL)
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2,
                     "Null address for Actual Record Length");
    }

    /* In order to eliminate timeout error when WAVEFORM:SOURCE is  *
     * incorrect, find and set the correct SOURCE before retrieving *
     * AGX2K3K_ATTR_HORZ_RECORD_LENGTH.                              */
    checkErr (agx2k3k_VerifyWaveformSource (vi));

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                       AGX2K3K_ATTR_HORZ_RECORD_LENGTH,
                                       0, actualRecordLength));
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_SampleMode
 *  Purpose:  This function returns the sample mode the oscilloscope uses for
 *            the acquisition.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC  agx2k3k_SampleMode (ViSession vi, ViInt32 *sampleMode)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (sampleMode == VI_NULL)
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2,
                     "Null address for Sample Mode");
    }
    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                       AGX2K3K_ATTR_SAMPLE_MODE,
                                       0, sampleMode));
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_SampleRate
 *  Purpose:  This function returns the effective sample rate of the
 *            oscilloscope.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC  agx2k3k_SampleRate (ViSession vi, ViReal64 *sampleRate)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (sampleRate == VI_NULL)
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2,
                     "Null address for Sample Rate");
    }
    checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL,
                                        AGX2K3K_ATTR_HORZ_SAMPLE_RATE,
                                        0, sampleRate));
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureUARTBus
 *  Purpose:  This function configures the UART bus.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureUARTBus (ViSession vi,
                                            ViConstString busName,
                                            ViInt32 baudRate,
                                            ViInt32 bitOrder,
                                            ViInt32 frameTerminateValue,
                                            ViInt32 parity,
                                            ViInt32 polarity,
                                            ViInt32 bitCount)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_UART_BAUDRATE,
                                          0, baudRate), 3, "Baud Rate");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_UART_BIT_ORDER,
                                          0, bitOrder), 4, "bitOrder");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_UART_FRAMING,
                                          0, frameTerminateValue), 5, "frameTerminateValue");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_UART_PARITY,
                                          0, parity), 6, "parity");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_UART_POLARITY,
                                          0, polarity), 7, "polarity");

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_UART_WIDTH,
                                          0, bitCount), 8, "bitCount");

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureUARTBusSource
 *  Purpose:  This function configures the UART bus source.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureUARTBusSource (ViSession vi,
                                                  ViConstString busName,
                                                  ViConstString rxSource,
                                                  ViConstString txSource)
{
    ViStatus error = VI_SUCCESS;


    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (rxSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");

        if ((strlen (rxSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (txSource == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for Error");

        if ((strlen (txSource) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_UART_SOURCE_RX,
                                           0, rxSource), 3, "Rx Source");

    viCheckParm (Ivi_SetAttributeViString (vi, busName,
                                           AGX2K3K_ATTR_SBUS_UART_SOURCE_TX,
                                           0, txSource), 4, "Tx Source");

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureUARTTrigger
 *  Purpose:  This function configures the UART triggering.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureUARTTrigger (ViSession vi,
                                                ViConstString busName,
                                                ViInt32 triggerType,
                                                ViInt32 triggerCondition,
                                                ViInt32 triggerData,
                                                ViInt32 burstValue,
                                                ViReal64 idlePeriod)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (busName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (busName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_UART_TRIGGER_TYPE,
                                          0, triggerType), 3, "triggerType");

    if (triggerType == AGX2K3K_VAL_UART_TRIGGER_RDATA ||
        triggerType == AGX2K3K_VAL_UART_TRIGGER_RD1 ||
        triggerType == AGX2K3K_VAL_UART_TRIGGER_RD0 ||
        triggerType == AGX2K3K_VAL_UART_TRIGGER_RDX ||
        triggerType == AGX2K3K_VAL_UART_TRIGGER_TDATA ||
        triggerType == AGX2K3K_VAL_UART_TRIGGER_TD1 ||
        triggerType == AGX2K3K_VAL_UART_TRIGGER_TD0 ||
        triggerType == AGX2K3K_VAL_UART_TRIGGER_TDX)
    {
        viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                              AGX2K3K_ATTR_SBUS_UART_TRIGGER_QUALIFIER,
                                              0, triggerCondition), 4, "Trigger Condition");

        viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                              AGX2K3K_ATTR_SBUS_UART_TRIGGER_DATA,
                                              0, triggerData), 5, "Trigger Data");
    }
    viCheckParm (Ivi_SetAttributeViInt32 (vi, busName,
                                          AGX2K3K_ATTR_SBUS_UART_TRIGGER_BURST,
                                          0, burstValue), 6, "Burst Value");

    viCheckParm (Ivi_SetAttributeViReal64 (vi, busName,
                                           AGX2K3K_ATTR_SBUS_UART_TRIGGER_IDLE,
                                           0, idlePeriod), 7, "Idle Period");

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureGeneratorAmplitude
 *  Purpose:  This function configures amplitude of waveform generator.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureGeneratorAmplitude (ViSession vi,
                                                       ViInt32 settingStyle,
                                                       ViReal64 amplitude,
                                                       ViReal64 offset,
                                                       ViReal64 highLevel,
                                                       ViReal64 lowLevel,
                                                       ViInt32 loadImpendance)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    switch (settingStyle)
    {
    case AGX2K3K_VAL_WGEN_AMPLITUDE_OFFSET:
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                               AGX2K3K_ATTR_WAVEGEN_VOLTAGE,
                                               0, amplitude), 3, "Amplitude");

        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                               AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET,
                                               0, offset), 4, "Offset");

        break;

    case AGX2K3K_VAL_WGEN_HIGH_LOW:
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                               AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH,
                                               0, highLevel), 5, "High Level");

        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                               AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW,
                                               0, lowLevel), 6, "Low Level");

        break;
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE,
                                          0, loadImpendance), 7, "Load Impendance");

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureGenAmpMultiChan
 *  Purpose:  This function configures amplitude of waveform generator.
 *            Note: This function is available only in 4000 series.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureGenAmpMultiChan (ViSession vi,
                                                    ViChar waveGenChannel[],
                                                    ViInt32 settingStyle,
                                                    ViReal64 amplitude,
                                                    ViReal64 offset,
                                                    ViReal64 highLevel,
                                                    ViReal64 lowLevel,
                                                    ViInt32 loadImpendance)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    switch (settingStyle)
    {
    case AGX2K3K_VAL_WGEN_AMPLITUDE_OFFSET:
        viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel,
                                               AGX2K3K_ATTR_WAVEGEN_VOLTAGE_MULTICHANNEL,
                                               0, amplitude), 4, "Amplitude");

        viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel,
                                               AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET_MULTICHANNEL,
                                               0, offset), 5, "Offset");

        break;

    case AGX2K3K_VAL_WGEN_HIGH_LOW:
        viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel,
                                               AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH_MULTICHANNEL,
                                               0, highLevel), 6, "High Level");

        viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel,
                                               AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW_MULTICHANNEL,
                                               0, lowLevel), 7, "Low Level");

        break;
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, waveGenChannel,
                                          AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE_MULTICHANNEL,
                                          0, loadImpendance), 8, "Load Impendance");

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureWaveform
 *  Purpose:  This function configures the waveform.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureWaveform (ViSession vi,
                                             ViInt32 functionType,
                                             ViInt32 settingSytle,
                                             ViReal64 period,
                                             ViReal64 frequency,
                                             ViReal64 symmetry,
                                             ViReal64 dutyCycle,
                                             ViReal64 pulseWidth)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                          AGX2K3K_ATTR_WAVEGEN_FUNCTION,
                                          0, functionType), 2, "Function Type");

    if (settingSytle == AGX2K3K_VAL_WGEN_STYLE_FREQUENCY)
    {
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                               AGX2K3K_ATTR_WAVEGEN_FREQUENCY,
                                               0, frequency), 5, "Frequency");
    }
    else if (settingSytle == AGX2K3K_VAL_WGEN_STYLE_PERIOD)
    {
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                               AGX2K3K_ATTR_WAVEGEN_PERIOD,
                                               0, period), 4, "Period");
    }

    switch (functionType)
    {
    case AGX2K3K_VAL_WAVEGEN_RAMP:
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                               AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY,
                                               0, symmetry), 6, "Symmetry");
        break;

    case AGX2K3K_VAL_WAVEGEN_SQUARE:
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                               AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE,
                                               0, dutyCycle), 7, "Duty Cycle");
        break;

    case AGX2K3K_VAL_WAVEGEN_PULSE:
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                               AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH,
                                               0, pulseWidth), 8, "Pulse Width");
        break;

    default:
        break;
    }

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureWaveformMultiChan
 *  Purpose:  This function configures the waveform.
 *            Note: This function is available only in 4000 series.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureWaveformMultiChan (ViSession vi,
                                                      ViChar waveGenChannel[],
                                                      ViInt32 functionType,
                                                      ViInt32 settingSytle,
                                                      ViReal64 period,
                                                      ViReal64 frequency,
                                                      ViReal64 symmetry,
                                                      ViReal64 dutyCycle,
                                                      ViReal64 pulseWidth)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, waveGenChannel,
                                          AGX2K3K_ATTR_WAVEGEN_FUNCTION_MULTICHANNEL,
                                          0, functionType), 3, "Function Type");

    if (settingSytle == AGX2K3K_VAL_WGEN_STYLE_FREQUENCY)
    {
        viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel,
                                               AGX2K3K_ATTR_WAVEGEN_FREQUENCY_MULTICHANNEL,
                                               0, frequency), 6, "Frequency");
    }
    else if (settingSytle == AGX2K3K_VAL_WGEN_STYLE_PERIOD)
    {
        viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel,
                                               AGX2K3K_ATTR_WAVEGEN_PERIOD_MULTICHANNEL,
                                               0, period), 5, "Period");
    }

    switch (functionType)
    {
    case AGX2K3K_VAL_WAVEGEN_RAMP:
        viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel,
                                               AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY_MULTICHANNEL,
                                               0, symmetry), 7, "Symmetry");
        break;

    case AGX2K3K_VAL_WAVEGEN_SQUARE:
        viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel,
                                               AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE_MULTICHANNEL,
                                               0, dutyCycle), 8, "Duty Cycle");
        break;

    case AGX2K3K_VAL_WAVEGEN_PULSE:
        viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel,
                                               AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH_MULTICHANNEL,
                                               0, pulseWidth), 9, "Pulse Width");
        break;

    default:
        break;
    }

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_EnableGeneratorOutput
 *  Purpose:  This function configures the output state of waveform generator.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_EnableGeneratorOutput (ViSession vi,
                                                 ViBoolean enableOutput)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL,
                                            AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE,
                                            0, enableOutput), 2, "Enable Output");
    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_EnableGenOutputMultiChan
 *  Purpose:  This function configures the output state of waveform generator.
 *            Note: This function is available only in 4000 series.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_EnableGenOutputMultiChan (ViSession vi, ViChar waveGenChannel[],
                                                    ViBoolean enableOutput)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViBoolean (vi, waveGenChannel,
                                            AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE_MULTICHANNEL,
                                            0, enableOutput), 3, "Enable Output");
    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/***********************************************************************************************************************
 * Function:  agx2k3k_ConfigureGeneratorOutputMode
 * Purpose:   Configures the output mode of waveform generators, and to control when the single-shot output
 *			  mode is selected, a single cycle of the defined waveform will be output or not. Sending the
 *			  single cycle output command multiple times will interrupt a slow signal output before the cycle is completed.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 ***********************************************************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureGeneratorOutputMode (ViSession vi, ViConstString WaveGenChannel, ViInt32 OutputMode, ViBoolean SingleCycleOutputEnabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (WaveGenChannel == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (WaveGenChannel) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, WaveGenChannel, AGX2K3K_ATTR_WAVEGEN_OUTPUT_MODE,
                                          0, OutputMode), 3, "Output Mode");

    if (OutputMode == AGX2K3K_VAL_WAVEGEN_OUTPUT_MODE_SINGLE && SingleCycleOutputEnabled == VI_TRUE)
    {
        ViSession io = Ivi_IOSession (vi);
        checkErr (viPrintf (io, ":%s:OUTP:SING;", WaveGenChannel));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureGeneratorTrackingPhase
 * Purpose:   Configures generator tracking phase.
 *
 *
 *            Note:
 *            It is applicable for 4000 X-Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureGeneratorTrackingPhase (ViSession vi, ViConstString WaveGenChannel, ViInt32 PhaseRelationship)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (WaveGenChannel == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (WaveGenChannel) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViInt32 (vi, WaveGenChannel, AGX2K3K_ATTR_WAVEGEN_TRACK_PHASE,
                                          0, PhaseRelationship), 3, "Phase Relationship");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*===========================================================================*
 *= IviScope Acquisition Group Group Functions =============================*
 *===========================================================================*/


/*******************************************************************************
 * Function:  agx2k3k_ConfigureRefSignalType
 * Purpose:   This function selects the 10 MHz reference signal type.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureRefSignalType (ViSession vi, ViInt32 ReferenceSignalMode)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_REFERENCE_SIGNAL_MODE,
                                          0, ReferenceSignalMode), 2, "Reference Signal Mode");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*===========================================================================*
 *= IviScope Digital Voltmeter Group Group Functions =============================*
 *===========================================================================*/


/*******************************************************************************
 * Function:  agx2k3k_ConfigureDigitalVoltmeter
 * Purpose:   This function controls the digital voltmeter (DVM) feature.
 *
 *            Note:
 *            To use this function, the optional DSOXDVM digital voltmeter analysis feature must be licensed.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureDigitalVoltmeter (ViSession vi,
                                                     ViBoolean AutoRange,
                                                     ViBoolean EnableDVM,
                                                     ViInt32 DVMMode,
                                                     ViInt32 DVMAnalogSource)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_DVM_ANALOG_SOURCE,
                                          0, DVMAnalogSource), 5, "DVM Analog Source");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_DVM_MODE,
                                          0, DVMMode), 4, "DVM Mode");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_DVM_ENABLED,
                                            0, EnableDVM), 3, "Enable DVM");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_DVM_AUTO_RANGE_ENABLED,
                                            0, AutoRange), 2, "Auto Range");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadDigitalVoltmeter
 * Purpose:   This function returns the displayed value of DVM.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadDigitalVoltmeter (ViSession vi,
                                                ViReal64 *DVMFrequency,
                                                ViReal64 *DVMCurrent)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_DVM_FREQUENCY,
                                           0, DVMFrequency), 2, "D VMFrequency");
    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_DVM_CURRENT,
                                           0, DVMCurrent), 3, "D VMCurrent");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*===========================================================================*
 *= IviScope Function Group Group Functions =============================*
 *===========================================================================*/


/*******************************************************************************
 * Function:  agx2k3k_ConfigureFunAverageNumber
 * Purpose:   This function sets the number of waveforms to be averaged together.
 *            The number of averages can be set from 2 to 65536 in increments of
 *            powers of 2. Increasing the number of averages will increase
 *            resolution and reduce noise.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFunAverageNumber (ViSession vi,
                                                     ViChar functionChannel[],
                                                     ViInt32 NumberAverages)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_NUM_AVERAGES,
                                          0, NumberAverages), 3, "Number Averages");


    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSelectedFunction
 * Purpose:   This function defines the full-scale vertical axis and voltage or
 *			  vertical value represented at center screen for the selected function.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSelectedFunction (ViSession vi,
                                                     ViChar functionChannel[],
                                                     ViReal64 VerticalAxis,
                                                     ViReal64 ReferenceLevel)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_VERTICAL_AXIS,
                                           0, VerticalAxis), 3, "Vertical Axis");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_REFERENCE_LEVEL,
                                           0, ReferenceLevel), 4, "Reference Level");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*===========================================================================*
 *= IviScope Marker Group Group Functions =============================*
 *===========================================================================*/


/*******************************************************************************
 * Function:  agx2k3k_ConfigureMarkerUnits
 * Purpose:   This function configures the marker unit settings.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMarkerUnits (ViSession vi, ViInt32 Dimension)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        if (Dimension == AGX2K3K_VAL_MARKER_DIMENSION_X)
        {
            viCheckErr (viPrintf (io, ":MARK:XUN:USE"));
        }
        else if (Dimension == AGX2K3K_VAL_MARKER_DIMENSION_Y)
        {
            viCheckErr (viPrintf (io, ":MARK:YUN:USE"));
        }
        else
        {
            viCheckErr (IVI_ERROR_INVALID_VALUE);
        }
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ReadMarkerDYDX
 * Purpose:   Reads the cursor deltaY/deltaX value.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadMarkerDYDX (ViSession vi, ViPReal64 DYDX)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viQueryf (io, ":MARK:DYDX?", "%lf", DYDX));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*===========================================================================*
 *= IviScope Measurement Group Group Functions =============================*
 *===========================================================================*/


/*******************************************************************************
 * Function:  agx2k3k_ReadQualityPowerAnalysis
 * Purpose:   This function returns the measurement of a quality power analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadQualityPowerAnalysis (ViSession vi,
                                                    ViReal64 *PhaseAngle,
                                                    ViReal64 *ApparentPower,
                                                    ViReal64 *CrestFactor,
                                                    ViReal64 *PowerFactor,
                                                    ViReal64 *ReactivePower,
                                                    ViReal64 *RealPower)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_POWER_PHASE_ANGLE,
                                           0, PhaseAngle), 2, "Phase Angle");
    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_APPARENT_POWER,
                                           0, ApparentPower), 3, "Apparent Power");
    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_CREST_FACOTR,
                                           0, CrestFactor), 4, "Crest Factor");
    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_POWER_FACTOR,
                                           0, PowerFactor), 5, "Power Factor");
    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_REACTIVE_POWER,
                                           0, ReactivePower), 6, "Reactive Power");
    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_REAL_POWER,
                                           0, RealPower), 7, "Real Power");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadCurrentValue
 * Purpose:   This function measures and returns the area value.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadCurrentValue (ViSession vi, ViReal64 *Area)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_AREA,
                                           0, Area), 2, "Area");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ClearMeasurementsMarkers
 * Purpose:   This function clears all selected measurements and markers from the screen.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ClearMeasurementsMarkers (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":MEAS:CLE"));
    }


    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadSwitchLossPowerAnalysis
 * Purpose:   This function returns the measurement of a switching loss power analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadSwitchLossPowerAnalysis (ViSession vi,
                                                       ViReal64 *PowerLossPerCycle,
                                                       ViReal64 *EnergyLoss,
                                                       ViReal64 *PowerLoss)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_POWER_LOSS_PER_CYCLE,
                                           0, PowerLossPerCycle), 2, "Power Loss Per Cycle");
    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_ENERGY_LOSS,
                                           0, EnergyLoss), 3, "Energy Loss");
    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_POWER_LOSS,
                                           0, PowerLoss), 4, "Power Loss");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadEfficiencyPowerAnalysis
 * Purpose:   This function returns the measurement of a efficiency power analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadEfficiencyPowerAnalysis (ViSession vi, ViReal64 *InputPower, ViReal64 *OutputPower)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_INPUT_POWER,
                                           0, InputPower), 2, "Input Power");
    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_OUTPUT_POWER,
                                           0, OutputPower), 3, "Output Power");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadOnOffTime
 * Purpose:   This function returns the measured turn on or off time.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadOnOffTime (ViSession vi, ViReal64 *TurnOffTime, ViReal64 *TurnOnTime)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_OFF_TIME,
                                           0, TurnOffTime), 2, "Turn Off Time");
    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_ON_TIME,
                                           0, TurnOnTime), 3, "Turn On Time");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureStatisticsType
 * Purpose:   This function configures the current statistics type.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureStatisticsType (ViSession vi, ViInt32 MeasureInformationType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_INFORMATION_TYPE,
                                          0, MeasureInformationType), 2, "Measure Information Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadDisplayedMeasurements
 * Purpose:   This function returns the results of the continuously displayed measurements.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadDisplayedMeasurements (ViSession vi,
                                                     ViChar ContinuouslyDisplayedMeasurements[],
                                                     ViInt32 ResultLength)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_CONTINUOUSLY_DISPLAYED_RESULTS,
                                           0, ResultLength, ContinuouslyDisplayedMeasurements), 2, "Continuously Displayed Measurements");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*===========================================================================*
 *= IviScope Power Group Group Functions =============================*
 *===========================================================================*/


/*******************************************************************************
 * Function:  agx2k3k_ReadPowerHarmonics
 * Purpose:   This function queries the power harmonics results table data.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadPowerHarmonics (ViSession vi,
                                              ViInt32 DataLength,
                                              ViChar TableData[])
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        ViUInt32  readCount;

        viCheckErr (viWrite (io, (ViBuf) ":POW:HARM:DATA?", 15, VI_NULL));
        viCheckErr (viRead (io, (ViPBuf) TableData, DataLength - 1, &readCount));
        TableData[readCount] = '\0';
    }


    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadHarmonicsPowerAnalysis
 * Purpose:   This function queries the results of harmonics power analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadHarmonicsPowerAnalysis (ViSession vi,
                                                      ViInt32 *FailCount,
                                                      ViReal64 *PowerFactor,
                                                      ViInt32 *IterationCount,
                                                      ViReal64 *TotalHarmonicsDistortion,
                                                      ViInt32 *OverallStatus)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_HARMONICS_FAIL_COUNT,
                                          0, FailCount), 2, "Fail Count");
    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_HARMONICS_POWER_FACTOR,
                                           0, PowerFactor), 3, "Power Factor");
    viCheckParm (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_HARMONICS_RUN_ITERATION_COUNT,
                                          0, IterationCount), 4, "Iteration Count");
    viCheckParm (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_HARMONICS_TOTAL_DISTORTION,
                                           0, TotalHarmonicsDistortion), 5, "Total Harmonics Distortion");
    viCheckParm (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_HARMONICS_FAIL_PASS_STATUS,
                                          0, OverallStatus), 6, "Overall Status");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerCycleCount
 * Purpose:   This function configures the cycle counts of power signals.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerCycleCount (ViSession vi,
                                                    ViInt32 HarmonicsCycleCount,
                                                    ViInt32 QualityCycleCount)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_HARMONICS_CYCLE_COUNT,
                                          0, HarmonicsCycleCount), 2, "Harmonics Cycle Count");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_QUALITY_CYCLE_COUNT,
                                          0, QualityCycleCount), 3, "Quality Cycle Count");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerDuration
 * Purpose:   This function configures the duration of power signals.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerDuration (ViSession vi,
                                                  ViReal64 EfficiencyDuration,
                                                  ViReal64 ModulationDuration,
                                                  ViReal64 TurnOffDuration,
                                                  ViReal64 TurnOnDuration,
                                                  ViReal64 RippleDuration,
                                                  ViReal64 TransientDuration)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_EFFICIENCY_DURATION,
                                           0, EfficiencyDuration), 2, "Efficiency Duration");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_MODULATION_DURATION,
                                           0, ModulationDuration), 3, "Modulation Duration");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_OFF_DURAQTION,
                                           0, TurnOffDuration), 4, "Turn Off Duration");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_ON_DURATION,
                                           0, TurnOnDuration), 5, "Turn On Duration");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_RIPPLE_DURATION,
                                           0, RippleDuration), 6, "Ripple Duration");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_TRANSIENT_DURATION,
                                           0, TransientDuration), 7, "Transient Duration");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerVoltage
 * Purpose:   This function configure the voltage settings of power signals.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerVoltage (ViSession vi,
                                                 ViReal64 InrushMaxVoltage,
                                                 ViReal64 TurnOffMaxVoltage,
                                                 ViReal64 TurnOnMaxVoltage,
                                                 ViReal64 TurnOffSteadyVoltage,
                                                 ViReal64 TurnOnSteadyVoltage,
                                                 ViReal64 TransientSteadyVoltage)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_IRUSH_MAX_VOLTAGE,
                                           0, InrushMaxVoltage), 2, "Inrush Max Voltage");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_OFF_MAX_VOLTAGE,
                                           0, TurnOffMaxVoltage), 3, "Turn Off Max Voltage");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_ON_MAX_VOLTAGE,
                                           0, TurnOnMaxVoltage), 4, "Turn On Max Voltage");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_OFF_DC_VOLTAGE,
                                           0, TurnOffSteadyVoltage), 5, "Turn Off Steady Voltage");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_ON_DC_VOLTAGE,
                                           0, TurnOnSteadyVoltage), 6, "Turn On Steady Voltage");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_TRANSIENT_DC_VOLTAGE,
                                           0, TransientSteadyVoltage), 7, "Transient Steady Voltage");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerInrushCurrent
 * Purpose:   This function configures the expected inrush current amplitude.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerInrushCurrent (ViSession vi, ViReal64 InrushCurrentAmplitude)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_IRUSH_AMPLITUDE,
                                           0, InrushCurrentAmplitude), 2, "Inrush Current Amplitude");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerControlResponse
 * Purpose:   Performs the control loop response
 *            (Bode) analysis to help you determine the margin of a control loop.
 *            A Bode plot measurement plots gain (A) in units of dB as a function of frequency.
 *            This control loop response analysis requires an input sine wave (from the
 *            oscilloscope's waveform generator, Vi) be swept from a low to a high frequency
 *            while measuring Vi and Vo RMS voltages at each step frequency, using two
 *            channels of the oscilloscope. Gain (A) at each step frequency is computed as
 *            20Log(Vo/Vi) and plotted using a math function waveform.
 *            It takes some time for the frequency sweep analysis to complete. You can query bit
 *            0 of the Standard Event Status Register (*ESR?) to find out when the analysis is
 *            complete.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerControlResponse (ViSession vi, ViInt32 StartFrequency, ViInt32 StopFrequency,
                                                         ViInt32 YMaximum, ViInt32 YMinimum)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_CLRESPONSE_FREQUENCY_START,
                                          0, StartFrequency), 2, "Start Frequency");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_CLRESPONSE_FREQUENCY_STOP,
                                          0, StopFrequency), 3, "Stop Frequency");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_CLRESPONSE_YMAXIMUM,
                                          0, YMaximum), 4, "Y Maximum");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_CLRESPONSE_YMINIMUM,
                                          0, YMinimum), 5, "Y Minimum");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerAnalysisEfficiency
 * Purpose:   Configures the type of power that is being converted from the input to the output.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerAnalysisEfficiency (ViSession vi, ViInt32 PowerEfficiencyType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_EFFICIENCY_TYPE,
                                          0, PowerEfficiencyType), 2, "Power Efficiency Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerAnalysisHarmonics
 * Purpose:   Configures harmonics power analysis, whether to use the real power value and set the value as well or defined by the user.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerAnalysisHarmonics (ViSession vi, ViInt32 PowerHarmonicsType, ViBoolean UserDefinedPowerEnabled,
                                                           ViReal64 UserDefinedPower)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_HARMONICS_REAL_POWER_TYPE,
                                          0, PowerHarmonicsType), 2, "Power Harmonics Type");
    if (UserDefinedPowerEnabled == VI_TRUE && PowerHarmonicsType == AGX2K3K_VAL_POWER_HARMONICS_REAL_POWER_SOURCE_USER)
    {
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_HARMONICS_REAL_POWER_VALUE,
                                               0, UserDefinedPower), 4, "User Defined Power");
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*===========================================================================*
 *= IviScope Serial Bus Group Group Functions =============================*
 *===========================================================================*/


/*******************************************************************************
 * Function:  agx2k3k_ReadSBusA429
 * Purpose:   This function returns serial bus A429 results.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadSBusA429 (ViSession vi,
                                        ViChar BusName[],
                                        ViInt32 *A429ErrorCount,
                                        ViInt32 *A429WordCount)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_GetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_A429_ERROR_COUNT,
                                          0, A429ErrorCount), 3, "A429 Error Count");
    viCheckParm (Ivi_GetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_A429_WORD_COUNT,
                                          0, A429WordCount), 4, "A429 Word Count");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureA429TriggerRange
 * Purpose:   This function configures the trigger range of serial bus A429.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureA429TriggerRange (ViSession vi,
                                                     ViChar BusName[],
                                                     ViConstString A429TriggerRange)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_A429_TRIGGER_RANGE,
                                           0, A429TriggerRange), 3, "A429 Trigger Range");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadSBusFlexray
 * Purpose:   This function returns serial bus flexray results.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadSBusFlexray (ViSession vi,
                                           ViChar BusName[],
                                           ViInt32 *FlexSyncFrameCount,
                                           ViInt32 *FlexTotalFrameCount)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_GetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_FLEX_SYNC_FRAME_COUNT,
                                          0, FlexSyncFrameCount), 3, "Flex Sync Frame Count");
    viCheckParm (Ivi_GetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_FLEX_TOTAL_FRAME_COUNT,
                                          0, FlexTotalFrameCount), 4, "Flex Total Frame Count");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadSBusErrorCount
 * Purpose:   Returns the Spec error (Ack + Form + Stuff + CRC errors) count.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadSBusErrorCount (ViSession vi, ViChar BusName[], ViPInt32 SpecErrorCount)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (BusName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (BusName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        viCheckErr (viQueryf (io, ":%s:CAN:COUN:SPEC?", "%d", BusName, SpecErrorCount));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFlexTriggerType
 * Purpose:   This function configures trigger type of flexray serial bus.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFlexTriggerType (ViSession vi,
                                                    ViChar BusName[],
                                                    ViInt32 FlexrayTriggerMode)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_FLEX_EVENT_TRIGGER_MODE,
                                          0, FlexrayTriggerMode), 3, "Flexray Trigger Mode");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureUSBTriggerSource2
 * Purpose:   This function configures trigger source of serial bus USB.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureUSBTriggerSource2 (ViSession vi,
                                                      ViChar BusName[],
                                                      ViInt32 Speed,
                                                      ViInt32 D_Plus,
                                                      ViInt32 D_Minus)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_USB_SPEED,
                                          0, Speed), 3, "Speed");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_USB_D_PLUS_SOURCE,
                                          0, D_Plus), 4, "D_ Plus");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_USB_D_MINUS_SOURCE,
                                          0, D_Minus), 5, "D_ Minus");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureUSBTriggerType
 * Purpose:   This function configures the USB trigger mode for the selected bus.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureUSBTriggerType (ViSession vi,
                                                   ViChar BusName[],
                                                   ViInt32 TriggerType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_MODE,
                                          0, TriggerType), 3, "Trigger Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureUSBPortion
 * Purpose:   This function configures the portion of the trigger for the selected bus.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureUSBPortion (ViSession vi,
                                               ViChar BusName[],
                                               ViConstString AddressPortion,
                                               ViConstString CRCPortion,
                                               ViConstString DataPortion,
                                               ViInt32 DataLength,
                                               ViConstString EndpointPortion)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_ADDRESS_PORTION,
                                           0, AddressPortion), 3, "Address Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_CRC_PORTION,
                                           0, CRCPortion), 4, "C RCPortion");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PORTION,
                                           0, DataPortion), 5, "Data Portion");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_LENGTH,
                                          0, DataLength), 6, "Data Length");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_ENDPOINT_PORTION,
                                           0, EndpointPortion), 7, "Endpoint Portion");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureUSBPortionAdvanced
 * Purpose:   This function configures the advanced portion settings of the trigger for the selected bus.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureUSBPortionAdvanced (ViSession vi,
                                                       ViChar BusName[],
                                                       ViConstString ETPortion,
                                                       ViConstString FramePortion,
                                                       ViConstString HubAddressPortion,
                                                       ViConstString PidCheckPortion,
                                                       ViConstString PortPortion,
                                                       ViConstString SCPortion,
                                                       ViConstString SEUPortion)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_ET_PORTION,
                                           0, ETPortion), 3, "ET Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_FRAME_PORTION,
                                           0, FramePortion), 4, "Frame Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_HUB_ADDRESS_PORTION,
                                           0, HubAddressPortion), 5, "Hub Address Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_PID_CHECK_PORTION,
                                           0, PidCheckPortion), 6, "Pid Check Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_PORT_PORTION,
                                           0, PortPortion), 7, "Port Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_SC_PORTION,
                                           0, SCPortion), 8, "SC Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_SEU_PORTION,
                                           0, SEUPortion), 9, "SEU Portion");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureUSBPID
 * Purpose:   This function configures the PID to trigger on for the selected bus.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureUSBPID (ViSession vi,
                                           ViChar BusName[],
                                           ViInt32 DataPid,
                                           ViInt32 HandshakePid,
                                           ViInt32 SpecialPid,
                                           ViInt32 TokenPid)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PID,
                                          0, DataPid), 3, "Data Pid");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_HANDSHAKE_PID,
                                          0, HandshakePid), 4, "Handshake Pid");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_SPECIAL_PID,
                                          0, SpecialPid), 5, "Special Pid");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_USB_TRIGGER_TOKEN_PID,
                                          0, TokenPid), 6, "Token Pid");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureUSBNormal
 * Purpose:   This function configures serial bus USB base and differential source for the selected bus.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureUSBNormal (ViSession vi,
                                              ViChar BusName[],
                                              ViInt32 UsbBase,
                                              ViInt32 UsbDifferentialSource)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_USB_BASE,
                                          0, UsbBase), 3, "Usb Base");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_SBUS_USB_DIFFERENTIAL_SOURCE,
                                          0, UsbDifferentialSource), 4, "Usb Differential Source");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*===========================================================================*
 *= IviScope Search Group Group Functions =============================*
 *===========================================================================*/


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSearchUSBType
 * Purpose:   This function configures the USB search type.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSearchUSBType (ViSession vi, ViInt32 SearchType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_SEARCH_MODE,
                                          0, SearchType), 2, "Search Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSearchUSBPortion
 * Purpose:   This function configures the portion of the search value.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSearchUSBPortion (ViSession vi,
                                                     ViConstString AddressPortion,
                                                     ViConstString CRCPortion,
                                                     ViConstString DataPortion,
                                                     ViInt32 DataLength,
                                                     ViConstString EndpointPortion)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_ADDRESS_PORTION,
                                           0, AddressPortion), 2, "Address Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_CRC_PORTION,
                                           0, CRCPortion), 3, "CRC Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_PORTION,
                                           0, DataPortion), 4, "Data Portion");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_LENGTH,
                                          0, DataLength), 5, "Data Length");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_ENDPOINT_PORTION,
                                           0, EndpointPortion), 6, "Endpoint Portion");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSearchUSBPortionAd
 * Purpose:   This function configures the advanced portion settings of the search value.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSearchUSBPortionAd (ViSession vi,
                                                       ViConstString ETPortion,
                                                       ViConstString FramePortion,
                                                       ViConstString HubAddressPortion,
                                                       ViConstString PortPortion,
                                                       ViConstString SCPortion,
                                                       ViConstString SEUPortion)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_ET_PORTION,
                                           0, ETPortion), 2, "ET Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_FRAME_PORTION,
                                           0, FramePortion), 3, "Frame Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_HUB_ADDRESS_PORTION,
                                           0, HubAddressPortion), 4, "Hub Address Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_PORT_PORTION,
                                           0, PortPortion), 5, "Port Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_SC_PORTION,
                                           0, SCPortion), 6, "SC Portion");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_SEU_PORTION,
                                           0, SEUPortion), 7, "SEU Portion");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSearchUSBPID
 * Purpose:   This function configure the PID to find.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSearchUSBPID (ViSession vi,
                                                 ViInt32 DataPid,
                                                 ViInt32 HandshakePid,
                                                 ViInt32 SpecialPid,
                                                 ViInt32 TokenPid)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_PID,
                                          0, DataPid), 2, "Data Pid");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_HANDSHAKE_PID,
                                          0, HandshakePid), 3, "Handshake Pid");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_SPECIAL_PID,
                                          0, SpecialPid), 4, "Special Pid");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_USB_TOKEN_PID,
                                          0, TokenPid), 5, "Token Pid");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSearchEventNumber
 * Purpose:   Configures search event number.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSearchEventNumber (ViSession vi, ViInt32 EventNumber)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_EVENT,
                                          0, EventNumber), 2, "Event Number");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSearchPeak
 * Purpose:   Configures peak event search.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSearchPeak (ViSession vi, ViReal64 Excursion, ViInt32 MaxPeaks,
                                               ViReal64 Threshold, ViInt32 PeakSource)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_PEAK_EXCURSION,
                                           0, Excursion), 2, "Excursion");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_PEAK_MAXIMUM_PEAKS,
                                          0, MaxPeaks), 3, "Max Peaks");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_PEAK_THRESHOLD,
                                           0, Threshold), 4, "Threshold");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_PEAK_SOURCE,
                                          0, PeakSource), 5, "Peak Source");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSearchSerialCAN
 * Purpose:   Configures the characteristics of serial bus CAN symbolic.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSearchSerialCAN (ViSession vi, ViConstString Message, ViConstString SignalName,
                                                    ViReal64 SignalValue)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (Message == NULL || strcmp (Message, "") == 0)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (Message) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (SignalName == NULL || strcmp (SignalName, "") == 0)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");

        if ((strlen (SignalName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_MESSAGE,
                                           0, Message), 2, "Message");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_SIGNAL,
                                           0, SignalName), 3, "Signal Name");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_VALUE,
                                           0, SignalValue), 4, "Signal Value");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSearchSerialLIN
 * Purpose:   Configures the characteristics of serial bus LIN symbolics.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSearchSerialLIN (ViSession vi, ViConstString Message, ViConstString SignalName,
                                                    ViReal64 SignalValue)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (Message == NULL || strcmp (Message, "") == 0)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (Message) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

        if (SignalName == NULL || strcmp (SignalName, "") == 0)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");

        if ((strlen (SignalName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_FRAME,
                                           0, Message), 2, "Message");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_SIGNAL,
                                           0, SignalName), 3, "Signal Name");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_VALUE,
                                           0, SignalValue), 4, "Signal Value");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSearchSerialSENT
 * Purpose:   Configures the characteristics of serial bus SENT.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSearchSerialSENT (ViSession vi, ViConstString FastData, ViInt32 Mode,
                                                     ViInt32 SlowData, ViInt32 SlowID)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (FastData == NULL || strcmp (FastData, "") == 0)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (FastData) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_SENT_FAST_DATA,
                                           0, FastData), 2, "Fast Data");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_SENT_MODE,
                                          0, Mode), 3, "Mode");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_SENT_SLOW_DATA,
                                          0, SlowData), 4, "Slow Data");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_SENT_SLOW_ID,
                                          0, SlowID), 5, "Slow ID");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*===========================================================================*
 *= IviScope WGEN Group Group Functions =============================*
 *===========================================================================*/



/*******************************************************************************
 * Function:  agx2k3k_ConfigureArbWaveformData
 * Purpose:   This function configures the data settings for arbitrary waveform.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureArbWaveformData (ViSession vi,
                                                    ViChar waveGenChannel[],
                                                    ViConstString ArbData,
                                                    ViConstString ArbDacData,
                                                    ViInt32 PointsCount)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViString (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_FLOAT_ARB_WAVEFORM,
                                           0, ArbData), 3, "Arb Data");
    viCheckParm (Ivi_SetAttributeViString (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_DAC_ARB_WAVEFORM,
                                           0, ArbDacData), 4, "Arb Dac Data");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_ARB_WAVEFORM_POINT_COUNT,
                                          0, PointsCount), 5, "Points Count");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ClearArbWaveformData
 * Purpose:   This function clears the arbitrary waveform memory and loads
 *            it with the default waveform.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ClearArbWaveformData (ViSession vi, ViChar waveGenChannel[])
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":%s:ARB:DATA:CLE", waveGenChannel));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_StoreArbWaveform
 * Purpose:   This function stores the source's waveform into the arbitrary
 *            waveform memory.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_StoreArbWaveform (ViSession vi,
                                            ViChar waveGenChannel[],
                                            ViInt32 Source)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_STORE_ARB_WAVEFORM,
                                          0, Source), 3, "Source");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}



/*******************************************************************************
 * Function:  agx2k3k_ConfigureModulationAM
 * Purpose:   This function configures the amplitude modulation.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureModulationAM (ViSession vi,
                                                 ViChar waveGenChannel[],
                                                 ViInt32 DepthPercent,
                                                 ViReal64 WaveformFrequency)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_COUNT,
                                          0, DepthPercent), 3, "Depth Percent");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_FREQUENCY,
                                           0, WaveformFrequency), 4, "Waveform Frequency");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureModulationFM
 * Purpose:   This function configures the modulating signal.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureModulationFM (ViSession vi,
                                                 ViChar waveGenChannel[],
                                                 ViReal64 Deviation,
                                                 ViReal64 Frequency)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_DEVIATION,
                                           0, Deviation), 3, "Deviation");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_FREQUENCY,
                                           0, Frequency), 4, "Frequency");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureModulationFSKey
 * Purpose:   This function configures FSK settings.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureModulationFSKey (ViSession vi,
                                                    ViChar waveGenChannel[],
                                                    ViReal64 Frequency,
                                                    ViReal64 Rate)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_HOP_FREQUENCY,
                                           0, Frequency), 3, "Frequency");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_RATE,
                                           0, Rate), 4, "Rate");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureModulationFunction
 * Purpose:   This function configures the modulating waveform shape and the amount of time per cycle that it is rising.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureModulationFunction (ViSession vi,
                                                       ViChar waveGenChannel[],
                                                       ViInt32 SignalShape,
                                                       ViInt32 RampSymmetry)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_MODULATION_SIGNAL_SHAPE,
                                          0, SignalShape), 3, "Signal Shape");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_MODULATION_RAMP_SYMMETRY,
                                          0, RampSymmetry), 4, "Ramp Symmetry");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureModulationState
 * Purpose:   This function enables or disables modulated waveform generator output. You can enable modulation for all waveform generator function types except pulse, DC, and noise.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureModulationState (ViSession vi,
                                                    ViChar waveGenChannel[],
                                                    ViBoolean EnableModulatedWaveform)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViBoolean (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_MODULATION_ENABLED,
                                            0, EnableModulatedWaveform), 3, "Enable Modulated Waveform");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureModulationType
 * Purpose:   This function selects the modulation type.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureModulationType (ViSession vi,
                                                   ViChar waveGenChannel[],
                                                   ViInt32 ModulationType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_MODULATION_TYPE,
                                          0, ModulationType), 3, "Modulation Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureGeneratorTracking
 * Purpose:   This function configures waveform generator tracking.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureGeneratorTracking (ViSession vi,
                                                      ViChar waveGenChannel[],
                                                      ViBoolean EnableTracking,
                                                      ViBoolean EnableAmplitudeTracking,
                                                      ViBoolean EnableFrequencyTracking,
                                                      ViBoolean SetIdentical)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViBoolean (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_TRACKING_ENABLED,
                                            0, EnableTracking), 3, "Enable Tracking");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_AMPLITUDE_TRACKING_ENABLED,
                                            0, EnableAmplitudeTracking), 4, "Enable Amplitude Tracking");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_FREQUENCY_TRACKING_ENABLED,
                                            0, EnableFrequencyTracking), 5, "Enable Frequency Tracking");

    if (!Ivi_Simulating (vi) && SetIdentical)
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":%s:TRAC:CSIG", waveGenChannel));
    }
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureGeneratorInverted
 * Purpose:   This function configures whether the waveform generator output is inverted.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureGeneratorInverted (ViSession vi,
                                                      ViChar waveGenChannel[],
                                                      ViInt32 OutputPolarity)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, waveGenChannel, AGX2K3K_ATTR_WAVEGEN_OUTPUT_POLARITY_INVERTED,
                                          0, OutputPolarity), 3, "Output Polarity");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*===========================================================================*
 *= IviScope Interpolation Group Group Functions =============================*
 *===========================================================================*/


/*******************************************************************************
 * Function:  agx2k3k_ConfigureInterpolation
 * Purpose:   This function configures the interpolation method between
 *            arbitrary waveform points, this function applies to both channel 1
 *            and channel 2.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureInterpolation (ViSession vi, ViInt32 InterpolationMethod)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, "WGEN1", AGX2K3K_ATTR_INTERPOLATION,
                                          0, InterpolationMethod), 2, "Interpolation Method");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, "WGEN2", AGX2K3K_ATTR_INTERPOLATION,
                                          0, InterpolationMethod), 2, "Interpolation Method");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}
/*******************************************************************************
 * Function:  agx2k3k_ConfigureInterpolationByChannel
 * Purpose:   This function configures the interpolation method between
 *            arbitrary waveform points.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureInterpolationByChannel (ViSession vi,
                                                           ViChar waveGenChannel[],
                                                           ViInt32 InterpolationMethod)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, waveGenChannel, AGX2K3K_ATTR_INTERPOLATION,
                                          0, InterpolationMethod), 3, "Interpolation Method");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


static IviRangeTableEntry attrComplianceUSBSignalQualityTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE_DHSS, 0, 0, "DHSS", 0 },
    { AGX2K3K_VAL_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE_HHSS, 0, 0, "HHSS", 0 },
    { AGX2K3K_VAL_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE_DLSS, 0, 0, "DLSS", 0 },
    { AGX2K3K_VAL_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE_HLSS, 0, 0, "HLSS", 0 },
    { AGX2K3K_VAL_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE_DFSS, 0, 0, "DFSS", 0 },
    { AGX2K3K_VAL_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE_HFSS, 0, 0, "HFSS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrComplianceUSBSignalQualityTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrComplianceUSBSignalQualityTypeRangeTableEntries,
};

static IviRangeTableEntry attrComplianceUSBTestConnectionRangeTableEntries[] =
{
    { AGX2K3K_VAL_COMPLIANCE_USB_TEST_CONNECTION_SINGLEENDED,  0, 0, "SING", 0 },
    { AGX2K3K_VAL_COMPLIANCE_USB_TEST_CONNECTION_DIFFERENTIAL, 0, 0, "DIFF", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrComplianceUSBTestConnectionRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrComplianceUSBTestConnectionRangeTableEntries,
};

static IviRangeTableEntry attrComplianceUSBTestTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_COMPLIANCE_USB_TEST_TYPE_NEAREND, 0, 0, "NEAR", 0 },
    { AGX2K3K_VAL_COMPLIANCE_USB_TEST_TYPE_FAREND,  0, 0, "FAR",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrComplianceUSBTestTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrComplianceUSBTestTypeRangeTableEntries,
};

/*******************************************************************************
 * Function:  agx2k3k_RunUSBComplianceTest
 * Purpose:   Runs USB compliance test.
 *
 *            Note:
 *            It is applicable for 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_RunUSBComplianceTest (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        viCheckErr (viPrintf (io, ":COMP:USB:RUN;"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_AutoSetupUSBComplianceTest
 * Purpose:   Auto setup USB compliance test.
 *
 *            Note:
 *            It is applicable for 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_AutoSetupUSBComplianceTest (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        viCheckErr (viPrintf (io, ":COMP:USB:AUT;"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureUSBComplianceTest
 * Purpose:   Configures Compliance USB test characteristics, set the test type, connection type and test end type.
 *
 *            Note:
 *            It is applicable for 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureUSBComplianceTest (ViSession vi, ViInt32 SignleQualityTestType, ViInt32 ConnectionType,
                                                      ViInt32 TestEndType, ViInt32 HubsNumber)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE,
                                          0, SignleQualityTestType), 2, "Signle Quality Test Type");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COMPLIANCE_USB_TEST_CONNECTION,
                                          0, ConnectionType), 3, "Connection Type");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COMPLIANCE_USB_TEST_TYPE,
                                          0, TestEndType), 4, "Test End Type");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COMPLIANCE_USB_HUBS,
                                          0, HubsNumber), 5, "Hubs Number");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureUSBComplianceSource
 * Purpose:   Configures USB Compliance sources.
 *
 *            Note:
 *            It is applicable for 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureUSBComplianceSource (ViSession vi, ViInt32 SourceAdjacent, ViInt32 SourceDifferential,
                                                        ViInt32 SourceDMinus, ViInt32 SourceDPlus)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_ADJACENT,
                                          0, SourceAdjacent), 2, "Source Adjacent");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DIFFERENTIAL,
                                          0, SourceDifferential), 3, "Source Differential");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DMINUS,
                                          0, SourceDMinus), 4, "Source DMinus");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DPLUS,
                                          0, SourceDPlus), 5, "Source DPlus");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}



/*******************************************************************************
 * Function:  agx2k3k_ClearFFTEvaluatedWaveforms
 * Purpose:   Clears the number of evaluated waveforms.
 *
 *            Note:
 *            It is applicable for 3000T X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ClearFFTEvaluatedWaveforms (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        viCheckErr (viPrintf (io, ":FFT:CLE;"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFFTAverageCount
 * Purpose:   Sets the number of waveforms to be averaged together.
 *
 *            Note:
 *            It is applicable for 3000T X-Series only.
 *            The FFT subsystem controls the FFT function in the oscilloscope.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFFTAverageCount (ViSession vi, ViInt32 FFTWaveformCount)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_FFT_AVERAGE_COUNT,
                                          0, FFTWaveformCount), 2, "FFT Waveform Count");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}



/*******************************************************************************
 * Function:  agx2k3k_ConfigureFFT
 * Purpose:   Configures the characteristics of the FFT function.
 *
 *            Note:
 *            It is applicable for 3000T X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFFT (ViSession vi, ViReal64 FFTVerticalOffset, ViReal64 FFTVerticalRange,
                                        ViReal64 FFTReferenceLevel, ViReal64 FFTVerticalScale, ViInt32 FFTVerticalScaleUnits,
                                        ViBoolean FFTDisplayEnabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FFT_VERTICAL_OFFSET,
                                           0, FFTVerticalOffset), 2, "FFT Vertical Offset");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FFT_VERTICAL_RANGE,
                                           0, FFTVerticalRange), 3, "FFT Vertical Range");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FFT_VERTICAL_REFERENCE,
                                           0, FFTReferenceLevel), 4, "FFT Reference Level");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FFT_VERTICAL_SCALE,
                                           0, FFTVerticalScale), 5, "FFT Vertical Scale");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_FFT_VERTICAL_UNIT,
                                          0, FFTVerticalScaleUnits), 6, "FFT Vertical Scale Units");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_FFT_DISPLAY_ENABLED,
                                            0, FFTDisplayEnabled), 7, "FFT Display Enabled");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureFFTFrequency
 * Purpose:   Configures the start and stop frequency in the FFT math function's displayed range.
 *            You can choose which method to set the frequency values:
 *            (1) By setting the start and stop frequency.
 *            (2) By setting the span and center.
 *
 *            Note:
 *            It is applicable for 3000T X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFFTFrequency (ViSession vi, ViInt32 FrequencyType, ViReal64 StartFrequency,
                                                 ViReal64 StopFrequency, ViReal64 FFTFrequencySpan, ViReal64 FFTFrequencyCenter)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (FrequencyType == AGX2K3K_VAL_FFT_FREQUENCY_TYPE_START_STOP)
    {
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FFT_FREQUENCY_START,
                                               0, StartFrequency), 3, "Start Frequency");
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FFT_FREQUENCY_STOP,
                                               0, StopFrequency), 4, "Stop Frequency");
    }
    else if (FrequencyType == AGX2K3K_VAL_FFT_FREQUENCY_TYPE_SPAN_CENTER)
    {
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FFT_FREQUENCY_SPAN,
                                               0, FFTFrequencySpan), 5, "FFT Frequency Span");
        viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FFT_FREQUENCY_CENTER,
                                               0, FFTFrequencyCenter), 6, "FFT Frequency Center");
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureFFTSource
 * Purpose:   Configures the FFT source.
 *
 *            Note:
 *            It is applicable for 3000T X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFFTSource (ViSession vi, ViInt32 FFTSource)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_FFT_SOURCE1,
                                          0, FFTSource), 2, "FFT Source");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureFFTWindowing
 * Purpose:   Allows the selection of four different windowing transform or operations for the FFT function.
 *
 *            Note:
 *            It is applicable for 3000T X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFFTWindowing (ViSession vi, ViInt32 FFTWindow)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_FFT_WINDOW,
                                          0, FFTWindow), 2, "F FTWindow");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureFFTDisplayMode
 * Purpose:   Sets the display mode for one of the FFT waveforms.
 *
 *            Note:
 *            It is applicable for 3000X series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFFTDisplayMode (ViSession vi, ViInt32 FFTDisplayMode)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_FFT_DISPLAY_MODE,
                                          0, FFTDisplayMode), 2, "FFT Display Mode");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_EnableCounter
 * Purpose:   Enables or disables the counter feature.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_EnableCounter (ViSession vi, ViBoolean CounterEnabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_COUNTER_ENABLE,
                                            0, CounterEnabled), 2, "Counter Enabled");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ResetTotalizerCount
 * Purpose:   Zeros the edge event counter.
 *
 *            Note:
 *            It is applicable for 3000T X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ResetTotalizerCount (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        viCheckErr (viWrite (io, (ViBuf) ":COUN:TOT:CLE;", 14, VI_NULL));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureCounter
 * Purpose:   Configures the counter characteristics.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureCounter (ViSession vi, ViInt32 CounterSource, ViInt32 CounterMode,
                                            ViInt32 CounterDigits)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COUNTER_SOURCE,
                                          0, CounterSource), 2, "Counter Source");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COUNTER_MODE,
                                          0, CounterMode), 3, "Counter Mode");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COUNTER_NUMBER_OF_DIGITS,
                                          0, CounterDigits), 4, "Counter Digits");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureCounterTotalizer
 * Purpose:   Configures the counter totalizer characteristics.
 *
 *            Note:
 *            It is applicable for 3000T X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureCounterTotalizer (ViSession vi, ViInt32 CounterSource, ViBoolean TotalizerGatingEnabled,
                                                     ViInt32 GatingSignalPolarity, ViInt32 TotalizerSlope)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_SOURCE,
                                          0, CounterSource), 2, "Counter Source");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_ENABLED,
                                            0, TotalizerGatingEnabled), 3, "Totalizer Gating Enabled");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_POLARITY,
                                          0, GatingSignalPolarity), 4, "Gating Signal Polarity");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_COUNTER_TOTALIZE_SLOPE,
                                          0, TotalizerSlope), 5, "Totalizer Slope");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadCounterValue
 * Purpose:   Returns the counter current value.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadCounterValue (ViSession vi, ViPReal64 CounterValue)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        viCheckErr (viQueryf (io, ":COUN:CURR?", "%lf", &CounterValue));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_AutoSetup
 *  Purpose:  This function performs an autosetup on the instrument.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_AutoSetup (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))               /* call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);  /* call only when locked */

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

        viCheckErr (viPrintf (io, ":AUT"));
    }

    checkErr (Ivi_InvalidateAllAttributes (vi));
    checkErr (agx2k3k_WaitForOPC (vi, 10000));
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ReadWaveform
 *  Purpose:  This function initiates a new waveform acquisition and
 *            returns a waveform from a specific channel.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadWaveform (ViSession vi,
                                        ViConstString channel,
                                        ViInt32 waveformSize,
                                        ViInt32 maxTime,
                                        ViReal64 waveform[],
                                        ViInt32 *actualPoints,
                                        ViReal64 *initialX,
                                        ViReal64 *xIncrement)
{
    ViBoolean     channelEnabled;
    ViInt32       acquisitionType;
    ViStatus      error       = VI_SUCCESS;
    ViConstString channelName = VI_NULL;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    /* Parameter Checking */
    /* Note: Not checking the following parameters: waveformSize, maxTime */

    viCheckParm (Ivi_CoerceChannelName (vi, channel, &channelName), 2, "Channel");

    checkErr (Ivi_GetAttributeViBoolean (vi, channelName,
                                         AGX2K3K_ATTR_CHANNEL_ENABLED,
                                         0, &channelEnabled));
    if (!channelEnabled && !Ivi_Simulating (vi))
        viCheckErrElab (AGX2K3K_ERROR_CHANNEL_NOT_ENABLED,
                        "Cannot read waveform from disabled channel.");

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                       AGX2K3K_ATTR_ACQUISITION_TYPE,
                                       0, &acquisitionType));

    if (acquisitionType == AGX2K3K_VAL_PEAK_DETECT)
    {
        viCheckErrElab (IVI_ERROR_INVALID_CONFIGURATION,
                        "Use ReadMinMaxWaveform for acquisition types "
                        "Peak Detect or Envelope.");
    }

    if (waveform == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for Waveform");
    if (actualPoints == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 6, "Null address for Actual Points");
    if (initialX == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 7, "Null address for Initial X");
    if (xIncrement == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 8, "Null address for X Increment");

    /* Read Waveform */
    checkErr (agx2k3k_InitiateAcquisition (vi));
    error = agx2k3k_WaitForOPC (vi, maxTime);

    if (error == VI_ERROR_TMO)
        error = AGX2K3K_ERROR_MAX_TIME_EXCEEDED;
    viCheckErr (error);

    checkErr (agx2k3k_FetchWaveformSafe (vi, channelName, waveformSize, waveform,
                                         actualPoints, initialX, xIncrement));
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}
/*****************************************************************************
 *  Function: agx2k3k_ReadEfficiency
 *  Purpose:  This function reads the measurment for efficiency setting.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadEfficiency (ViSession vi,
                                          ViReal64 *measurement)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    checkErr (agx2k3k_FetchEfficiency (vi, measurement));

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ReadRipple
 *  Purpose:  This function reads the measurment for ripple setting.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadRipple (ViSession vi,
                                      ViChar channelName[],
                                      ViReal64 *measurement)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    checkErr (agx2k3k_FetchRipple (vi, channelName, measurement));

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ReadMinMaxWaveform
 *  Purpose:  This function initiates new waveform acquisition and
 *            returns min and max waveforms from a specific channel.
 *            Call this function only when AGX2K3K_ATTR_ACQUISTION_TYPE
 *            is AGX2K3K_VAL_PEAK_DETECT.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadMinMaxWaveform (ViSession vi,
                                              ViConstString channel,
                                              ViInt32 waveformSize,
                                              ViInt32 maxTime,
                                              ViReal64 minWaveform[],
                                              ViReal64 maxWaveform[],
                                              ViInt32 *actualPoints,
                                              ViReal64 *initialX,
                                              ViReal64 *xIncrement)
{
    ViBoolean     channelEnabled;
    ViInt32       acquisitionType;
    ViConstString channelName = VI_NULL;
    ViStatus      error       = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    /* Parameter Checking */
    /* Note: Not checking the following parameters: waveformSize, maxTime */

    viCheckParm (Ivi_CoerceChannelName (vi, channel, &channelName), 2, "Channel");

    checkErr (Ivi_GetAttributeViBoolean (vi, channel, AGX2K3K_ATTR_CHANNEL_ENABLED,
                                         0, &channelEnabled));
    if (!channelEnabled && !Ivi_Simulating (vi))
        viCheckErrElab (AGX2K3K_ERROR_CHANNEL_NOT_ENABLED,
                        "Cannot read waveform from disabled channel.");

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                       AGX2K3K_ATTR_ACQUISITION_TYPE,
                                       0, &acquisitionType));

    if (acquisitionType != AGX2K3K_VAL_PEAK_DETECT)
    {
        viCheckErrElab (IVI_ERROR_INVALID_CONFIGURATION,
                        "Use Read/FetchMinMaxWaveform only for acquisition types "
                        "Peak Detect or Envelope.");
    }

    if (minWaveform == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for minWaveform");

    if (maxWaveform == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 6, "Null address for maxWaveform");

    if (actualPoints == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 7, "Null address for Actual Points");

    if (initialX == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 8, "Null address for Initial X");

    if (xIncrement == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 9, "Null address for X Increment");

    /* Read Min and Max Waveforms */
    checkErr (agx2k3k_InitiateAcquisition (vi));

    error = agx2k3k_WaitForOPC (vi, maxTime);

    if (error == VI_ERROR_TMO)
        error = AGX2K3K_ERROR_MAX_TIME_EXCEEDED;
    viCheckErr (error);

    checkErr (agx2k3k_FetchMinMaxWaveformSafe (vi, channelName, waveformSize,
                                               minWaveform, maxWaveform, actualPoints,
                                               initialX, xIncrement));
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ReadWaveformMeasurement
 *  Purpose:  This function initiates a new waveform acquisition and
 *            returns a specified waveform measurement from a specific
 *            channel.
 *****************************************************************************/
static IviRangeTableEntry attrMeasFuncRangeTableEntries[] =
{
    { AGX2K3K_VAL_AMPLITUDE,                  0, 0, "VAMP",      0 },
    { AGX2K3K_VAL_VOLTAGE_AVERAGE,            0, 0, "VAV",       0 },
    { AGX2K3K_VAL_VOLTAGE_LOW,                0, 0, "VBAS",      0 },
    { AGX2K3K_VAL_COUNTER,                    0, 0, "COUN",      0 },
    { AGX2K3K_VAL_DELAY,                      0, 0, "DEL",       0 },
    { AGX2K3K_VAL_DUTY_CYCLE_POS,             0, 0, "DUTY",      0 },
    { AGX2K3K_VAL_FALL_TIME,                  0, 0, "FALL",      0 },
    { AGX2K3K_VAL_FREQUENCY,                  0, 0, "FREQ",      0 },
    { AGX2K3K_VAL_VOLTAGE_MAX,                0, 0, "VMAX",      0 },
    { AGX2K3K_VAL_VOLTAGE_MIN,                0, 0, "VMIN",      0 },
    { AGX2K3K_VAL_OVERSHOOT,                  0, 0, "OVER",      0 },
    { AGX2K3K_VAL_VOLTAGE_PEAK_TO_PEAK,       0, 0, "VPP",       0 },
    { AGX2K3K_VAL_PERIOD,                     0, 0, "PER",       0 },
    { AGX2K3K_VAL_PHASE,                      0, 0, "PHAS",      0 },
    { AGX2K3K_VAL_PRESHOOT,                   0, 0, "PRES",      0 },
    { AGX2K3K_VAL_RISE_TIME,                  0, 0, "RIS",       0 },
    { AGX2K3K_VAL_VOLTAGE_RMS,                0, 0, "VRMS",      0 },
    { AGX2K3K_VAL_VOLTAGE_HIGH,               0, 0, "VTOP",      0 },
    { AGX2K3K_VAL_WIDTH_POS,                  0, 0, "PWID",      0 },
    { AGX2K3K_VAL_WIDTH_NEG,                  0, 0, "NWID",      0 },
    { AGX2K3K_VAL_X_AT_MAX,                   0, 0, "XMAX",      0 },
    { AGX2K3K_VAL_X_AT_MIN,                   0, 0, "XMIN",      0 },
    { AGX2K3K_VAL_BURST_WIDTH,                0, 0, "BWID",      0 },
    { AGX2K3K_VAL_NEGATIVE_EDGE,              0, 0, "NEDG",      0 },
    { AGX2K3K_VAL_NEGATIVE_PULSE,             0, 0, "NPUL",      0 },
    { AGX2K3K_VAL_POSITIVE_EDGE,              0, 0, "PEDG",      0 },
    { AGX2K3K_VAL_POSITIVE_PULSE,             0, 0, "PPUL",      0 },
    { AGX2K3K_VAL_VOLTAGE_RATIO,              0, 0, "VRAT",      0 },
    /* Added in version 3.1 */
    { AGX2K3K_VAL_BIT_RATE,                   0, 0, "BRAT",      0 },
    { AGX2K3K_VAL_NEGATIVE_DUTY,              0, 0, "NDUT",      0 },
    { AGX2K3K_VAL_RDS_ON,                     0, 0, "RDS",       0 },
    { AGX2K3K_VAL_VCE_SAT,                    0, 0, "VCES",      0 },
    { AGX2K3K_VAL_DUAL_CHARGE,                0, 0, "DUAL:CHAR", 0 },
    { AGX2K3K_VAL_DUAL_VERTICAL_AMPLITUDE,    0, 0, "DUAL:VAMP", 0 },
    { AGX2K3K_VAL_DUAL_AVERAGE_VALUE,         0, 0, "DUAL:VAV",  0 },
    { AGX2K3K_VAL_DUAL_WAVEFORM_BASE_VALUE,   0, 0, "DUAL:VBAS", 0 },
    { AGX2K3K_VAL_DUAL_VERTICAL_PEAK_TO_PEAK, 0, 0, "DUAL:VPP",  0 },
    { AGX2K3K_VAL_DUAL_VRMS,                  0, 0, "DUAL:VRMS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrMeasFuncRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    VI_NULL,
    attrMeasFuncRangeTableEntries,
};

DllExport ViStatus _VI_FUNC agx2k3k_ReadWaveformMeasurement (ViSession vi,
                                                   ViConstString channel,
                                                   ViInt32 measFunction,
                                                   ViInt32 maxTime,
                                                   ViReal64 *measurement)
{
    ViStatus      error = VI_SUCCESS;
    ViBoolean     channelEnabled;
    ViConstString channelName = VI_NULL;
    ViInt32       modelType   = UNKNOWN;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    /* Parameter Checking */
    /* Note: Not checking the following parameters: maxTime */
    if (channel != VI_NULL && strlen (channel) != 0)
    {
        viCheckParm (Ivi_CoerceChannelName (vi, channel, &channelName), 2, "Channel");
        checkErr (Ivi_GetAttributeViBoolean (vi, channelName, AGX2K3K_ATTR_CHANNEL_ENABLED,
                                             0, &channelEnabled));

        if (!channelEnabled)
            viCheckErrElab (AGX2K3K_ERROR_CHANNEL_NOT_ENABLED,
                            "Cannot read waveform from disabled channel.");

        checkErr (Ivi_GetAttributeViInt32 (vi,
                                           VI_NULL,
                                           AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                           0, &modelType));

        /*  Check channel name */
        switch (measFunction)
        {
        case AGX2K3K_VAL_COUNTER:
            if (IS_DSO_INSTR (modelType))
            {
                if ((strncmp (channelName, "CHAN", 4) != 0) && (strcmp (channelName, "EXT") != 0))
                {
                    viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);
                }
            }
            else if (IS_MSO_INSTR (modelType))
            {
                if ((strncmp (channelName, "CHAN", 4) != 0) && (strcmp (channelName, "EXT") != 0) &&
                    (strncmp (channelName, "DIG", 3) != 0))
                {
                    viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);
                }
            }
            break;

        case AGX2K3K_VAL_DELAY:
            if ((strncmp (channelName, "CHAN", 4) != 0) && (strncmp (channelName, "FUNC", 4) != 0) &&
                (strncmp (channelName, "WMEM", 4) != 0))
            {
                viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);
            }
            break;

        case AGX2K3K_VAL_DUTY_CYCLE_POS:
        case AGX2K3K_VAL_FALL_TIME:
        case AGX2K3K_VAL_FREQUENCY:
        case AGX2K3K_VAL_NEGATIVE_EDGE:
        case AGX2K3K_VAL_NEGATIVE_PULSE:
        case AGX2K3K_VAL_WIDTH_NEG:
        case AGX2K3K_VAL_PERIOD:
        case AGX2K3K_VAL_WIDTH_POS:
            if (IS_DSO_INSTR (modelType))
            {
                if ((strncmp (channelName, "CHAN", 4) != 0) && (strncmp (channelName, "FUNC", 4) != 0) &&
                    (strncmp (channelName, "WMEM", 4) != 0))
                {
                    viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);
                }
            }
            else if (IS_MSO_INSTR (modelType))
            {
                if ((strncmp (channelName, "CHAN", 4) != 0) && (strncmp (channelName, "FUNC", 4) != 0) &&
                    (strncmp (channelName, "WMEM", 4) != 0) && (strncmp (channelName, "DIG", 3) != 0))
                {
                    viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);
                }
            }
            break;

        case AGX2K3K_VAL_OVERSHOOT:
        case AGX2K3K_VAL_POSITIVE_EDGE:
        case AGX2K3K_VAL_PHASE:
        case AGX2K3K_VAL_POSITIVE_PULSE:
        case AGX2K3K_VAL_PRESHOOT:
        case AGX2K3K_VAL_RISE_TIME:
        case AGX2K3K_VAL_AMPLITUDE:
        case AGX2K3K_VAL_VOLTAGE_AVERAGE:
        case AGX2K3K_VAL_VOLTAGE_LOW:
        case AGX2K3K_VAL_VOLTAGE_MAX:
        case AGX2K3K_VAL_VOLTAGE_MIN:
        case AGX2K3K_VAL_VOLTAGE_PEAK_TO_PEAK:
        case AGX2K3K_VAL_VOLTAGE_RATIO:
            if ((strncmp (channelName, "CHAN", 4) != 0) && (strncmp (channelName, "FUNC", 4) != 0) &&
                (strncmp (channelName, "WMEM", 4) != 0))
            {
                viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);
            }
            break;

        case AGX2K3K_VAL_BIT_RATE:
        case AGX2K3K_VAL_NEGATIVE_DUTY:
            if ((strncmp (channelName, "CHAN", 4) != 0) && (strncmp (channelName, "FUNC", 4) != 0) &&
                (strncmp (channelName, "DIG", 3) != 0) && (strncmp (channelName, "WMEM", 4) != 0) &&
                (strncmp (channelName, "MATH", 4) != 0))
            {
                viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);
            }
            break;

        case AGX2K3K_VAL_RDS_ON:
        case AGX2K3K_VAL_VCE_SAT:
            if ((strncmp (channelName, "CHAN", 4) != 0) && (strncmp (channelName, "FUNC", 4) != 0) &&
                (strncmp (channelName, "MATH", 4) != 0) && (strncmp (channelName, "WMEM", 4) != 0))
            {
                viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);
            }
            break;

        case AGX2K3K_VAL_DUAL_CHARGE:
        case AGX2K3K_VAL_DUAL_VERTICAL_AMPLITUDE:
        case AGX2K3K_VAL_DUAL_AVERAGE_VALUE:
        case AGX2K3K_VAL_DUAL_WAVEFORM_BASE_VALUE:
        case AGX2K3K_VAL_DUAL_VERTICAL_PEAK_TO_PEAK:
        case AGX2K3K_VAL_DUAL_VRMS:
            if ((strncmp (channelName, "CHAN", 4) != 0))
            {
                viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);
            }
            break;
        }
    }
    else
    {
        channelName = "";
    }

    viCheckParm (Ivi_GetViInt32EntryFromValue (measFunction, &attrMeasFuncRangeTable, VI_NULL, VI_NULL,
                                               VI_NULL, VI_NULL, VI_NULL, VI_NULL),
                 3, "Measurement Function");
    if (measurement == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for Measurement");

    /* Read Waveform Measurement */
/*    checkErr( agx2k3k_InitiateAcquisition (vi));
 *
 *  error = agx2k3k_WaitForOPC (vi, maxTime);
 */
    if (error == VI_ERROR_TMO)
        error = AGX2K3K_ERROR_MAX_TIME_EXCEEDED;
    viCheckErr (error);

    checkErr (agx2k3k_FetchWaveformMeasurementSafe (vi, channelName,
                                                    measFunction, measurement));
    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_InitiateAcquisition
 *  Purpose:  This function initiates waveform acquisition.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_InitiateAcquisition (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))                /* call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /* call only when locked */

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

        viCheckErr (viBufWrite (io, (ViBuf) ":DIG;", 5, VI_NULL));
    }

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_AcquisitionStatus
 *  Purpose:  This function determines if an acquisition is in
 *            progress or has completed. If it cannot determine the acquisition
 *            status, it returns AGX2K3K_VAL_ACQ_STATUS_UNKNOWN.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_AcquisitionStatus (ViSession vi,
                                             ViInt32 *statusRef)
{
    ViStatus error  = VI_SUCCESS;
    ViInt32  status = AGX2K3K_VAL_ACQ_STATUS_UNKNOWN;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (statusRef == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Status");


    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io  = Ivi_IOSession (vi);  /*  call only when locked */
        ViInt32   pct = 0;
        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

        viCheckErr (viQueryf (io, ":ACQ:COMP?", "%d", &pct));

        if (pct < 100)
            status = AGX2K3K_VAL_ACQ_IN_PROGRESS;
        else
            status = AGX2K3K_VAL_ACQ_COMPLETE;
    }
    else
    {
        status = AGX2K3K_VAL_ACQ_COMPLETE;
    }

Error:
    *statusRef = status;
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}
/*****************************************************************************
 *  Function: agx2k3k_FetchEfficiency
 *  Purpose:  This function fetches the Efficiency measurement
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_FetchEfficiency (ViSession vi,
                                           ViReal64 *measurement)
{
    ViStatus  error = VI_SUCCESS;
    ViSession io    = Ivi_IOSession (vi);

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        viQueryf (io, ":MEAS:EFF?", "%lf", measurement);
    }

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_FetchRipple
 *  Purpose:  This function fetches the Ripple measurement
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_FetchRipple (ViSession vi,
                                       ViChar channelName[],
                                       ViReal64 *measurement)
{
    ViStatus  error = VI_SUCCESS;
    ViSession io    = Ivi_IOSession (vi);

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        viQueryf (io, ":MEAS:RIPP? %s", "%lf", channelName, measurement);
    }
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_FetchWaveform
 *  Purpose:  This function fetches a waveform from a specified
 *            channel from a previously initiated acquisition.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_FetchWaveform (ViSession vi,
                                         ViConstString channel,
                                         ViInt32 waveformSize,
                                         ViReal64 waveform[],
                                         ViInt32 *actualPoints,
                                         ViReal64 *initialX,
                                         ViReal64 *xIncrement)
{
    ViStatus      error = VI_SUCCESS;
    ViInt32       acquisitionType;
    ViConstString channelName;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    /* Parameter Checking */
    /* Note: Not checking the waveformSize parameter */

    viCheckParm (Ivi_CoerceChannelName (vi, channel, &channelName), 2, "Channel");

    if (waveform == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for Waveform");

    if (actualPoints == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for Actual Points");

    if (initialX == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 6, "Null address for Initial X");

    if (xIncrement == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 7, "Null address for X Increment");

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                       AGX2K3K_ATTR_ACQUISITION_TYPE,
                                       0, &acquisitionType));

    if (acquisitionType == AGX2K3K_VAL_PEAK_DETECT)
    {
        viCheckErrElab (IVI_ERROR_INVALID_CONFIGURATION,
                        "Use FetchMinMaxWaveform for acquisition types "
                        "Peak Detect or Envelope.");
    }

    /* Fetch Waveform */
    checkErr (agx2k3k_FetchWaveformSafe (vi, channelName, waveformSize,
                                         waveform, actualPoints, initialX, xIncrement));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*  Extended capabilities functions */

/*****************************************************************************
 *  Function: agx2k3k_FetchMinMaxWaveform
 *  Purpose:  This function fetches a min and max waveform from a waveform
 *            acquisition that the user or driver previously initiated on a
 *            specific channel.
 *            Call this function only when AGX2K3K_ATTR_ACQUISTION_TYPE
 *            is AGX2K3K_VAL_PEAK_DETECT or AGX2K3K_VAL_ENVELOPE.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_FetchMinMaxWaveform (ViSession vi,
                                               ViConstString channel,
                                               ViInt32 waveformSize,
                                               ViReal64 minWaveform[],
                                               ViReal64 maxWaveform[],
                                               ViInt32 *actualPoints,
                                               ViReal64 *initialX,
                                               ViReal64 *xIncrement)
{
    ViStatus      error = VI_SUCCESS;
    ViInt32       acquisitionType;
    ViConstString channelName;


    checkErr (Ivi_LockSession (vi, VI_NULL));

    /* Parameter Checking */
    /* Note: Not checking the waveformSize parameter */

    viCheckParm (Ivi_CoerceChannelName (vi, channel, &channelName), 2, "Channel");

    if (minWaveform == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for minWaveform");

    if (maxWaveform == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for maxWaveform");

    if (actualPoints == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 6, "Null address for Actual Points");

    if (initialX == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 7, "Null address for Initial X");

    if (xIncrement == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 8, "Null address for X Increment");

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                       AGX2K3K_ATTR_ACQUISITION_TYPE,
                                       0, &acquisitionType));

    if (acquisitionType != AGX2K3K_VAL_PEAK_DETECT)
    {
        viCheckErrElab (IVI_ERROR_INVALID_CONFIGURATION,
                        "Use Read/FetchMinMaxWaveform only for acquisition types "
                        "Peak Detect or Envelope.");
    }

    /* Fetch Min and Max Waveforms */

    checkErr (agx2k3k_FetchMinMaxWaveformSafe (vi, channelName, waveformSize,
                                               minWaveform, maxWaveform, actualPoints,
                                               initialX, xIncrement));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_FetchWaveformMeasurement
 *  Purpose:  This function fetches a specified waveform measurement
 *            from a specific channel from a previously initiated
 *            waveform acquisition.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_FetchWaveformMeasurement (ViSession vi,
                                                    ViConstString channel,
                                                    ViInt32 measFunction,
                                                    ViReal64 *measurement)
{
    ViStatus      error = VI_SUCCESS;
    ViConstString channelName;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    /* Parameter Checking */
    viCheckParm (Ivi_CoerceChannelName (vi, channel, &channelName), 2, "Channel");

    viCheckParm (Ivi_GetViInt32EntryFromValue (measFunction, &attrMeasFuncRangeTable,
                                               VI_NULL, VI_NULL,
                                               VI_NULL, VI_NULL, VI_NULL, VI_NULL),
                 3, "Measurement Function");

    if (measurement == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for Measurement");

    checkErr (agx2k3k_FetchWaveformMeasurementSafe (vi, channelName,
                                                    measFunction, measurement));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_Abort
 *  Purpose:  This function aborts a previously initiated acquisition.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_Abort (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))                /* call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /* call only when locked */

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

        viCheckErr (viWrite (io, (ViBuf) ":STOP;", 6, VI_NULL));
    }

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_IsInvalidWfmElement
 *  Purpose:  This function takes one of the Waveform Array's element value
 *            that you obtain from the ReadWaveform or FetchWaveform function
 *            and determines if the value is a valid measurement value or a
 *            value indicating that the oscilloscope could not sample a
 *            voltage.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_IsInvalidWfmElement (ViSession vi, ViReal64 elementValue,
                                               ViBoolean *isInvalid)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  type;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (isInvalid == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Is Invalid.");

    viCheckErr (Ivi_GetViReal64Type (elementValue, &type));

    if (type == IVI_VAL_TYPE_NAN)
        *isInvalid = VI_TRUE;
    else
        *isInvalid = VI_FALSE;

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*****************************************************************************
 * Function: agx2k3k_GetAttribute<type> Functions
 * Purpose:  These functions enable the instrument driver user to get
 *           attribute values directly.  There are typesafe versions for
 *           ViInt32, ViReal64, ViString, ViBoolean, and ViSession attributes.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_GetAttributeViInt32 (ViSession vi, ViConstString channelName,
                                               ViAttr attributeId, ViInt32 *value)
{
    return Ivi_GetAttributeViInt32 (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                    value);
}
DllExport ViStatus _VI_FUNC agx2k3k_GetAttributeViReal64 (ViSession vi, ViConstString channelName,
                                                ViAttr attributeId, ViReal64 *value)
{
    return Ivi_GetAttributeViReal64 (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                     value);
}
DllExport ViStatus _VI_FUNC agx2k3k_GetAttributeViString (ViSession vi, ViConstString channelName,
                                                ViAttr attributeId, ViInt32 bufSize,
                                                ViChar value[])
{
    return Ivi_GetAttributeViString (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                     bufSize, value);
}
DllExport ViStatus _VI_FUNC agx2k3k_GetAttributeViBoolean (ViSession vi, ViConstString channelName,
                                                 ViAttr attributeId, ViBoolean *value)
{
    return Ivi_GetAttributeViBoolean (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                      value);
}
DllExport ViStatus _VI_FUNC agx2k3k_GetAttributeViSession (ViSession vi, ViConstString channelName,
                                                 ViAttr attributeId, ViSession *value)
{
    return Ivi_GetAttributeViSession (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                      value);
}

/*****************************************************************************
 * Function: agx2k3k_SetAttribute<type> Functions
 * Purpose:  These functions enable the instrument driver user to set
 *           attribute values directly.  There are typesafe versions for
 *           ViInt32, ViReal64, ViString, ViBoolean, and ViSession datatypes.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_SetAttributeViInt32 (ViSession vi, ViConstString channelName,
                                               ViAttr attributeId, ViInt32 value)
{
    return Ivi_SetAttributeViInt32 (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                    value);
}
DllExport ViStatus _VI_FUNC agx2k3k_SetAttributeViReal64 (ViSession vi, ViConstString channelName,
                                                ViAttr attributeId, ViReal64 value)
{
    return Ivi_SetAttributeViReal64 (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                     value);
}
DllExport ViStatus _VI_FUNC agx2k3k_SetAttributeViString (ViSession vi, ViConstString channelName,
                                                ViAttr attributeId, ViConstString value)
{
    return Ivi_SetAttributeViString (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                     value);
}
DllExport ViStatus _VI_FUNC agx2k3k_SetAttributeViBoolean (ViSession vi, ViConstString channelName,
                                                 ViAttr attributeId, ViBoolean value)
{
    return Ivi_SetAttributeViBoolean (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                      value);
}
DllExport ViStatus _VI_FUNC agx2k3k_SetAttributeViSession (ViSession vi, ViConstString channelName,
                                                 ViAttr attributeId, ViSession value)
{
    return Ivi_SetAttributeViSession (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                      value);
}

/*****************************************************************************
 * Function: agx2k3k_CheckAttribute<type> Functions
 * Purpose:  These functions enable the instrument driver user to check
 *           attribute values directly.  These functions check the value you
 *           specify even if you set the AGX2K3K_ATTR_RANGE_CHECK
 *           attribute to VI_FALSE.  There are typesafe versions for ViInt32,
 *           ViReal64, ViString, ViBoolean, and ViSession datatypes.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_CheckAttributeViInt32 (ViSession vi, ViConstString channelName,
                                                 ViAttr attributeId, ViInt32 value)
{
    return Ivi_CheckAttributeViInt32 (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                      value);
}
DllExport ViStatus _VI_FUNC agx2k3k_CheckAttributeViReal64 (ViSession vi, ViConstString channelName,
                                                  ViAttr attributeId, ViReal64 value)
{
    return Ivi_CheckAttributeViReal64 (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                       value);
}
DllExport ViStatus _VI_FUNC agx2k3k_CheckAttributeViString (ViSession vi, ViConstString channelName,
                                                  ViAttr attributeId, ViConstString value)
{
    return Ivi_CheckAttributeViString (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                       value);
}
DllExport ViStatus _VI_FUNC agx2k3k_CheckAttributeViBoolean (ViSession vi, ViConstString channelName,
                                                   ViAttr attributeId, ViBoolean value)
{
    return Ivi_CheckAttributeViBoolean (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                        value);
}
DllExport ViStatus _VI_FUNC agx2k3k_CheckAttributeViSession (ViSession vi, ViConstString channelName,
                                                   ViAttr attributeId, ViSession value)
{
    return Ivi_CheckAttributeViSession (vi, channelName, attributeId, IVI_VAL_DIRECT_USER_CALL,
                                        value);
}


/*****************************************************************************
 * Function: WriteInstrData and ReadInstrData Functions
 * Purpose:  These functions enable the instrument driver user to
 *           write and read commands directly to and from the instrument.
 *
 *           Notes: 1) These functions bypass the IVI attribute state caching.
 *                  WriteInstrData invalidates the cached values for all
 *                  attributes.
 *                  2) These functions are obsolete since IVI Compliance
 *                  Package (ICP) 4.6.1. You can use agx2k3k_viWrite
 *                  and agx2k3k_viRead instead.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_WriteInstrData (ViSession vi, ViConstString writeBuffer)
{
    return Ivi_WriteInstrData (vi, writeBuffer);
}
DllExport ViStatus _VI_FUNC agx2k3k_ReadInstrData (ViSession vi, ViInt32 numBytes,
                                         ViChar rdBuf[], ViInt32 *bytesRead)
{
    return Ivi_ReadInstrData (vi, numBytes, rdBuf, bytesRead);
}

/*****************************************************************************
 *-------------------- Utility Functions (Not Exported) ---------------------*
 *****************************************************************************/
/*****************************************************************************
 * Function: RemoveSurroundingWhiteSpace
 * Purpose:  This function removes surrounding white space around a string
 *****************************************************************************/
static void RemoveSurroundingWhiteSpace (ViChar string[])
{
    ViChar  *start = string,
    *end;
    ViInt32 lengthWithoutLeadingWS;

    if (start)
    {
        while (*start && isspace ((unsigned char) *start))
            start++;

        lengthWithoutLeadingWS = (ViInt32) strlen (start);
        memmove (string, start, lengthWithoutLeadingWS);
        end = string + lengthWithoutLeadingWS;
        while (end > string && isspace ((unsigned char) *(end - 1)))
            end--;

        *end = '\0';
    }
}

/*****************************************************************************
 *  Function: agx2k3k_GetDriverSetupOption
 *  Purpose:  Get the value of a DriverSetup option. The driver setup string
 *            is part of the option string the user passes to the
 *            agx2k3k_InitWithOptions function. Specifically it is the part
 *            that follows "DriverSetup=". This function assumes the
 *            DriverSetup string has the following format:
 *              "Model : OptionValue"
 *****************************************************************************/
static ViStatus agx2k3k_GetDriverSetupOption (ViSession vi,           /* Session */
                                              ViInt32*    pModelType, /* Returns Model Type */
                                              ViInt32*    pOptions)   /* Returns installed options */
{
    ViStatus error = VI_SUCCESS;
    ViChar   * ptag;
    ViChar   setup[BUFFER_SIZE],
             model_buffer[256];

    /* Initialize output variables */
    *pModelType = UNKNOWN;

    checkErr (Ivi_GetAttributeViString (vi,
                                        VI_NULL,
                                        IVI_ATTR_DRIVER_SETUP,
                                        0, BUFFER_SIZE,
                                        setup));

    if ((ptag = strstr (setup, SETUP_MODEL_TAG)) != VI_NULL)
    {
        sscanf (ptag, "%*[^:]:%256[^;]", model_buffer);
        RemoveSurroundingWhiteSpace (model_buffer);
        if (Ivi_GetValueFromTable (gs_agx2k3k_ModelTable, model_buffer, pModelType) < VI_SUCCESS)
        {
            ViChar message[BUFFER_SIZE];

            sprintf (message, "Bad value for %s option in DriverSetup: %s",
                     SETUP_MODEL_TAG,
                     model_buffer);

            viCheckErrElab (IVI_ERROR_BAD_OPTION_VALUE, message);
        }
    }

Error:
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_GetRecordModeSetupOption
 *  Purpose:  Get the value of the record mode setup option. The record mode setup string
 *            is part of the option string the user passes to the
 *            agx2k3k_InitWithOptions function. Specifically it is the part
 *            that follows "RecordMode=".
 *****************************************************************************/
static ViStatus agx2k3k_GetRecordModeSetupOption (ViSession vi,
                                                  ViInt32*    recordModeSetup)
{
    ViStatus error = VI_SUCCESS;
    ViChar   * ptag;
    ViChar   setup[BUFFER_SIZE],
             recordMode_buffer[256];

    *recordModeSetup = AGX2K3K_VAL_RECORD_NORMAL;
    checkErr (Ivi_GetAttributeViString (vi,
                                        VI_NULL,
                                        AGX2K3K_ATTR_DRIVER_SETUP,
                                        0, BUFFER_SIZE,
                                        setup));

    if ((ptag = strstr (setup, SETUP_RECORD_MODE_TAG)) != VI_NULL)
    {
        sscanf (ptag, "%*[^:]:%256[^;]", recordMode_buffer);
        if (strstr (recordMode_buffer, "RAW"))
        {
            *recordModeSetup = AGX2K3K_VAL_RECORD_RAW;
        }
        else if (strstr (recordMode_buffer, "MAX"))
        {
            *recordModeSetup = AGX2K3K_VAL_RECORD_MAX;
        }
    }

Error:
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_QueryID
 *  Purpose:  Query the instrument for its id string.
 *****************************************************************************/
static ViStatus agx2k3k_QueryID (ViSession vi,
                                 ViSession io,
                                 ViInt32 bufferSize,
                                 ViChar buffer[])
{
    ViStatus error = VI_SUCCESS;
    ViUInt32 readCount;

    viCheckErr (viWrite (io, (ViBuf) "*IDN?", 5, VI_NULL));
    viCheckErr (viRead (io, (ViPBuf) buffer, bufferSize - 1, &readCount));
    buffer[readCount] = '\0';

Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_GetModelFromBuffer
 * Purpose:  This function returns model number from buffer. If table
 *           agx2k3k_ModelTable does not contains this model, function
 *           returns VI_ERROR_FAIL_ID_QUERY;
 *****************************************************************************/
static ViStatus agx2k3k_GetModelFromBuffer (ViSession vi,
                                            ViConstString buffer,
                                            ViInt32*        pModelType)
{
    ViStatus error = VI_SUCCESS;
    ViChar   tmpBuffer[BUFFER_SIZE];

    sscanf (buffer, "%*[^,],%[^,]", tmpBuffer);
    RemoveSurroundingWhiteSpace (tmpBuffer);
    if (Ivi_GetValueFromTable (gs_agx2k3k_ModelTable, tmpBuffer, pModelType) < VI_SUCCESS)
        viCheckErr (VI_ERROR_FAIL_ID_QUERY);

Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_ReadDataUnknownLength
 * Purpose:  This function reads all data from instrument without specified
 *           length.
 *
 *           Note:  Call this function only when the session is locked.
 *                  Use viCheckErr for error checking.
 *****************************************************************************/
static ViStatus agx2k3k_ReadDataUnknownLength (ViSession io,
                                               ViInt32 defaultSize,
                                               void**          pdata,
                                               ViUInt32*       returnCount)
{
    ViStatus error     = VI_SUCCESS;
    ViChar   * pbuffer = VI_NULL;
    ViUInt32 allocated_size,
             readed_bytes = 0;
    ViChar   * pend_buffer;
    ViInt32  alloc_increment = defaultSize;

    *pdata = VI_NULL;
    if (returnCount)
        *returnCount = 0;

    /*
     * Allocate Buffer
     */
    allocated_size = (defaultSize < 1) ? BUFFER_SIZE : defaultSize;
    pbuffer        = (ViChar *) calloc (allocated_size, sizeof (ViChar));
    if (pbuffer == VI_NULL)
        checkErr (VI_ERROR_ALLOC);

    pend_buffer = pbuffer;
    do
    {
        error = viRead (io, (ViPBuf) pend_buffer, alloc_increment, &readed_bytes);
        if (error < VI_SUCCESS)
            checkErr (error);

        /*
         * Buffer was small, reallocate it
         */
        if (readed_bytes == alloc_increment)
        {
            allocated_size += BUFFER_SIZE;
            alloc_increment = BUFFER_SIZE;
            pbuffer         = (ViChar *) realloc (pbuffer, allocated_size);
            if (pbuffer == VI_NULL)
                checkErr (VI_ERROR_ALLOC);
            /*
             * Set pointer to end of data in rallocated buffer
             */
            pend_buffer = pbuffer + (allocated_size - alloc_increment);
        }
        else
        {
            /*
             * For sure set end of string on the end of data
             */
            *(pend_buffer + readed_bytes) = '\0';
        }
    } while (error == 0x3FFF0006); /* if buffer was small, continue with next read */

    *pdata = (void *) pbuffer;

    if (returnCount)
        *returnCount = (allocated_size - alloc_increment) + readed_bytes;

Error:
    if (error < VI_SUCCESS && pbuffer != VI_NULL)
    {
        free (pbuffer);
        *pdata = VI_NULL;
    }
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_FetchWaveformSafe
 *  Purpose:  This function returns the data from the instrument. You must
 *            range-check all parameters and lock the session before calling
 *            this function.
 *****************************************************************************/
static ViStatus agx2k3k_FetchWaveformSafe (ViSession vi, ViConstString channelName,
                                           ViInt32 waveformSize, ViReal64 waveform[],
                                           ViInt32 *actualPoints, ViReal64 *initialX,
                                           ViReal64 *xIncrement)
{
    ViStatus error = VI_SUCCESS;

    if (!Ivi_Simulating (vi))               /* call only when locked */
    {
        checkWarn (agx2k3k_FetchRawWaveform (vi, channelName, 0,
                                             waveformSize,
                                             waveform,
                                             actualPoints,
                                             initialX,
                                             xIncrement));
    }
    else
    {
        ViInt32  x;
        ViReal64 yRange, simOffset;
        ViInt32  triggerSlope, vCoup;
        ViReal64 k, level, theta, offset;

        checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                           AGX2K3K_ATTR_HORZ_RECORD_LENGTH,
                                           0, actualPoints));
        checkErr (Ivi_GetAttributeViReal64 (vi, channelName,
                                            AGX2K3K_ATTR_VERTICAL_RANGE,
                                            0, &yRange));
        checkErr (Ivi_GetAttributeViInt32 (vi, channelName,
                                           AGX2K3K_ATTR_VERTICAL_COUPLING,
                                           0, &vCoup));
        checkErr (Ivi_GetAttributeViReal64 (vi, channelName,
                                            AGX2K3K_ATTR_VERTICAL_OFFSET,
                                            0, &offset));
        checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                           AGX2K3K_ATTR_TRIGGER_SLOPE,
                                           0, &triggerSlope));
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL,
                                            AGX2K3K_ATTR_TRIGGER_LEVEL,
                                            0, &level));
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL,
                                            AGX2K3K_ATTR_HORZ_TIME_PER_RECORD,
                                            0, xIncrement));
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL,
                                            AGX2K3K_ATTR_ACQUISITION_START_TIME,
                                            0, initialX));
        theta = asin (2 * level / yRange);
        if (triggerSlope == AGX2K3K_VAL_POSITIVE)
            k = 1.0;
        else
            k = -1.0;

        if (*actualPoints > waveformSize)
            *actualPoints = waveformSize;  /* Checking number of points to write */
        *xIncrement /= *actualPoints;

        simOffset = (vCoup == AGX2K3K_VAL_DC) ? 0.5 : 0.0;

        for (x = 0; x < *actualPoints; x++)
        {
            ViReal64 y = simOffset + k * 2.5 * sin (*xIncrement * 12560 * x + k * theta) + /*  ~2 periods of 1kHz sinewave */
                         (!(x % 20)) * (16384 - rand ()) / 150000.0;
            waveform[x] = (offset + yRange / 2) > y ? ((offset - yRange / 2) < y ? y : (offset - yRange / 2)) : (offset + yRange / 2);
        }
    }
Error:
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_FetchMinMaxWaveformSafe
 *  Purpose:  This function returns the data from the instrument. You must
 *            range-check all parameters and lock the session before calling
 *            this function.
 *****************************************************************************/
static ViStatus agx2k3k_FetchMinMaxWaveformSafe (ViSession vi, ViConstString channelName,
                                                 ViInt32 waveformSize, ViReal64 minWaveform[],
                                                 ViReal64 maxWaveform[], ViInt32 *actualPoints,
                                                 ViReal64 *initialX, ViReal64 *xIncrement)
{
    ViStatus error = VI_SUCCESS;

    if (!Ivi_Simulating (vi))               /* call only when locked */
    {
        checkWarn (agx2k3k_FetchRawMinMaxWaveformSafe (vi,
                                                       channelName,
                                                       0,
                                                       waveformSize,
                                                       minWaveform,
                                                       maxWaveform,
                                                       actualPoints,
                                                       initialX,
                                                       xIncrement));
    }
    else
    {
        ViInt32  x;
        ViReal64 yRange, k, theta, level;
        ViInt32  triggerSlope;
        checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_HORZ_RECORD_LENGTH,
                                           0, actualPoints));
        checkErr (Ivi_GetAttributeViReal64 (vi, channelName, AGX2K3K_ATTR_VERTICAL_RANGE,
                                            0, &yRange));
        checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_SLOPE,
                                           0, &triggerSlope));
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_LEVEL,
                                            0, &level));
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_HORZ_TIME_PER_RECORD,
                                            0, xIncrement));
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_ACQUISITION_START_TIME,
                                            0, initialX));

        *xIncrement = (*xIncrement) / (*actualPoints);
        theta       = asin (2 * level / yRange);
        if (triggerSlope == AGX2K3K_VAL_POSITIVE)
            k = 1.0;
        else
            k = -1.0;

        *actualPoints /= 4;
        if (*actualPoints > waveformSize)
            *actualPoints = waveformSize;  /* Checking number of points to write */
        *xIncrement *= 4;
        for (x = 0; x < *actualPoints; x++)
        {
            /* add glitch to the every 20th element in the waveform array */
            maxWaveform[x] = k * yRange * .49 * sin (*xIncrement * 12560 * x + k * theta - *initialX)
                             + (!(x % 20)) * rand () / 150000.0;
            minWaveform[x] = k * yRange * .51 * sin (*xIncrement * 12560 * x + k * theta - *initialX)
                             - (!(x % 20)) * rand () / 160000.0;
        }
    }

Error:
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_FetchRawWaveform
 *  Purpose:  This function fetches and returns an unscaled waveform from the
 *            instrument. The waveform can be fetched from an input channels
 *            (CHx), a digital channels (DIGx), or a math channels
 *            (MATHx). To transfer less data than the horizontal record
 *            length, set the arraySize element in the waveformData parameter
 *            to the desired amount. This may be desired if Extended
 *            Acqusition mode is enabled, but you do not want to transfer
 *            that much data.
 *
 *  Note:  Call this function only when the session is locked and NOT Simulating.
 *****************************************************************************/
#define FORMAT_DATA(dType) \
    { \
        dType* pdata = (dType *) (((char *) pbuffer) + header_length); \
        for (i = 0; i < stop_index; i++) { \
            *pwaveform++ = (*pdata++ - yreference) * yincrement + yorigin; \
        } \
    }

static ViStatus agx2k3k_FetchRawWaveform (ViSession vi,
                                          ViConstString dataSource,
                                          ViInt32 segmentNumber,
                                          ViInt32 waveformSize,
                                          ViReal64 waveform[],
                                          ViInt32*        actualPoints,
                                          ViReal64*       initialX,
                                          ViReal64*       xIncrement)
{
    ViStatus error        = VI_SUCCESS;
    ViStatus second_error = VI_SUCCESS;
    ViInt32  number_of_points,
             yreference;
    ViInt32  stop_index = 0;
    ViInt32  i;
    void     * pbuffer = VI_NULL;
    ViReal64 x_inc     = 0,
             yincrement,
             yorigin;
    ViSession     io      = Ivi_IOSession (vi);
    ViInt16       test_nb = 0;
    ViConstString pbyte_order_string;
    ViString      dataSourceTemp = VI_NULL;


    /*- Set Data Source */
    if (strcmp (dataSource, "DIG0") == 0 || strcmp (dataSource, "DIG1") == 0 ||
        strcmp (dataSource, "DIG2") == 0 || strcmp (dataSource, "DIG3") == 0 ||
        strcmp (dataSource, "DIG4") == 0 || strcmp (dataSource, "DIG5") == 0 ||
        strcmp (dataSource, "DIG6") == 0 || strcmp (dataSource, "DIG7") == 0)
        dataSourceTemp = "POD1";
    if (strcmp (dataSource, "DIG8") == 0 || strcmp (dataSource, "DIG9") == 0 ||
        strcmp (dataSource, "DIG10") == 0 || strcmp (dataSource, "DIG11") == 0 ||
        strcmp (dataSource, "DIG12") == 0 || strcmp (dataSource, "DIG13") == 0 ||
        strcmp (dataSource, "DIG14") == 0 || strcmp (dataSource, "DIG15") == 0)
        dataSourceTemp = "POD2";

    checkErr (Ivi_SetAttributeViString (vi, VI_NULL,
                                        AGX2K3K_ATTR_INSTR_DATA_SOURCE,
                                        0, (dataSourceTemp != VI_NULL) ? dataSourceTemp : dataSource));

    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        /*
         * Set byte ordering
         */
        *((char *) &test_nb) = 1;
        if (test_nb == 1)
            pbyte_order_string = "LSBF";
        else
            pbyte_order_string = "MSBF";

        viCheckErr (viPrintf (io, ":WAV:BYT %s", pbyte_order_string));

        /*
         * Set waveform data
         */
        viCheckErr (viPrintf (io, ":WAV:FORM BYTE"));

        /*
         * Set required block of memory.
         */
        checkErr (Ivi_GetAttributeViInt32 (vi,
                                           VI_NULL,
                                           AGX2K3K_ATTR_HORZ_RECORD_LENGTH,
                                           0, &number_of_points));

        stop_index = (number_of_points > waveformSize) ? waveformSize : number_of_points;

        /*
         * Get Waveform Attributes
         */
        viCheckErr (viQueryf (io, ":WAV:YREF?;:WAV:YINC?;:WAV:YOR?;:WAV:XINC?",
                              "%ld;%Le;%Le;%Le",
                              &yreference, &yincrement, &yorigin, &x_inc));


        if (waveform)
        {
            ViUInt32 nb_of_bytes;
            ViReal64 * pwaveform = waveform;
            ViInt32  header_length;

            if (!Ivi_Simulating (vi))
            {
                /* Waveform Query */
                viCheckErr (viPrintf (io, ":WAV:DATA?"));
            }
            /* Read all data buffer at once  */
            viCheckErr (agx2k3k_ReadDataUnknownLength (io,
                                                       (stop_index + HEADER_SIZE),
                                                       &pbuffer,
                                                       &nb_of_bytes));
            /* skip header  */
            sscanf ((const char *) pbuffer, "#%1ld", &header_length);
            header_length += 2;

            FORMAT_DATA (ViByte)
        }

        viCheckWarn (second_error);

        if (initialX)
        {
            ViBoolean isFFT = VI_FALSE;

            checkWarn (agx2k3k_IsFFT (vi, dataSource, &isFFT));

            if (isFFT)
                *initialX = 0.0;
            else
                checkWarn (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_ACQUISITION_START_TIME, 0, initialX));
        }
    }

    if (error == VI_SUCCESS) /* AGX2K3K_WARN_INVALID_WFM_ELEMENT */
        error = second_error;

Error:
    if (pbuffer)
        free (pbuffer);
    if (actualPoints)
        *actualPoints = (error < VI_SUCCESS) ? 0 : stop_index;
    if (xIncrement)
        *xIncrement = x_inc;

    return error;
}

/*****************************************************************************
 * Function: agx2k3k_FetchRawMinMaxWaveformSafe
 * Purpose:  This function fetches and returns an unscaled waveform from the
 *           instrument. The waveform can be fetched from an input channel
 *           (CH1-CH4). To transfer less data than the horizontal record
 *           length, set the arraySize element in the waveformData parameter
 *           to the desired amount. This may be desired if Extended
 *           Acqusition mode is enabled, but you do not want to transfer
 *           that much data.
 *           NOTE: Call this only when AGX2K3K_ATTR_ACQUISITION_TYPE is
 *           AGX2K3K_VAL_PEAK_DETECT
 *           NOTE: Call this only when NOT Simulating.
 *****************************************************************************/
#define FORMAT_MINMAX_DATA(dType) \
    { \
        dType* pdata = (dType *) (((char *) pbuffer) + header_length); \
        for (i = 0; i < stop_index; i++) { \
            *pmin_waveform++ = (*pdata++ - yreference) * yincrement + yorigin; \
            *pmax_waveform++ = (*pdata++ - yreference) * yincrement + yorigin; \
        } \
    }

static ViStatus agx2k3k_FetchRawMinMaxWaveformSafe (ViSession vi,
                                                    ViConstString dataSource,
                                                    ViInt32 segmentNumber,
                                                    ViInt32 waveformSize,
                                                    ViReal64 minWaveform[],
                                                    ViReal64 maxWaveform[],
                                                    ViInt32*        actualPoints,
                                                    ViReal64*       initialX,
                                                    ViReal64*       xIncrement)
{
    ViStatus error        = VI_SUCCESS;
    ViStatus second_error = VI_SUCCESS;
    ViInt32  number_of_points,
             yreference;
    ViInt32  stop_index = 0;
    ViInt32  i;
    void     * pbuffer = VI_NULL;
    ViReal64 x_inc     = 0,
             yincrement,
             yorigin;
    ViSession     io      = Ivi_IOSession (vi);
    ViInt16       test_nb = 0;
    ViConstString pbyte_order_string;
    ViString      dataSourceTemp = VI_NULL;

    /*- Set Data Source */
    if (strcmp (dataSource, "DIG0") == 0 || strcmp (dataSource, "DIG1") == 0 ||
        strcmp (dataSource, "DIG2") == 0 || strcmp (dataSource, "DIG3") == 0 ||
        strcmp (dataSource, "DIG4") == 0 || strcmp (dataSource, "DIG5") == 0 ||
        strcmp (dataSource, "DIG6") == 0 || strcmp (dataSource, "DIG7") == 0)
        dataSourceTemp = "POD1";
    if (strcmp (dataSource, "DIG8") == 0 || strcmp (dataSource, "DIG9") == 0 ||
        strcmp (dataSource, "DIG10") == 0 || strcmp (dataSource, "DIG11") == 0 ||
        strcmp (dataSource, "DIG12") == 0 || strcmp (dataSource, "DIG13") == 0 ||
        strcmp (dataSource, "DIG14") == 0 || strcmp (dataSource, "DIG15") == 0)
        dataSourceTemp = "POD2";

    checkErr (Ivi_SetAttributeViString (vi, VI_NULL,
                                        AGX2K3K_ATTR_INSTR_DATA_SOURCE,
                                        0, (dataSourceTemp != VI_NULL) ? dataSourceTemp : dataSource));

    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        /*
         * Set byte ordering
         */
        *((char *) &test_nb) = 1;
        if (test_nb == 1)
            pbyte_order_string = "LSBF";
        else
            pbyte_order_string = "MSBF";
        viCheckErr (viPrintf (io, "WAV:BYT %s", pbyte_order_string));

        /*
         * Set waveform data
         */
        viCheckErr (viPrintf (io, ":WAV:FORM BYTE"));

        /*
         * Set required block of memory.
         */
        checkErr (Ivi_GetAttributeViInt32 (vi,
                                           VI_NULL,
                                           AGX2K3K_ATTR_HORZ_RECORD_LENGTH,
                                           0, &number_of_points));

        stop_index = 2 * ((number_of_points > waveformSize) ? waveformSize : number_of_points);

        /*
         * Get Waveform Attributes
         */
        viCheckErr (viQueryf (io, ":WAV:YREF?;:WAV:YINC?;:WAV:YOR?;:WAV:XINC?",
                              "%ld;%Le;%Le;%Le",
                              &yreference, &yincrement, &yorigin, &x_inc));


        if (minWaveform && maxWaveform)
        {
            ViUInt32 nb_of_bytes;
            ViInt32  header_length;
            ViReal64 * pmin_waveform = minWaveform;
            ViReal64 * pmax_waveform = maxWaveform;

            if (!Ivi_Simulating (vi))
            {
                /* Waveform Query */
                viCheckErr (viPrintf (io, ":WAV:DATA?"));
            }

            /* Read all data buffer at once  */
            viCheckErr (agx2k3k_ReadDataUnknownLength (io,
                                                       (stop_index + HEADER_SIZE),
                                                       &pbuffer,
                                                       &nb_of_bytes));

            /* skip header  */
            sscanf ((const char *) pbuffer, "#%1ld", &header_length);
            header_length += 2;

            stop_index  /= 2;
            nb_of_bytes -= header_length;
            if (stop_index > (ViInt32) (nb_of_bytes / 2))
                stop_index = nb_of_bytes / 2;

            FORMAT_MINMAX_DATA (ViByte)
        }

        viCheckWarn (second_error);

        if (initialX)
        {
            ViBoolean isFFT = VI_FALSE;

            checkWarn (agx2k3k_IsFFT (vi, dataSource, &isFFT));

            if (isFFT)
                *initialX = 0.0;
            else
                checkWarn (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_ACQUISITION_START_TIME, 0, initialX));
        }
    }

    if (error == VI_SUCCESS) /* AGX2K3K_WARN_INVALID_WFM_ELEMENT */
        error = second_error;

Error:
    if (pbuffer)
        free (pbuffer);
    if (actualPoints)
        *actualPoints = (error < VI_SUCCESS) ? 0 : stop_index;
    if (xIncrement)
        *xIncrement = x_inc * 2.0;
    return error;
}


/*****************************************************************************
 *  Function: agx2k3k_IsFFT
 *  Purpose:  This function returns VI_TRUE if the specified math channel
 *            FFT function,
 *****************************************************************************/
static ViStatus agx2k3k_IsFFT (ViSession vi,
                               ViConstString dataSource,
                               ViBoolean*      pIsFFT)
{
    ViStatus  error  = VI_SUCCESS;
    ViBoolean is_fft = VI_FALSE;
    ViInt32   mathOperation;

    if (pIsFFT == VI_NULL)
    {
        return IVI_ERROR_NULL_POINTER;
    }

    if (strstr (dataSource, "FUNC"))
    {
        checkErr (Ivi_GetAttributeViInt32 (vi,
                                           VI_NULL,
                                           AGX2K3K_ATTR_MATH_OPERATION,
                                           0,
                                           &mathOperation));

        if (mathOperation == AGX2K3K_VAL_MATH_OPERATION_FFT)
            is_fft = VI_TRUE;
    }

Error:
    if (pIsFFT)
        *pIsFFT = is_fft;
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_FetchWaveformMeasurementSafe
 *  Purpose:  This function returns the data from the instrument. You must
 *            range-check all parameters and lock the session before calling
 *            this function.
 *****************************************************************************/
static ViStatus agx2k3k_FetchWaveformMeasurementSafe (ViSession vi,
                                                      ViConstString channelName,
                                                      ViInt32 measFunction,
                                                      ViReal64 *measurement)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    viCheckParm (Ivi_GetViInt32EntryFromValue (measFunction, &attrMeasFuncRangeTable,
                                               VI_NULL, VI_NULL,
                                               VI_NULL, VI_NULL, &cmd, VI_NULL),
                 3, "Measurement Function");
    if (!Ivi_Simulating (vi))               /* call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);  /* call only when locked */

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

        viCheckErr (viQueryf (io, ":MEAS:%s? %s", "%Le", cmd, channelName, measurement));
    }
    else
    {
        ViReal64 range;
        ViReal64 time_range;

        checkErr (Ivi_GetAttributeViReal64 (vi, channelName,
                                            AGX2K3K_ATTR_VERTICAL_RANGE,
                                            0, &range));

        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL,
                                            AGX2K3K_ATTR_HORZ_TIME_PER_RECORD,
                                            0, &time_range));

        switch (measFunction)
        {
        case AGX2K3K_VAL_RISE_TIME:
        case AGX2K3K_VAL_FALL_TIME:
            *measurement = 2e-6;
            break;

        case AGX2K3K_VAL_COUNTER:
        case AGX2K3K_VAL_FREQUENCY:
            *measurement = rand () / 10.0 + 10000.0;
            break;

        case AGX2K3K_VAL_PERIOD:
            *measurement = 1.0 / (rand () / 10.0 + 10000.0);
            break;

        case AGX2K3K_VAL_VOLTAGE_RMS:
            *measurement = range * .3535;
            break;

        case AGX2K3K_VAL_VOLTAGE_PEAK_TO_PEAK:
            *measurement = range;
            break;

        case AGX2K3K_VAL_VOLTAGE_MAX:
        case AGX2K3K_VAL_VOLTAGE_HIGH:
            *measurement = (1 - rand () / 120000.0) * range / 2;
            break;

        case AGX2K3K_VAL_VOLTAGE_LOW:
        case AGX2K3K_VAL_VOLTAGE_MIN:
            *measurement = (rand () / 120000.0 - 1) * range / 2;
            break;

        case AGX2K3K_VAL_VOLTAGE_AVERAGE:
            *measurement = 0;
            break;

        case AGX2K3K_VAL_WIDTH_NEG:
        case AGX2K3K_VAL_WIDTH_POS:
            *measurement = 1e-4 * rand () / 30000.0;
            break;

        case AGX2K3K_VAL_DUTY_CYCLE_POS:
            *measurement = 70.0;
            break;

        case AGX2K3K_VAL_AMPLITUDE:
            *measurement = range * .49;
            break;

        case AGX2K3K_VAL_OVERSHOOT:
            *measurement = 23.3;
            break;

        case AGX2K3K_VAL_PRESHOOT:
            *measurement = 4.66;
            break;

        case AGX2K3K_VAL_DELAY:
            *measurement = (time_range / 4.0 * 0.985);
            break;

        case AGX2K3K_VAL_PHASE:
            *measurement = (time_range / 4.0 * 0.885);
            break;

        case AGX2K3K_VAL_X_AT_MAX:
        case AGX2K3K_VAL_X_AT_MIN:
            *measurement = -1.0 / (rand () / 10.0 + 10000.0);
            break;

        case AGX2K3K_VAL_BURST_WIDTH:
        case AGX2K3K_VAL_NEGATIVE_EDGE:
        case AGX2K3K_VAL_NEGATIVE_PULSE:
        case AGX2K3K_VAL_POSITIVE_EDGE:
        case AGX2K3K_VAL_POSITIVE_PULSE:
            *measurement = 0.001;
            break;

        case AGX2K3K_VAL_BIT_RATE:
            *measurement = 9.9000E+37;
            break;

        case AGX2K3K_VAL_NEGATIVE_DUTY:
        case AGX2K3K_VAL_RDS_ON:
        case AGX2K3K_VAL_VCE_SAT:
        case AGX2K3K_VAL_DUAL_CHARGE:
        case AGX2K3K_VAL_DUAL_VERTICAL_AMPLITUDE:
        case AGX2K3K_VAL_DUAL_AVERAGE_VALUE:
        case AGX2K3K_VAL_DUAL_WAVEFORM_BASE_VALUE:
        case AGX2K3K_VAL_DUAL_VERTICAL_PEAK_TO_PEAK:
        case AGX2K3K_VAL_DUAL_VRMS:
            *measurement = 0.001;
            break;
        }
    }

Error:
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_GetProbeAttenuation
 *  Purpose:  This function always returns the actual probe attenuation.
 *****************************************************************************/
static ViStatus agx2k3k_GetProbeAttenuation (ViSession vi,
                                             ViConstString channelName,
                                             ViReal64* pValue)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_GetAttributeViReal64 (vi,
                                        channelName,
                                        AGX2K3K_ATTR_PROBE_SENSE_VALUE,
                                        0, pValue));

Error:
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_GetStr1PtrFromStr2
 *  Purpose:  This function searches the string/string table the driver
 *            defines with the agx2k3kStringTable type.
 *            Use this function when you know the string in the second table
 *            column. Function returns the pointer to the corresponding string
 *            in the first column.
 *****************************************************************************/
static ViStatus agx2k3k_GetStr1PtrFromStr2 (ViSession vi, agx2k3kStringTable strTable,
                                            ViConstString *str1, ViConstString str2)
{
    ViStatus  error = VI_SUCCESS;
    ViInt32   i     = 0;
    ViBoolean found = VI_FALSE;

    *str1 = VI_NULL;
    while (!found && strTable[i].col1)
    {
        if (strcmp (strTable[i].col2, str2) == 0)
        {
            *str1 = strTable[i].col1;
            found = VI_TRUE;
        }
        i++;
    }
    if (!found)
        error = IVI_ERROR_INVALID_VALUE;

    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_GetStr2BufFromStr1
 *  Purpose:  This function searches the string/string table the driver
 *            defines with the agx2k3kStringTable type.
 *            Use this function when you know the string in the first table
 *            column. Function fills the buffer you pass as the str2 parameter
 *            with the contents of the respective second column.
 *****************************************************************************/
static ViStatus agx2k3k_GetStr2BufFromStr1 (ViSession vi, agx2k3kStringTable strTable,
                                            ViConstString str1, ViConstString* str2)
{
    ViStatus  error = VI_SUCCESS;
    ViInt32   i     = 0;
    ViBoolean found = VI_FALSE;

    if (str2)
        *str2 = VI_NULL;

    while (!found && strTable[i].col1)
    {
        if (strcmp (strTable[i].col1, str1) == 0)
        {
            if (str2)
                *str2 = strTable[i].col2;
            found = VI_TRUE;
        }
        i++;
    }
    if (!found)
        error = IVI_ERROR_INVALID_VALUE;

    return error;
}


/*****************************************************************************
 * Function: agx2k3k_CheckStatus
 * Purpose:  This function checks the status of the instrument to detect
 *           whether the instrument has encountered an error.  This function
 *           is called at the end of most exported driver functions.  If the
 *           instrument reports an error, this function returns
 *           IVI_ERROR_INSTRUMENT_SPECIFIC.  The user can set the
 *           AGX2K3K_ATTR_QUERY_INSTRUMENT_STATUS attribute to VI_FALSE to disable this
 *           check and increase execution speed.
 *
 *           Note:  Call this function only when the session is locked.
 *****************************************************************************/
static ViStatus agx2k3k_CheckStatus (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    if (Ivi_QueryInstrStatus (vi) && Ivi_NeedToCheckStatus (vi) && !Ivi_Simulating (vi))
    {
        checkErr (agx2k3k_CheckStatusCallback (vi, Ivi_IOSession (vi)));
        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_FALSE));
    }

Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_WaitForOPC
 * Purpose:  This function waits for the instrument to complete the
 *           execution of all pending operations.  This function is a
 *           wrapper for the WaitForOPCCallback.  It can be called from
 *           other instrument driver functions.
 *
 *           The maxTime parameter specifies the maximum time to wait for
 *           operation complete in milliseconds.
 *
 *           Note:  Call this function only when the session is locked.
 *****************************************************************************/
static ViStatus agx2k3k_WaitForOPC (ViSession vi, ViInt32 maxTime)
{
    ViStatus error = VI_SUCCESS;

    if (!Ivi_Simulating (vi))
    {
        ViInt32 oldOPCTimeout;

        checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_OPC_TIMEOUT,
                                           0, &oldOPCTimeout));
        Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_OPC_TIMEOUT,
                                 0, maxTime);

        error = agx2k3k_WaitForOPCCallback (vi, Ivi_IOSession (vi));

        Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_OPC_TIMEOUT,
                                 0, oldOPCTimeout);
        viCheckErr (error);
    }
Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_DefaultInstrSetup
 * Purpose:  This function sends a default setup to the instrument.  The
 *           agx2k3k_reset function calls this function.  The
 *           agx2k3k_IviInit function calls this function when the
 *           user passes VI_FALSE for the reset parameter.  This function is
 *           useful for configuring settings that other instrument driver
 *           functions require.
 *
 *           Note:  Call this function only when the session is locked.
 *****************************************************************************/
static ViStatus agx2k3k_DefaultInstrSetup (ViSession vi)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  recordMode;
    ViInt32  modelType = 0;

    /* Invalidate all attributes */
    checkErr (Ivi_InvalidateAllAttributes (vi));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);  /* call only when locked */

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

        viCheckErr (viPrintf (io, "*CLS;*ESE 1;*SRE 32"));
    }

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MODEL_TYPE, 0, &modelType));

    if (modelType == MSOX2024A)
    {
        checkErr (Ivi_SetAttributeViInt32 (vi,
                                           VI_NULL,
                                           AGX2K3K_ATTR_TRIGGER_MODIFIER,
                                           IVI_VAL_DONT_MARK_AS_SET_BY_USER,
                                           AGX2K3K_VAL_AUTO));
    }
    else
    {
        checkErr (Ivi_SetAttributeViInt32 (vi,
                                           VI_NULL,
                                           AGX2K3K_ATTR_TRIGGER_MODIFIER,
                                           IVI_VAL_DONT_MARK_AS_SET_BY_USER,
                                           AGX2K3K_VAL_NO_TRIGGER_MOD));
    }

    checkErr (agx2k3k_GetRecordModeSetupOption (vi,
                                                &recordMode));
    checkErr (Ivi_SetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_HORZ_RECORD_MODE,
                                       IVI_VAL_DONT_MARK_AS_SET_BY_USER,
                                       recordMode));

    checkErr (Ivi_SetAttributeViBoolean (vi,
                                         VI_NULL,
                                         AGX2K3K_ATTR_INITIATE_CONTINUOUS,
                                         IVI_VAL_DONT_MARK_AS_SET_BY_USER,
                                         VI_FALSE));

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    return error;
}

/* functions added in version 3.2 */

/*******************************************************************************
 * Function:  agx2k3k_ConfigureChannelBandwidth
 * Purpose:   Configures bandwidth limiting for an analog input channel.
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureChannelBandwidth (ViSession vi, ViChar channelName[], ViReal64 bandwidth)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViReal64 (vi, channelName, AGX2K3K_ATTR_CHANNEL_BANDWIDTH,
                                           0, bandwidth), 3, "bandwidth");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureClockRecoveryFixed
 * Purpose:   Configures the clock recovery method. The clock is assumed to be a constant frequency.
 *
 *            SCPI Command:
 *            :CLOCk:METHod <method>
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureClockRecoveryFixed (ViSession vi, ViInt32 option, ViReal64 dataRate)
{
    ViStatus error = VI_SUCCESS;
    ViChar   cmdStr[BUFFER_SIZE];

    checkErr (Ivi_LockSession (vi, VI_NULL));

    switch (option)
    {
    case AGX2K3K_VAL_FIXED_AUTO:
        sprintf (cmdStr, "%s", ":CLOC:METH FIX,AUTO");
        break;

    case AGX2K3K_VAL_FIXED_SEMI:
        sprintf (cmdStr, ":CLOC:METH FIX,SEMI,%g", dataRate);
        break;

    case AGX2K3K_VAL_FIXED_DATARATE:
        sprintf (cmdStr, ":CLOC:METH FIX,%g", dataRate);
        break;

    default:
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "option");
    }

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viPrintf (io, cmdStr));
    }

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureClockRecoveryFOPLL
 * Purpose:   Configures the clock recovery method. With First Order PLL, the clock is recovered using the DSP-modeled response of an ideal first-order hardware PLL.
 *
 *            SCPI Command:
 *            :CLOCk:METHod <method>
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureClockRecoveryFOPLL (ViSession vi, ViReal64 dataRate, ViReal64 loopBandwidth)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viPrintf (io, ":CLOC:METH FOPL,%g,%g", dataRate, loopBandwidth));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureClockRecoverySOPLL
 * Purpose:   Configures the clock recovery method. With Second Order PLL, the clock is recovered using the DSP-modeled response of an ideal Type II, second-order hardware PLL.
 *
 *            SCPI Command:
 *            :CLOCk:METHod <method>
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureClockRecoverySOPLL (ViSession vi, ViReal64 dataRate, ViReal64 loopBandwidth,
                                                       ViReal64 dampingFactor)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viPrintf (io, ":CLOC:METH SOPL,%g,%g,%g", dataRate, loopBandwidth, dampingFactor));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureClockRecoveryExplicit
 * Purpose:   Configures the clock recovery method. The clock is recovered from a second signal in the device under test.
 *
 *            SCPI Command:
 *            :CLOCk:METHod <method>
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureClockRecoveryExplicit (ViSession vi, ViConstString source, ViInt32 direction,
                                                          ViInt32 multiplier)
{
    ViStatus error  = VI_SUCCESS;
    ViString dirStr = "";

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_GetViInt32EntryFromValue (direction, &funcDirectionRangeTable,
                                               VI_NULL, VI_NULL, VI_NULL, VI_NULL, &dirStr, VI_NULL), 3, "direction");
    if (multiplier > 1000 || multiplier < 1)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "multiplier");

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viPrintf (io, ":CLOC:METH EXPL,%s,%s,%d", source, dirStr, multiplier));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureHistogram
 * Purpose:   Configures histogram mode.
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureHistogram (ViSession vi, ViInt32 mode)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_HISTOGRAM_MODE,
                                          0, mode), 2, "mode");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureHistogramMeasurement
 * Purpose:   Configures the measurement slot to analyze when the histogram mode is measurement.
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureHistogramMeasurement (ViSession vi, ViInt32 measurement)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_HISTOGRAM_MEASUREMENT,
                                          0, measurement), 2, "measurement");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureHistogramWaveform
 * Purpose:   Configures the histogram when the histogram mode is measurement.
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureHistogramWaveform (ViSession vi, ViInt32 axis, ViReal64 leftLimit,
                                                      ViReal64 rightLimit, ViReal64 topLimit, ViReal64 bottomLimit,
                                                      ViConstString source)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_HISTOGRAM_AXIS,
                                          0, axis), 2, "axis");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_HISTOGRAM_WINDOW_LLIMIT,
                                           0, leftLimit), 3, "left Limit");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_HISTOGRAM_WINDOW_RLIMIT,
                                           0, rightLimit), 4, "right Limit");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_HISTOGRAM_WINDOW_TLIMIT,
                                           0, topLimit), 5, "top Limit");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_HISTOGRAM_WINDOW_BLIMIT,
                                           0, bottomLimit), 6, "bottom Limit");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_HISTOGRAM_WINDOW_SOURCE,
                                           0, source), 7, "source");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ResetHistogramCounters
 * Purpose:   Zeros the histogram counters.
 *
 *            SCPI Command:
 *            :HISTogram:RESet
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ResetHistogramCounters (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viPrintf (io, ":HIST:RES"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ApplyJitterHistogram
 * Purpose:   Auto-configures and turns on the jitter measurement histogram for the selected measurement.
 *
 *            SCPI Command:
 *            :JITTer:HISTogram:APPLy
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyJitterHistogram (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viPrintf (io, ":JITT:HIST:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ApplyJitterSpectrum
 * Purpose:   Auto-configures and turns on the jitter spectrum for the selected measurement.
 *
 *            SCPI Command:
 *            :JITTer:SPECtrum:APPLy
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyJitterSpectrum (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viPrintf (io, ":JITT:SPEC:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureJitterMeasurement
 * Purpose:   Configures the measurement to jitter analyze.
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureJitterMeasurement (ViSession vi, ViInt32 measurement)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_JITTER_MEASUREMENT,
                                          0, measurement), 2, "measurement");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureJitterAnalysisEnabled
 * Purpose:   Configures whether the jitter analysis is enabled or not.
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureJitterAnalysisEnabled (ViSession vi, ViBoolean enabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_JITTER_ENABLE,
                                            0, enabled), 2, "enabled");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ApplyJitterTrend
 * Purpose:   Auto-configures and turns on the jitter measurement trend for the selected measurement.
 *
 *            SCPI Command:
 *            :JITTer:TRENd:APPLy
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyJitterTrend (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viPrintf (io, ":JITT:TREN:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ApplyJitterTrendSmooth
 * Purpose:   Auto-configures and turns on smoothing for the jitter measurement trend.
 *
 *            SCPI Command:
 *            :JITTer:TRENd:APPLy
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyJitterTrendSmooth (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viPrintf (io, ":JITT:TREN:SMO:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ReadNCycleToNCycleJitter
 * Purpose:   Measures the N-Cycle to N-Cycle jitter.
 *
 *            SCPI Command:
 *            :MEASure:NCJitter
 *
 *            Note:
 *            This function is available when the optional DSOX6JITTER jitter analysis feature is licensed.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadNCycleToNCycleJitter (ViSession vi, ViConstString source, ViInt32 direction,
                                                    ViInt32 numPeriods, ViReal64* jitter)
{
    ViStatus error = VI_SUCCESS;
    ViString dirStr;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_GetViInt32EntryFromValue (direction, &funcNPeriodDirectionRangeTable,
                                               VI_NULL, VI_NULL, VI_NULL, VI_NULL, &dirStr, VI_NULL), 3, "direction");
    if (numPeriods > 10000 || numPeriods < 1)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for numPeriods");
    if (jitter == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for jitter");

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viQueryf (io, ":MEAS:NCJ? %s,%s,%d", "%lg", source, dirStr, numPeriods, jitter));
    }
    else
        *jitter = 299792458;

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadNPeriodJitter
 * Purpose:   Measures the N-Period jitter.
 *
 *            SCPI Command:
 *            :MEASure:NPERiod
 *
 *            Note:
 *            This function is available when the optional DSOX6JITTER jitter analysis feature is licensed.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadNPeriodJitter (ViSession vi, ViConstString source, ViInt32 slope,
                                             ViInt32 numPeriods, ViReal64* jitter)
{
    ViStatus error    = VI_SUCCESS;
    ViString slopeStr = "";

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_GetViInt32EntryFromValue (slope, &funcNPeriodDirectionRangeTable,
                                               VI_NULL, VI_NULL, VI_NULL, VI_NULL, &slopeStr, VI_NULL), 3, "direction");
    if (numPeriods > 10000 || numPeriods < 1)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "numPeriods");
    if (jitter == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for jitter");

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viQueryf (io, ":MEAS:NPER? %s,%s,%d", "%lg", source, slopeStr, numPeriods, jitter));
    }
    else
        *jitter = 299792458;

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadDataTIEJitter
 * Purpose:   Measures the Data Time Interval Error (TIE) jitter.
 *
 *            SCPI Command:
 *            :MEASure:TIEData
 *
 *            Note:
 *            This function is available when the optional DSOX6JITTER jitter analysis feature is licensed.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadDataTIEJitter (ViSession vi, ViConstString source, ViInt32 unit,
                                             ViReal64* jitter)
{
    ViStatus error   = VI_SUCCESS;
    ViString unitStr = "";

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_GetViInt32EntryFromValue (unit, &funcTIEUnitRangeTable,
                                               VI_NULL, VI_NULL, VI_NULL, VI_NULL, &unitStr, VI_NULL), 3, "unit");
    if (jitter == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for jitter");

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viQueryf (io, ":MEAS:TIED? %s,%s", "%lg", source, unitStr, jitter));
    }
    else
        *jitter = 299792458;

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadClockTIEJitter
 * Purpose:   Measures the clock Time Interval Error (TIE) jitter.
 *
 *            SCPI Command:
 *            :MEASure:TIEClock
 *
 *            Note:
 *            This function is available when the optional DSOX6JITTER jitter analysis feature is licensed.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadClockTIEJitter (ViSession vi, ViConstString source, ViInt32 unit,
                                              ViInt32 direction, ViReal64* jitter)
{
    ViStatus error   = VI_SUCCESS;
    ViString unitStr = "";
    ViString dirStr  = "";

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_GetViInt32EntryFromValue (unit, &funcTIEUnitRangeTable,
                                               VI_NULL, VI_NULL, VI_NULL, VI_NULL, &unitStr, VI_NULL), 3, "unit");
    viCheckParm (Ivi_GetViInt32EntryFromValue (direction, &funcDirectionRangeTable,
                                               VI_NULL, VI_NULL, VI_NULL, VI_NULL, &dirStr, VI_NULL), 4, "direction");
    if (jitter == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Null address for jitter");

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viQueryf (io, ":MEAS:TIEC? %s,%s,%s", "%lg", source, unitStr, dirStr, jitter));
    }
    else
        *jitter = 299792458;

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadHistogramMeasurement
 * Purpose:   Measures various properties of the histogram.
 *
 *            SCPI Command:
 *            :MEASure:HISTogram:BWIDth
 *            :MEASure:HISTogram:HITS
 *            :MEASure:HISTogram:M1S
 *            :MEASure:HISTogram:M2S
 *            :MEASure:HISTogram:M3S
 *            :MEASure:HISTogram:MAXimum
 *            :MEASure:HISTogram:MEAN
 *            :MEASure:HISTogram:MEDian
 *            :MEASure:HISTogram:MINimum
 *            :MEASure:HISTogram:MODE
 *            :MEASure:HISTogram:PEAK
 *            :MEASure:HISTogram:PPEak
 *            :MEASure:HISTogram:SDEViation
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadHistogramMeasurement (ViSession vi, ViInt32 measurement, ViReal64* value)
{
    ViStatus error  = VI_SUCCESS;
    ViString cmdStr = "";

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_GetViInt32EntryFromValue (measurement, &funcHistogramMeasureRangeTable,
                                               VI_NULL, VI_NULL, VI_NULL, VI_NULL, &cmdStr, VI_NULL), 2, "measurement");
    if (value == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for value");

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viQueryf (io, ":MEAS:HIST:%s?", "%lg", cmdStr, value));
    }
    else
        *value = 299792458;

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadRTEyeMeasurement
 * Purpose:   Measures the height or width of the real-time eye diagram.
 *
 *            SCPI Command:
 *            :MEASure:RTEYe:EHEight
 *            :MEASure:RTEYe:EWIDth
 *
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadRTEyeMeasurement (ViSession vi, ViInt32 measurement, ViReal64* value)
{
    ViStatus error  = VI_SUCCESS;
    ViString cmdStr = "";

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_GetViInt32EntryFromValue (measurement, &funcRTEMeasurementRangeTable,
                                               VI_NULL, VI_NULL, VI_NULL, VI_NULL, &cmdStr, VI_NULL), 2, "measurement");
    if (value == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for value");

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viQueryf (io, "%s?", "%lg", cmdStr, value));
    }
    else
        *value = 299792458;

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ReadCycleToCycleWidth
 * Purpose:   This function measures the cycle to cycle positive/negative width.
 *
 *            Note:
 *            This function is available when the optional DSOX6JITTER jitter analysis feature is licensed.
 *
 *            SCPI Command:
 *            :MEASure:CTCNwidth
 *            :MEASure:CTCPwidth
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ReadCycleToCycleWidth (ViSession vi, ViInt32 polarity, ViConstString source, ViReal64* width)
{
    ViStatus error  = VI_SUCCESS;
    ViString cmdStr = "";

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_GetViInt32EntryFromValue (polarity, &funcCTCWPolarityRangeTable,
                                               VI_NULL, VI_NULL, VI_NULL, VI_NULL, &cmdStr, VI_NULL), 2, "polarity");
    if (width == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 4, "Null address for width");

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viQueryf (io, "%s? %s", "%lf", cmdStr, source, width));
    }
    else
        *width = 299792458;

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_BuildRealTimeEye
 * Purpose:   Builds the real-time eye.
 *
 *            SCPI Command:
 *            :RTEYe:ACQuire
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_BuildRealTimeEye (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viPrintf (io, ":RTEY:ACQ"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureRealTimeEye
 * Purpose:   Configures the source of real-time eye and enable/disable it.
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureRealTimeEye (ViSession vi, ViConstString source, ViBoolean enabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_RTEYE_SOURCE,
                                           0, source), 2, "source");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_RTEYE_ENABLE,
                                            0, enabled), 3, "enabled");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_QueryUIIntervals
 * Purpose:   Queries the number of UI intervals folded into the real-time eye analysis.
 *
 *            SCPI Command:
 *            :RTEYe:TUINtervals
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_QueryUIIntervals (ViSession vi, ViInt32* intervals)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (intervals == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for intervals");

    if (!Ivi_Simulating (vi))                /*  call only when locked */
    {
        ViSession io = Ivi_IOSession (vi);   /*  call only when locked */
        viCheckErr (viQueryf (io, ":RTEY:TUIN?", "%d", intervals));
    }
    else
        *intervals = 299792458;

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureCANFDStandard
 * Purpose:   Configures the standard that will be used when decoding or triggering on FD frames.
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureCANFDStandard (ViSession vi, ViInt32 standard)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SBUS_CAN_FDSTANDARD,
                                          0, standard), 2, "standard");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSystemPrecision
 * Purpose:   Configures the length of system precision and enable/disable the analysis.
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSystemPrecision (ViSession vi, ViBoolean enabled, ViInt32 length)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_SYSTEM_PRECISION_ENABLED,
                                            0, enabled), 2, "enabled");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SYSTEM_PRECISION_LENGTH,
                                          0, length), 3, "length");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureTriggerJFreeEnabled
 * Purpose:   Configures whether the Jitter-Free Trigger option is enabled or not.
 *
 *            Note:
 *            This function is only available on 6000X Series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTriggerJFreeEnabled (ViSession vi, ViBoolean enabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_JFREE_ENABLED,
                                            0, enabled), 2, "enabled");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureWaveformSubsource
 * Purpose:   Configures the subsource when the waveform is serial decode.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureWaveformSubsource (ViSession vi, ViInt32 subsource)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_WAVEFORM_SOURCE_SUBSOURCE,
                                          0, subsource), 2, "subsource");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *------------------------ Global Session Callbacks -------------------------*
 *****************************************************************************/

/*****************************************************************************
 * Function: agx2k3k_CheckStatusCallback
 * Purpose:  This function queries the instrument to determine if it has
 *           encountered an error.  If the instrument has encountered an
 *           error, this function returns the IVI_ERROR_INSTRUMENT_SPECIFIC
 *           error code.  This function is called by the
 *           agx2k3k_CheckStatus utility function.  The
 *           Ivi_SetAttribute and Ivi_GetAttribute functions invoke this
 *           function when the optionFlags parameter includes the
 *           IVI_VAL_DIRECT_USER_CALL flag.
 *
 *           The user can disable calls to this function by setting the
 *           AGX2K3K_QUERY_INSTRUMENT_STATUS attribute to VI_FALSE.  The driver can
 *           disable the check status callback for a particular attribute by
 *           setting the IVI_VAL_DONT_CHECK_STATUS flag.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3k_CheckStatusCallback (ViSession vi, ViSession io)
{
    ViStatus error = VI_SUCCESS;
    ViInt16  esr   = 0;

    /* Query instrument status */
    viCheckErr (viQueryf (io, "*ESR?", "%hd", &esr));
    if (esr & IEEE_488_2_ERROR_MASK)
    {
        viCheckErr (IVI_ERROR_INSTR_SPECIFIC);
    }

Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_WaitForOPCCallback
 * Purpose:  This function waits until the instrument has finished processing
 *           all pending operations.  This function is called by the
 *           agx2k3k_WaitForOPC utility function.  The IVI engine invokes
 *           this function in the following two cases:
 *           - Before invoking the read callback for attributes for which the
 *             IVI_VAL_WAIT_FOR_OPC_BEFORE_READS flag is set.
 *           - After invoking the write callback for attributes for which the
 *             IVI_VAL_WAIT_FOR_OPC_AFTER_WRITES flag is set.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3k_WaitForOPCCallback (ViSession vi, ViSession io)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  opcTimeout;
    ViUInt16 statusByte;

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_OPC_TIMEOUT,
                                       0, &opcTimeout));

    viCheckErr (viEnableEvent (io, VI_EVENT_SERVICE_REQ, VI_QUEUE, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        viCheckErr (viPrintf (io, "*OPC"));

        /*  wait for SRQ */
        viCheckErr (viWaitOnEvent (io, VI_EVENT_SERVICE_REQ, opcTimeout, VI_NULL, VI_NULL));
        viCheckErr (viDisableEvent (io, VI_EVENT_SERVICE_REQ, VI_QUEUE));


        /*  clean up after SRQ */
        viCheckErr (viBufWrite (io, (ViBuf) "*CLS", 4, VI_NULL));
        viCheckErr (viReadSTB (io, &statusByte));
    }

Error:
    viDiscardEvents (io, VI_EVENT_SERVICE_REQ, VI_QUEUE);

    return error;
}

/*****************************************************************************
 *---------------------------- Shared Callbacks -----------------------------*
 *****************************************************************************/
/*****************************************************************************
 * Function: agx2k3kViInt32_ReadCallback
 * Purpose:  This function queries the integer value of the ViInt32 attribute.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3kViInt32_ReadCallback (ViSession vi,
                                                      ViSession io,
                                                      ViConstString channelName,
                                                      ViAttr attributeId,
                                                      ViInt32*        value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    viCheckErr (Ivi_GetStringFromTable (gs_ViInt32Commands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        /*
         * If the channelName is not NULL pointer, attribute is
         * channel based.
         */
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];

            sprintf (buffer, cmd, channelName);

            error = viQueryf (io, "%s?", "%ld", buffer, value);
        }
        else
        {
            error = viQueryf (io, "%s?", "%ld", cmd, value);
        }
        viCheckErr (error);
    }
Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3kViInt32_WriteCallback
 * Purpose:  This function sets the integer value of the ViInt32 attribute.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3kViInt32_WriteCallback (ViSession vi,
                                                       ViSession io,
                                                       ViConstString channelName,
                                                       ViAttr attributeId,
                                                       ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    viCheckErr (Ivi_GetStringFromTable (gs_ViInt32Commands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        /*
         * If the channelName is not NULL pointer, attribute is
         * channel based.
         */
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];

            sprintf (buffer, cmd, channelName);

            error = viPrintf (io, "%s %ld", buffer, value);
        }
        else
        {
            error = viPrintf (io, "%s %ld", cmd, value);
        }
        viCheckErr (error);
    }
Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3kViReal64_ReadCallback
 * Purpose:  This function queries the real value of the ViReal64 attribute.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3kViReal64_ReadCallback (ViSession vi,
                                                       ViSession io,
                                                       ViConstString channelName,
                                                       ViAttr attributeId,
                                                       ViReal64*       value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    viCheckErr (Ivi_GetStringFromTable (gs_ViReal64Commands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];

            sprintf (buffer, cmd, channelName);

            error = viQueryf (io, "%s?", "%Le", buffer, value);
        }
        else
        {
            error = viQueryf (io, "%s?", "%Le", cmd, value);
        }
        viCheckErr (error);
    }
Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3kViReal64_WriteCallback
 * Purpose:  This function sets the real value of the ViReal64 attribute.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3kViReal64_WriteCallback (ViSession vi,
                                                        ViSession io,
                                                        ViConstString channelName,
                                                        ViAttr attributeId,
                                                        ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    viCheckErr (Ivi_GetStringFromTable (gs_ViReal64Commands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];

            sprintf (buffer, cmd, channelName);

            error = viPrintf (io, "%s %Le", buffer, value);
        }
        else
        {
            error = viPrintf (io, "%s %Le", cmd, value);
        }
        viCheckErr (error);
    }
Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3kEnum_WriteCallback
 * Purpose:  This function sets the enum value of the ViInt32 attribute.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3kEnum_WriteCallback (ViSession vi,
                                                    ViSession io,
                                                    ViConstString channelName,
                                                    ViAttr attributeId,
                                                    ViInt32 value)
{
    ViStatus         error = VI_SUCCESS;
    ViString         command,
                     command_value;
    IviRangeTablePtr table;

    viCheckErr (Ivi_GetStringFromTable (gs_EnumCommands, attributeId, &command));
    checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &table));
    viCheckErr (agx2k3k_GetCmdFromIntValue (value, table, &command_value));

    if (!Ivi_Simulating (vi))
    {
        if (strlen (command_value) != 0)
        {
            if (channelName != VI_NULL)
            {
                ViChar buffer[BUFFER_SIZE];

                sprintf (buffer, command, channelName);

                error = viPrintf (io, "%s %s", buffer, command_value);
            }
            else
            {
                error = viPrintf (io, "%s %s", command, command_value);
            }
            viCheckErr (error);
        }
    }
Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3kEnum_ReadCallback
 * Purpose:  This function reads the enum value of the ViInt32 attribute.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3kEnum_ReadCallback (ViSession vi,
                                                   ViSession io,
                                                   ViConstString channelName,
                                                   ViAttr attributeId,
                                                   ViInt32*        value)
{
    ViStatus         error = VI_SUCCESS;
    ViString         command;
    IviRangeTablePtr table;

    viCheckErr (Ivi_GetStringFromTable (gs_EnumCommands, attributeId, &command));
    checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &table));

    if (!Ivi_Simulating (vi))
    {
        ViChar buffer[BUFFER_SIZE];
        size_t buffer_size = sizeof (buffer);

        if (channelName != VI_NULL)
        {
            sprintf (buffer, command, channelName);
            error = viPrintf (io, "%s?", buffer);
        }
        else
        {
            error = viPrintf (io, "%s?", command);
        }
        viCheckErr (error);

        viCheckErr (viScanf (io, "%#s", &buffer_size, buffer));
        viCheckErr (agx2k3k_GetValueFromCmd (buffer, table, value));
    }
Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3kViBoolean_WriteCallback
 * Purpose:  This function sets the bool value of the ViBoolean attribute.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3kViBoolean_WriteCallback (ViSession vi,
                                                         ViSession io,
                                                         ViConstString channelName,
                                                         ViAttr attributeId,
                                                         ViBoolean value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    viCheckErr (Ivi_GetStringFromTable (gs_ViBooleanCommands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];
            sprintf (buffer, cmd, channelName);
            error = viPrintf (io, "%s %ld", buffer, (value) ? 1 : 0);
        }
        else
        {
            error = viPrintf (io, "%s %ld", cmd, (value) ? 1 : 0);
        }
        viCheckErr (error);
    }
Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3kViBoolean_ReadCallback
 * Purpose:  This function queries the bool value of the ViBoolean attribute.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3kViBoolean_ReadCallback (ViSession vi,
                                                        ViSession io,
                                                        ViConstString channelName,
                                                        ViAttr attributeId,
                                                        ViBoolean*      value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    viCheckErr (Ivi_GetStringFromTable (gs_ViBooleanCommands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];
            sprintf (buffer, cmd, channelName);
            error = viQueryf (io, "%s?", "%hd", buffer, value);
        }
        else
        {
            error = viQueryf (io, "%s?", "%hd", cmd, value);
        }
        viCheckErr (error);
    }
Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3kViQuotedString_WriteCallback
 * Purpose:  This function sets the string value of the ViString attribute.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3kViQuotedString_WriteCallback (ViSession vi,
                                                              ViSession io,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViString command;

    viCheckErr (Ivi_GetStringFromTable (gs_ViStringCommands, attributeId, &command));
    if (!Ivi_Simulating (vi))
    {
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];
            sprintf (buffer, command, channelName);
            error = viPrintf (io, "%s \"%s\"", buffer, value);
        }
        else
        {
            error = viPrintf (io, "%s \"%s\"", command, value);
        }
        viCheckErr (error);
    }

Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3kViString_WriteCallback
 * Purpose:  This function sets the string value of the ViString attribute.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3kViString_WriteCallback (ViSession vi,
                                                        ViSession io,
                                                        ViConstString channelName,
                                                        ViAttr attributeId,
                                                        ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViString command;

    viCheckErr (Ivi_GetStringFromTable (gs_ViStringCommands, attributeId, &command));
    if (!Ivi_Simulating (vi))
    {
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];
            sprintf (buffer, command, channelName);
            error = viPrintf (io, "%s %s", buffer, value);
        }
        else
        {
            error = viPrintf (io, "%s %s", command, value);
        }
        viCheckErr (error);
    }

Error:
    return error;
}
/*****************************************************************************
 * Function: agx2k3kViString_ReadCallback
 * Purpose:  This function reads the string value of the ViString attribute.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3kViString_ReadCallback (ViSession vi,
                                                       ViSession io,
                                                       ViConstString channelName,
                                                       ViAttr attributeId,
                                                       const ViConstString cacheValue)
{
    ViStatus error = VI_SUCCESS;
    ViString command;
    ViChar   * pdata = VI_NULL;
    ViChar   * pend  = VI_NULL;

    viCheckErr (Ivi_GetStringFromTable (gs_ViStringCommands, attributeId, &command));

    if (!Ivi_Simulating (vi))
    {
        ViChar   buffer[BUFFER_SIZE];
        ViChar   * pbuffer       = VI_NULL;
        ViUInt32 allocated_count = 0;
        ViUInt32 count           = 0;
        ViUInt32 readed_count;

        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];
            sprintf (buffer, command, channelName);
            error = viPrintf (io, "%s?", buffer);
        }
        else
        {
            error = viPrintf (io, "%s?", command);
        }
        viCheckErr (error);

        while ((error = viRead (io, (ViPBuf) buffer, BUFFER_SIZE, &readed_count)) == VI_SUCCESS_MAX_CNT)
        {
            if (allocated_count)
            {
                if (allocated_count <= count + readed_count)
                {
                    allocated_count += (allocated_count - count) + BUFFER_SIZE;
                    pdata            = (char *) realloc (pdata, allocated_count);
                }

                pend = pdata + count;
            }
            else
            {
                allocated_count = 2 * BUFFER_SIZE;
                pdata           = (char *) malloc (allocated_count);
                pend            = pdata;
            }

            memcpy (pend, buffer, readed_count);
            count += readed_count;
        }

        if (readed_count > 0)
        {
            /*
             * Check if the last character is alnum.
             * if this character is not alnum we know that it's '\n'.
             * Remove it.
             */
            if (!isalnum (buffer[readed_count - 1]))
                readed_count--;
            buffer[readed_count] = '\0';
        }

        /*
         * If function is read more data as BUFFER_SIZE, we must
         * copy last data from static buffer to dynamic buffer
         */
        if (pdata)
        {
            /*
             * For sure, check if the  buffer has enought element.
             * This condition should be FALSE every time.
             */
            if (allocated_count <= count + readed_count)
            {
                allocated_count += (allocated_count - count) + BUFFER_SIZE;
                pdata            = (char *) realloc (pdata, allocated_count);
            }
            pend = pdata + count;
            memcpy (pend, buffer, readed_count + 1);
            pbuffer = pdata;
        }
        else
            pbuffer = buffer;

        viCheckErr (error);

        checkErr (Ivi_SetValInStringCallback (vi, attributeId, pbuffer));
    }

Error:
    if (pdata)
        free (pdata);
    return error;
}
/*****************************************************************************
 * Function: agx2k3kViString_ReadCallback
 * Purpose:  This function reads the string value of the ViString attribute.
 *****************************************************************************/
static ViStatus _VI_FUNC agx2k3kViQuotedString_ReadCallback (ViSession vi,
                                                             ViSession io,
                                                             ViConstString channelName,
                                                             ViAttr attributeId,
                                                             const ViConstString cacheValue)
{
    ViStatus error = VI_SUCCESS;
    ViString command;
    ViChar   * pdata = VI_NULL;
    ViChar   * pend  = VI_NULL;

    viCheckErr (Ivi_GetStringFromTable (gs_ViStringCommands, attributeId, &command));

    if (!Ivi_Simulating (vi))
    {
        ViChar   buffer[BUFFER_SIZE];
        ViChar   * pbuffer       = VI_NULL;
        ViUInt32 allocated_count = 0;
        ViUInt32 count           = 0;
        ViUInt32 readed_count;

        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];
            sprintf (buffer, command, channelName);
            error = viPrintf (io, "%s?", buffer);
        }
        else
        {
            error = viPrintf (io, "%s?", command);
        }
        viCheckErr (error);

        while ((error = viRead (io, (ViPBuf) buffer, BUFFER_SIZE, &readed_count)) == VI_SUCCESS_MAX_CNT)
        {
            if (allocated_count)
            {
                if (allocated_count <= count + readed_count)
                {
                    allocated_count += (allocated_count - count) + BUFFER_SIZE;
                    pdata            = (char *) realloc (pdata, allocated_count);
                }

                pend = pdata + count;
            }
            else
            {
                allocated_count = 2 * BUFFER_SIZE;
                pdata           = (char *) malloc (allocated_count);
                pend            = pdata;
            }

            memcpy (pend, buffer, readed_count);
            count += readed_count;
        }

        if (readed_count > 0)
        {
            /*
             * Check if the last character is alnum.
             * if this character is not alnum we know that it's '\n'.
             * Remove it.
             */
            if (!isalnum (buffer[readed_count - 1]))
                readed_count--;
            buffer[readed_count] = '\0';
        }

        /*
         * If function is read more data as BUFFER_SIZE, we must
         * copy last data from static buffer to dynamic buffer
         */
        if (pdata)
        {
            /*
             * For sure, check if the  buffer has enought element.
             * This condition should be FALSE every time.
             */
            if (allocated_count <= count + readed_count)
            {
                allocated_count += (allocated_count - count) + BUFFER_SIZE;
                pdata            = (char *) realloc (pdata, allocated_count);
            }
            pend = pdata + count;
            memcpy (pend, buffer, readed_count + 1);
            pbuffer = pdata;
        }
        else
            pbuffer = buffer;

        viCheckErr (error);

        checkErr (Ivi_SetValInStringCallback (vi, attributeId, pbuffer));
    }

Error:
    if (pdata)
        free (pdata);
    return error;
}

/*****************************************************************************
 *----------------- Attribute Range Tables and Callbacks --------------------*
 *****************************************************************************/

/*- AGX2K3K_ATTR_ID_QUERY_RESPONSE -*/
static ViStatus _VI_FUNC agx2k3kAttrIdQueryResponse_ReadCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  const ViConstString cacheValue)
{
    ViStatus error                 = VI_SUCCESS;
    ViChar   rdBuffer[BUFFER_SIZE] = "";
    ViUInt32 retCnt;

    if (!Ivi_Simulating (vi))
    {
        viCheckErr (viPrintf (io, "*IDN?"));
        viCheckErr (viRead (io, (ViPBuf) rdBuffer, BUFFER_SIZE - 1, &retCnt));
        rdBuffer[retCnt] = 0;
    }

    checkErr (Ivi_SetValInStringCallback (vi, attributeId, rdBuffer));

Error:
    return error;
}

/*- AGX2K3K_ATTR_SPECIFIC_DRIVER_REVISION -*/
static ViStatus _VI_FUNC agx2k3kAttrDriverRevision_ReadCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 const ViConstString cacheValue)
{
    ViStatus error = VI_SUCCESS;
    ViChar   driverRevision[256];


    sprintf (driverRevision,
             "Driver: agx2k3k %d.%d, Compiler: %s %3.2f, "
             "Components: IVIEngine %.2f, VISA-Spec %.2f",
             AGX2K3K_MAJOR_VERSION, AGX2K3K_MINOR_VERSION,
             IVI_COMPILER_NAME, IVI_COMPILER_VER_NUM,
             IVI_ENGINE_MAJOR_VERSION + IVI_ENGINE_MINOR_VERSION / 1000.0,
             Ivi_ConvertVISAVer (VI_SPEC_VERSION));

    checkErr (Ivi_SetValInStringCallback (vi, attributeId, driverRevision));
Error:
    return error;
}


/*- AGX2K3K_ATTR_INSTRUMENT_FIRMWARE_REVISION -*/
static ViStatus _VI_FUNC agx2k3kAttrFirmwareRevision_ReadCallback (ViSession vi,
                                                                   ViSession io,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   const ViConstString cacheValue)
{
    ViStatus error = VI_SUCCESS;
    ViChar   idQ[BUFFER_SIZE], rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, "", AGX2K3K_ATTR_ID_QUERY_RESPONSE,
                                        0, BUFFER_SIZE, idQ));

    sscanf (idQ, "%*[^,],%*[^,],%*[^,],%256[^\n]", rdBuffer);

    checkErr (Ivi_SetValInStringCallback (vi, attributeId, rdBuffer));

Error:
    return error;
}

/*- AGX2K3K_ATTR_INSTRUMENT_MANUFACTURER -*/
static ViStatus _VI_FUNC agx2k3kAttrInstrumentManufacturer_ReadCallback (ViSession vi,
                                                                         ViSession io,
                                                                         ViConstString channelName,
                                                                         ViAttr attributeId,
                                                                         const ViConstString cacheValue)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rdBuffer[BUFFER_SIZE];
    ViChar   idQ[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, "", AGX2K3K_ATTR_ID_QUERY_RESPONSE,
                                        0, BUFFER_SIZE, idQ));
    sscanf (idQ, "%256[^,]", rdBuffer);

    checkErr (Ivi_SetValInStringCallback (vi, attributeId, rdBuffer));

Error:
    return error;
}

/*- AGX2K3K_ATTR_INSTRUMENT_MODEL -*/
static ViStatus _VI_FUNC agx2k3kAttrInstrumentModel_ReadCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  const ViConstString cacheValue)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rdBuffer[BUFFER_SIZE];
    ViChar   idQ[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, "", AGX2K3K_ATTR_ID_QUERY_RESPONSE,
                                        0, BUFFER_SIZE, idQ));
    sscanf (idQ, "%*[^,],%256[^,]", rdBuffer);

    checkErr (Ivi_SetValInStringCallback (vi, attributeId, rdBuffer));

Error:
    return error;
}

/*- AGX2K3K_ATTR_PROBE_ATTENUATION -*/
static IviRangeTableEntry attrProbeAttenuationRangeTableEntries[] =
{
    { AGX2K3K_VAL_PROBE_SENSE_ON, 0.0 - 1E-7,   -1.0, "", 0 },
    {                          0,        0.1,    0.1, "", 0 },
    {                        0.1,        0.2,    0.2, "", 0 },
    {                        0.2,        0.5,    0.5, "", 0 },
    {                        0.5,        1.0,    1.0, "", 0 },
    {                        1.0,        2.0,    2.0, "", 0 },
    {                        2.0,        5.0,    5.0, "", 0 },
    {                        5.0,       10.0,   10.0, "", 0 },
    {                       10.0,       20.0,   20.0, "", 0 },
    {                       20.0,       50.0,   50.0, "", 0 },
    {                       50.0,      100.0,  100.0, "", 0 },
    {                      100.0,      200.0,  200.0, "", 0 },
    {                      200.0,      500.0,  500.0, "", 0 },
    {                      500.0,     1000.0, 1000.0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrProbeAttenuationRangeTable =
{
    IVI_VAL_COERCED,
    VI_TRUE,
    VI_FALSE,
    "",
    attrProbeAttenuationRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrProbeAttenuation_WriteCallback (ViSession vi,
                                                                    ViSession io,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViReal64 value)
{
    ViStatus  error = VI_SUCCESS;
    ViBoolean enable_cache;

    if (value < 0.0)
    {
        /*
         * Auto Probe
         */
        enable_cache = VI_TRUE;
    }
    else
    {
        /*
         * Manual Probe
         */
        enable_cache = VI_FALSE;

        checkErr (Ivi_SetAttributeViReal64 (vi,
                                            channelName,
                                            AGX2K3K_ATTR_INSTR_PROBE_ATTENUATION,
                                            0, value));
    }

    checkErr (Ivi_SetAttributeViBoolean (vi,
                                         channelName,
                                         AGX2K3K_ATTR_INSTR_AUTO_PROBE_SENSE_ENABLED,
                                         0, enable_cache));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrProbeAttenuation_ReadCallback (ViSession vi,
                                                                   ViSession io,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViReal64 *value)
{
    ViStatus  error       = VI_SUCCESS;
    ViBoolean probe_sense = VI_FALSE;

    checkErr (Ivi_GetAttributeViBoolean (vi, channelName,
                                         AGX2K3K_ATTR_INSTR_AUTO_PROBE_SENSE_ENABLED,
                                         0, &probe_sense));
    if (probe_sense)
        *value = AGX2K3K_VAL_PROBE_SENSE_ON;
    else
    {
        checkErr (agx2k3k_GetProbeAttenuation (vi, channelName, value));
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_PROBE_SENSE_VALUE -*/
static ViStatus _VI_FUNC agx2k3kAttrProbeSenseValue_ReadCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViReal64*       value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_GetAttributeViReal64 (vi, channelName, AGX2K3K_ATTR_INSTR_PROBE_ATTENUATION, 0, value));

Error:
    return error;
}

/*- AGX2K3K_ATTR_VERTICAL_RANGE -*/
static IviRangeTableEntry attrVerticalRangeRangeTableEntries[] =
{
    { 16e-3, 40.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrVerticalRangeRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrVerticalRangeRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrVerticalRange_CheckCallback (ViSession vi,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViReal64 adjustedValue, probeAtt;
    ViInt32  result;

    checkErr (Ivi_GetAttributeViReal64 (vi, channelName, AGX2K3K_ATTR_INSTR_PROBE_ATTENUATION,
                                        0, &probeAtt));
    adjustedValue = value / probeAtt;
    checkErr (Ivi_DefaultCheckCallbackViReal64 (vi, channelName,
                                                attributeId, adjustedValue));

    viCheckErr (Ivi_CompareWithPrecision (0, adjustedValue, 16e-3, &result));
    if (result < 0)
        viCheckErr (IVI_ERROR_INVALID_VALUE);

    viCheckErr (Ivi_CompareWithPrecision (0, adjustedValue, 40.0, &result));
    if (result > 0)
        viCheckErr (IVI_ERROR_INVALID_VALUE);

Error:
    return error;
}

/*- AGX2K3K_ATTR_VERTICAL_OFFSET -*/
static ViStatus _VI_FUNC agx2k3kAttrVerticalOffset_CheckCallback (ViSession vi,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViReal64 value)
{
    ViStatus error = VI_SUCCESS;

    if (Ivi_RangeChecking (vi))
    {
        ViReal64 probeAtt, max, vRange;

        checkErr (Ivi_GetAttributeViReal64 (vi, channelName, AGX2K3K_ATTR_PROBE_SENSE_VALUE,
                                            0, &probeAtt));

        checkErr (Ivi_GetAttributeViReal64 (vi, channelName, AGX2K3K_ATTR_VERTICAL_RANGE,
                                            0, &vRange));

        max = (((vRange / probeAtt) > 1.6) ? 75.0 : 20.0) * probeAtt;

        if (value < -max || value > max)
            viCheckErr (IVI_ERROR_INVALID_VALUE);
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_VERTICAL_COUPLING -*/
static IviRangeTableEntry attrVerticalCouplingRangeTableEntries[] =
{
    { AGX2K3K_VAL_AC, 0, 0, "AC", 0 },
    { AGX2K3K_VAL_DC, 0, 0, "DC", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrVerticalCouplingRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrVerticalCouplingRangeTableEntries,
};

/*- AGX2K3K_ATTR_CHANNEL_ENABLED -*/
/* Use public callback functions */

/*- AGX2K3K_ATTR_DIG_SIZE -*/
static IviRangeTableEntry attrDigitalChannelSizeRangeTableEntries[] =
{
    { AGX2K3K_VAL_DIGITAL_SIZE_SMALL,  0, 0, "SMAL", 0 },
    { AGX2K3K_VAL_DIGITAL_SIZE_MEDIUM, 0, 0, "MED",  0 },
    { AGX2K3K_VAL_DIGITAL_SIZE_LARGE,  0, 0, "LARG", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrDigitalChannelSizeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrDigitalChannelSizeRangeTableEntries,
};

/*- AGX2K3K_ATTR_DIG_THRESHOLD -*/
static IviRangeTableEntry attrDigitalThresholdRangeTableEntries[] =
{
    { -8.0, 8.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrDigitalThresholdRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrDigitalThresholdRangeTableEntries,
};


/*- AGX2K3K_ATTR_DIG_CHANNEL_ENABLED -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_MAX_INPUT_FREQUENCY -*/
static ViStatus _VI_FUNC agx2k3kAttrMaxInputFrequency_CheckCallback (ViSession vi,
                                                                     ViConstString channelName,
                                                                     ViAttr attributeId,
                                                                     ViReal64 value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_DefaultCheckCallbackViReal64 (vi, channelName, attributeId, value));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrMaxInputFrequency_WriteCallback (ViSession vi,
                                                                     ViSession io,
                                                                     ViConstString channelName,
                                                                     ViAttr attributeId,
                                                                     ViReal64 value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_SetAttributeViReal64 (vi, channelName, AGX2K3K_ATTR_INSTR_MAX_INPUT_FREQUENCY, 0, value));

    checkErr (Ivi_SetAttributeViBoolean (vi, channelName, AGX2K3K_ATTR_INSTR_BW_LIMIT, 0,
                                         (value <= 25.0e6) ? VI_TRUE : VI_FALSE));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrMaxInputFrequency_ReadCallback (ViSession vi,
                                                                    ViSession io,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViReal64 *value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_GetAttributeViReal64 (vi, channelName, AGX2K3K_ATTR_INSTR_MAX_INPUT_FREQUENCY, 0, value));

Error:
    return error;
}

/*- AGX2K3K_ATTR_VERNIER -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_INVERT -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_INPUT_IMPEDANCE -*/
static IviRangeTableEntry attrInputImpedanceRangeTableEntries[] =
{
    {    50.0, 0, 0, "FIFT", 0 },
    { 1.0e+06, 0, 0, "ONEM", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrInputImpedanceRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrInputImpedanceRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrInputImpedance_CheckCallback (ViSession vi,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  coupling;
    ViInt32  modelType = UNKNOWN;

    checkErr (Ivi_GetAttributeViInt32 (vi, channelName, AGX2K3K_ATTR_VERTICAL_COUPLING,
                                       0, &coupling));

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       0, &modelType));

    if (coupling == AGX2K3K_VAL_AC && value == 50.0)
        viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);

    if (IS_2000_SERIES (modelType) && value != 1.0e6)
        viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrInputImpedance_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    viCheckErr (Ivi_GetViReal64EntryFromValue (value, &attrInputImpedanceRangeTable,
                                               VI_NULL, VI_NULL, VI_NULL, VI_NULL,
                                               &cmd, VI_NULL));

    checkErr (Ivi_SetAttributeViString (vi, channelName, AGX2K3K_ATTR_INSTR_INPUT_IMPEDANCE, 0, cmd));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrInputImpedance_ReadCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViReal64 *value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, channelName, AGX2K3K_ATTR_INSTR_INPUT_IMPEDANCE, 0, BUFFER_SIZE, rdBuffer));

    viCheckErr (Ivi_GetViReal64EntryFromString (rdBuffer, &attrInputImpedanceRangeTable,
                                                value, VI_NULL, VI_NULL, VI_NULL, VI_NULL));

Error:
    return error;
}

/*- AGX2K3K_ATTR_HORZ_TIME_PER_RECORD -*/
static IviRangeTableEntry attrHorzTimePerRecordRangeTableEntries[] =
{
    { 5.0e-9, 500.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrHorzTimePerRecordRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrHorzTimePerRecordRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrHorzTimePerRecord_CheckCallback (ViSession vi,
                                                                     ViConstString channelName,
                                                                     ViAttr attributeId,
                                                                     ViReal64 value)
{
    ViStatus error     = VI_SUCCESS;
    ViReal64 min       = 5.0e-9;
    ViReal64 max       = 500.0;
    ViInt32  modelType = UNKNOWN;

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViInt32 (vi,
                                           VI_NULL,
                                           AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                           0, &modelType));
        if (IS_2000_SERIES (modelType))
        {
            min = 50.0e-9;
        }
        if (IS_3000_SERIES (modelType))
        {
            min = 20.0e-9;
        }

        if (value < min || value > max)
            viCheckErr (IVI_ERROR_INVALID_VALUE);
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_HORZ_RECORD_LENGTH -*/
static ViStatus _VI_FUNC agx2k3kAttrHorzRecordLength_WriteCallback (ViSession vi,
                                                                    ViSession io,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViInt32 value)
{
    ViStatus  error = VI_SUCCESS;
    ViBoolean continuous;

    if (!Ivi_Simulating (vi))
    {
        viCheckErr (viPrintf (io, "STOP;"));

        viCheckErr (viPrintf (io, "WAV:POIN %d;", value));
    }
    checkErr (Ivi_GetAttributeViBoolean (vi, VI_NULL,
                                         AGX2K3K_ATTR_INITIATE_CONTINUOUS,
                                         0, &continuous));
    checkErr (Ivi_InvalidateAttribute (vi, VI_NULL,
                                       AGX2K3K_ATTR_INITIATE_CONTINUOUS));
    checkErr (Ivi_SetAttributeViBoolean (vi, VI_NULL,
                                         AGX2K3K_ATTR_INITIATE_CONTINUOUS,
                                         0, continuous));

Error:
    return error;
}

/*- AGX2K3K_ATTR_HORZ_MIN_NUM_PTS -*/
static IviRangeTableEntry attrMinNumPtsRangeTableEntries[] =
{
    { 0, 64516, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrMinNumPtsRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrMinNumPtsRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrMinNumPts_CheckCallback (ViSession vi,
                                                             ViConstString channelName,
                                                             ViAttr attributeId,
                                                             ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  maxAcquirePoints;

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                           AGX2K3K_ATTR_INSTR_ACQUISITION_POINTS,
                                           0, &maxAcquirePoints));

        if (value > maxAcquirePoints)
            viCheckErr (IVI_ERROR_INVALID_VALUE);
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrMinNumPts_WriteCallback (ViSession vi,
                                                             ViSession io,
                                                             ViConstString channelName,
                                                             ViAttr attributeId,
                                                             ViInt32 value)
{
    ViStatus error = VI_SUCCESS;

    error = Ivi_SetAttributeViInt32 (vi, VI_NULL,
                                     AGX2K3K_ATTR_HORZ_RECORD_LENGTH,
                                     IVI_VAL_DONT_MARK_AS_SET_BY_USER, value);

    if (error == IVI_ERROR_INVALID_VALUE)
        Ivi_SetErrorInfo (vi, VI_TRUE, error, VI_SUCCESS,
                          "AGX2K3K_ATTR_HORZ_MIN_NUM_PTS");
    return error;
}

/*- AGX2K3K_ATTR_HORZ_RECORD_MODE -*/
static ViStatus _VI_FUNC agx2k3kAttrHorzRecordMode_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViInt32 value)
{
    ViStatus         error = VI_SUCCESS;
    ViBoolean        continuous;
    IviRangeTablePtr table;
    ViString         command_value;

    if (!Ivi_Simulating (vi))
    {
        viCheckErr (viPrintf (io, "STOP;"));

        checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &table));
        viCheckErr (agx2k3k_GetCmdFromIntValue (value, table, &command_value));
        viCheckErr (viPrintf (io, "WAV:POIN:MODE %s;", command_value));
    }
    checkErr (Ivi_GetAttributeViBoolean (vi, VI_NULL,
                                         AGX2K3K_ATTR_INITIATE_CONTINUOUS,
                                         0, &continuous));
    checkErr (Ivi_InvalidateAttribute (vi, VI_NULL,
                                       AGX2K3K_ATTR_INITIATE_CONTINUOUS));
    checkErr (Ivi_SetAttributeViBoolean (vi, VI_NULL,
                                         AGX2K3K_ATTR_INITIATE_CONTINUOUS,
                                         0, continuous));

Error:
    return error;
}


/*- AGX2K3K_ATTR_ACQUISITION_START_TIME -*/
static IviRangeTableEntry attrAcqStartTimeRangeTableEntries[] =
{
    { -5.00e+02, 5.00e+02, 5.00e+01, "", 0 },
    { -2.00e+02, 5.00e+02, 2.00e+01, "", 0 },
    { -1.00e+02, 5.00e+02, 1.00e+01, "", 0 },
    { -5.00e+01, 5.00e+02, 5.00e+00, "", 0 },
    { -2.00e+01, 5.00e+02, 2.00e+00, "", 0 },
    { -1.00e+01, 5.00e+02, 1.00e+00, "", 0 },
    { -5.00e+00, 5.00e+02, 5.00e-01, "", 0 },
    { -2.00e+00, 5.00e+02, 2.00e-01, "", 0 },
    { -1.00e+00, 5.00e+02, 1.00e-01, "", 0 },
    { -5.00e-01, 5.00e+02, 5.00e-02, "", 0 },
    { -2.00e-01, 2.00e+02, 2.00e-02, "", 0 },
    { -1.00e-01, 1.00e+02, 1.00e-02, "", 0 },
    { -5.00e-02, 5.00e+01, 5.00e-03, "", 0 },
    { -2.00e-02, 2.00e+01, 2.00e-03, "", 0 },
    { -1.00e-02, 1.00e+01, 1.00e-03, "", 0 },
    { -5.00e-03, 5.00e+00, 5.00e-04, "", 0 },
    { -2.00e-03, 2.00e+00, 2.00e-04, "", 0 },
    { -1.00e-03, 1.00e+00, 1.00e-04, "", 0 },
    { -5.00e-06, 1.00e+00, 5.00e-05, "", 0 },
    { -5.00e-06, 1.00e+00, 2.00e-05, "", 0 },
    { -5.00e-06, 1.00e+00, 1.00e-05, "", 0 },
    { -5.00e-06, 1.00e+00, 5.00e-06, "", 0 },
    { -5.00e-06, 1.00e+00, 2.00e-06, "", 0 },
    { -5.00e-06, 1.00e+00, 1.00e-06, "", 0 },
    { -5.00e-06, 1.00e+00, 5.00e-07, "", 0 },
    { -5.00e-06, 1.00e+00, 2.00e-07, "", 0 },
    { -5.00e-06, 1.00e+00, 1.00e-07, "", 0 },
    { -5.00e-06, 1.00e+00, 5.00e-08, "", 0 },
    { -5.00e-06, 1.00e+00, 2.00e-08, "", 0 },
    { -5.00e-06, 1.00e+00, 1.00e-08, "", 0 },
    { -5.00e-06, 1.00e+00, 5.00e-09, "", 0 },
    { -5.00e-06, 1.00e+00, 2.00e-09, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrAcqStartTimeRangeTable =
{
    IVI_VAL_RANGED,
    VI_FALSE,
    VI_FALSE,
    "",
    attrAcqStartTimeRangeTableEntries,
};


static ViStatus _VI_FUNC agx2k3kAttrAcquisitionStartTime_CheckCallback (ViSession vi,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViReal64 scale;
    ViReal64 min, max;

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_TIMEBASE_SCALE, 0, &scale));

        viCheckErr (Ivi_GetViReal64EntryFromCoercedVal (scale, &attrAcqStartTimeRangeTable, &min, &max,
                                                        VI_NULL, VI_NULL, VI_NULL));


        if (value < min || value > max)
        {
            viCheckErr (IVI_ERROR_INVALID_VALUE);
        }
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrAcquisitionStartTime_WriteCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViReal64 value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_SetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_TIMEBASE_REFERENCE,
                                       0,
                                       AGX2K3K_VAL_TIMEBASE_REF_CENTER));

    checkErr (Ivi_SetAttributeViReal64 (vi,
                                        VI_NULL,
                                        AGX2K3K_ATTR_TIMEBASE_POSITION,
                                        0,
                                        value));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrAcquisitionStartTime_ReadCallback (ViSession vi,
                                                                       ViSession io,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViReal64 *value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_GetAttributeViReal64 (vi,
                                        VI_NULL,
                                        AGX2K3K_ATTR_TIMEBASE_POSITION,
                                        0,
                                        value));

Error:
    return error;
}

/*- AGX2K3K_ATTR_HORZ_SAMPLE_RATE -*/
/*- Shared Read callcabck agx2k3kViReal64_ReadCallback -*/

/*- AGX2K3K_ATTR_TRIGGER_TYPE -*/
static IviRangeTableEntry attrTriggerTypeRangeTable_3000Entries[] =
{
    { AGX2K3K_VAL_EDGE_TRIGGER,       0, 0, "EDGE",  0 },
    { AGX2K3K_VAL_GLITCH_TRIGGER,     0, 0, "GLIT",  0 },
    { AGX2K3K_VAL_PATTERN_TRIGGER,    0, 0, "PATT",  0 },
    { AGX2K3K_VAL_TV_TRIGGER,         0, 0, "TV",    0 },
    { AGX2K3K_VAL_EDGE_BURST_TRIGGER, 0, 0, "EBUR",  0 },
    { AGX2K3K_VAL_RUNT_TRIGGER,       0, 0, "RUNT",  0 },
    { AGX2K3K_VAL_SETUP_HOLD_TRIGGER, 0, 0, "SHOL",  0 },
    { AGX2K3K_VAL_TRANSITION_TRIGGER, 0, 0, "TRAN",  0 },
    { AGX2K3K_VAL_USB_TRIGGER,        0, 0, "USB",   0 },
    { AGX2K3K_VAL_DELAY_TRIGGER,      0, 0, "DEL",   0 },
    { AGX2K3K_VAL_OR_TRIGGER,         0, 0, "OR",    0 },
    { AGX2K3K_VAL_SBUS1_TRIGGER,      0, 0, "SBUS1", 0 },
    { AGX2K3K_VAL_SBUS2_TRIGGER,      0, 0, "SBUS2", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTriggerTypeRangeTable_3000 =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTriggerTypeRangeTable_3000Entries,
};

static IviRangeTableEntry attrTriggerTypeRangeTable_2000Entries[] =
{
    { AGX2K3K_VAL_EDGE_TRIGGER,    0, 0, "EDGE", 0 },
    { AGX2K3K_VAL_GLITCH_TRIGGER,  0, 0, "GLIT", 0 },
    { AGX2K3K_VAL_PATTERN_TRIGGER, 0, 0, "PATT", 0 },
    { AGX2K3K_VAL_TV_TRIGGER,      0, 0, "TV",   0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTriggerTypeRangeTable_2000 =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTriggerTypeRangeTable_2000Entries,
};

static ViStatus _VI_FUNC agx2k3kAttrTriggerType_RangeTableCallback (ViSession vi,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    IviRangeTablePtr *rangeTablePtr)
{
    ViStatus         error     = VI_SUCCESS;
    IviRangeTablePtr tblPtr    = VI_NULL;
    ViInt32          modelType = UNKNOWN;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       0, &modelType));

    if (IS_2000_SERIES (modelType))
    {
        tblPtr = &attrTriggerTypeRangeTable_2000;
    }
    else if (IS_3000_SERIES (modelType) || IS_4000_SERIES (modelType) || IS_6000_SERIES (modelType))
    {
        tblPtr = &attrTriggerTypeRangeTable_3000;
    }
    else
    {
        return IVI_ERROR_ATTRIBUTE_NOT_SUPPORTED;
    }

Error:
    *rangeTablePtr = tblPtr;
    return error;
}

/*- AGX2K3K_ATTR_TRIGGER_SOURCE -*/
static ViStatus _VI_FUNC agx2k3kAttrTriggerSource_CheckCallback (ViSession vi,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  trigger_type;

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViInt32 (vi,
                                           VI_NULL,
                                           AGX2K3K_ATTR_TRIGGER_TYPE,
                                           0, &trigger_type));

        switch (trigger_type)
        {
        case AGX2K3K_VAL_TV_TRIGGER:
        {
            if (!strstr (value, "CHAN"))
            {
                viCheckErr (IVI_ERROR_INVALID_VALUE);
            }
        } break;
        }
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrTriggerSource_WriteCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  trigger_type;
    /* Default value for attribute_id */
    ViAttr   attribute_id = VI_NULL;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_TRIGGER_TYPE,
                                       0, &trigger_type));

    switch (trigger_type)
    {
    case AGX2K3K_VAL_TV_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_TV_SOURCE;
        break;

    case AGX2K3K_VAL_GLITCH_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_SOURCE;
        break;

    case AGX2K3K_VAL_RUNT_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_RUNT_SOURCE;
        break;

    case AGX2K3K_VAL_TRANSITION_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_TRANSITION_SOURCE;
        break;

    case AGX2K3K_VAL_EDGE_BURST_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_BURST_SOURCE;
        break;

    case AGX2K3K_VAL_EDGE_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_SOURCE;
        break;

    case AGX2K3K_VAL_SETUP_HOLD_TRIGGER:
    case AGX2K3K_VAL_USB_TRIGGER:
    case AGX2K3K_VAL_PATTERN_TRIGGER:
    default:
        /* Use specific source attributes */
        viCheckErrElab (IVI_ERROR_INVALID_CONFIGURATION, "Trigger Source is not available "
                        "for active trigger type.");
        break;
    }

    if (attribute_id != VI_NULL)
    {
        checkErr (Ivi_SetAttributeViString (vi, channelName, attribute_id, 0, value));
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrTriggerSource_ReadCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                const ViConstString cacheValue)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];
    ViInt32  trigger_type;
    /* Default value for attribute_id */
    ViAttr   attribute_id = VI_NULL;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_TRIGGER_TYPE,
                                       0, &trigger_type));

    switch (trigger_type)
    {
    case AGX2K3K_VAL_EDGE_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_SOURCE;
        break;

    case AGX2K3K_VAL_EDGE_BURST_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_BURST_SOURCE;
        break;

    case AGX2K3K_VAL_TV_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_TV_SOURCE;
        break;

    case AGX2K3K_VAL_GLITCH_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_SOURCE;
        break;

    case AGX2K3K_VAL_RUNT_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_RUNT_SOURCE;
        break;

    case AGX2K3K_VAL_TRANSITION_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_TRANSITION_SOURCE;
        break;

    case AGX2K3K_VAL_SETUP_HOLD_TRIGGER:
    case AGX2K3K_VAL_USB_TRIGGER:
    case AGX2K3K_VAL_PATTERN_TRIGGER:
    default:
        /* Use specific source attributes */
        viCheckErrElab (IVI_ERROR_INVALID_CONFIGURATION, "Trigger Source is not available "
                        "for active trigger type.");
        break;
    }

    if (attribute_id != VI_NULL)
    {
        checkErr (Ivi_GetAttributeViString (vi,
                                            VI_NULL,
                                            attribute_id,
                                            0,
                                            BUFFER_SIZE,
                                            buffer));
        checkErr (Ivi_SetValInStringCallback (vi, AGX2K3K_ATTR_TRIGGER_SOURCE, buffer));
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_TRIGGER_LEVEL -*/
static ViStatus _VI_FUNC agx2k3kAttrTriggerLevel_CheckCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   tSource[BUFFER_SIZE];
    ViReal64 vRange, vOffset;
    ViReal64 minLvl, maxLvl;

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL,
                                        AGX2K3K_ATTR_TRIGGER_SOURCE,
                                        0, BUFFER_SIZE, tSource));

    error = Ivi_CoerceChannelName (vi, tSource, VI_NULL);

    if (error < VI_SUCCESS && error != IVI_ERROR_UNKNOWN_CHANNEL_NAME)
        viCheckErr (error);

    if (error == IVI_ERROR_UNKNOWN_CHANNEL_NAME)
    {
        /*  source is not a channel - apply static range table */
        checkErr (Ivi_DefaultCheckCallbackViReal64 (vi, VI_NULL,
                                                    attributeId, value));
    }
    else
    {
        if (strstr (tSource, "DIG"))
        {
            minLvl = -5.0;
            maxLvl = 5.0;
        }
        else
        {
            checkErr (Ivi_GetAttributeViReal64 (vi, tSource,
                                                AGX2K3K_ATTR_VERTICAL_OFFSET,
                                                0, &vOffset));
            checkErr (Ivi_GetAttributeViReal64 (vi, tSource,
                                                AGX2K3K_ATTR_VERTICAL_RANGE,
                                                0, &vRange));

            /*   Calculate the minLvl and maxLvl here as function of */
            /*   vOffset and vRange, and check the range: */

            minLvl = -0.75 * vRange + vOffset;
            maxLvl = 0.75 * vRange + vOffset;
        }

        if ((value < minLvl) || (value > maxLvl))
            viCheckErr (IVI_ERROR_INVALID_VALUE);
    }

Error:
    return error;
}


static ViStatus _VI_FUNC agx2k3kAttrTriggerLevel_WriteCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  trigger_type;
    /* Default value for attribute_id */
    ViAttr   attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_LEVEL;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_TRIGGER_TYPE,
                                       0, &trigger_type));

    switch (trigger_type)
    {
    case AGX2K3K_VAL_GLITCH_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_LEVEL;
        break;

    case AGX2K3K_VAL_EDGE_TRIGGER:
    default:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_LEVEL;
        break;
    }

    checkErr (Ivi_SetAttributeViReal64 (vi, VI_NULL, attribute_id, 0, value));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrTriggerLevel_ReadCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViReal64 *value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  trigger_type;
    /* Default value for attribute_id */
    ViAttr   attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_LEVEL;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_TRIGGER_TYPE,
                                       0, &trigger_type));

    switch (trigger_type)
    {
    case AGX2K3K_VAL_EDGE_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_LEVEL;
        break;

    case AGX2K3K_VAL_GLITCH_TRIGGER:
        attribute_id = AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_LEVEL;
        break;

    default:
        viCheckErrElab (IVI_ERROR_INVALID_CONFIGURATION, "Trigger Source is not available "
                        "for active trigger type.");
        break;
    }

    checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL, attribute_id, 0, value));

Error:
    return error;
}

/*- AGX2K3K_ATTR_TRIGGER_HOLDOFF -*/
static IviRangeTableEntry attrTriggerHoldoffRangeTableEntries[] =
{
    { 60.0e-9, 10.00, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTriggerHoldoffRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrTriggerHoldoffRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrTriggerHoldoff_CoerceCallback (ViSession vi,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViReal64 value,
                                                                   ViReal64 *coercedValue)
{
    if ((value >= 0.0) && (value <= MIN_HOLDOFF_VALUE))
        *coercedValue = MIN_HOLDOFF_VALUE;
    else
        *coercedValue = value;

    return VI_SUCCESS;
}

/*- AGX2K3K_ATTR_TRIGGER_MODIFIER -*/
static IviRangeTableEntry attrTriggerModifierRangeTableEntries[] =
{
    { AGX2K3K_VAL_AUTO,           0, 0, "AUTO", 0 },
    { AGX2K3K_VAL_NO_TRIGGER_MOD, 0, 0, "NORM", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTriggerModifierRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTriggerModifierRangeTableEntries,
};

/*- AGX2K3K_ATTR_TRIGGER_COUPLING -*/
static IviRangeTableEntry attrTriggerCouplingRangeTableEntries[] =
{
    { AGX2K3K_VAL_AC,        0, 0, "AC",  0 },
    { AGX2K3K_VAL_DC,        0, 0, "DC",  0 },
    { AGX2K3K_VAL_LF_REJECT, 0, 0, "LFR", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTriggerCouplingRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTriggerCouplingRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrTriggerCoupling_CheckCallback (ViSession vi,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  triggerType;

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_TYPE,
                                       0, &triggerType));

    if (triggerType == AGX2K3K_VAL_TV_TRIGGER)
    {
        viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_TRIGGER_NOISE_REJECT -*/
/* Use common callback functions */


/*- AGX2K3K_ATTR_TRIGGER_HF_REJECT -*/
static ViStatus _VI_FUNC agx2k3kAttrTriggerHFReject_CheckCallback (ViSession vi,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViBoolean value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  triggerCoupling;

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_COUPLING,
                                       0, &triggerCoupling));

    if (triggerCoupling == AGX2K3K_VAL_LF_REJECT && value)
    {
        viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_TRIGGER_SLOPE -*/
static IviRangeTableEntry attrTriggerSlopeRangeTableEntries[] =
{         /* Discrete Value,           Not Used,  Not Used,    CmdString,  CmdVal  */
    { AGX2K3K_VAL_POSITIVE,  0, 0, "POS",  0 },
    { AGX2K3K_VAL_NEGATIVE,  0, 0, "NEG",  0 },
    { AGX2K3K_VAL_EITHER,    0, 0, "EITH", 0 },
    { AGX2K3K_VAL_ALTERNATE, 0, 0, "ALT",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTriggerSlopeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTriggerSlopeRangeTableEntries,
};

/*- AGX2K3K_ATTR_GLITCH_POLARITY -*/
static IviRangeTableEntry attrGlitchPolarityRangeTableEntries[] =
{
    { AGX2K3K_VAL_GLITCH_POSITIVE, 0, 0, "POS", 0 },
    { AGX2K3K_VAL_GLITCH_NEGATIVE, 0, 0, "NEG", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrGlitchPolarityRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrGlitchPolarityRangeTableEntries,
};

/*- AGX2K3K_ATTR_GLITCH_CONDITION -*/
static IviRangeTableEntry attrGlitchConditionRangeTableEntries[] =
{
    { AGX2K3K_VAL_GLITCH_LESS_THAN,    0, 0, "LESS", 0 },
    { AGX2K3K_VAL_GLITCH_GREATER_THAN, 0, 0, "GRE",  0 },
    { AGX2K3K_VAL_GLITCH_RANGE,        0, 0, "RANG", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrGlitchConditionRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrGlitchConditionRangeTableEntries,
};

/*- AGX2K3K_ATTR_GLITCH_MIN_WIDTH -*/
static IviRangeTableEntry attrMinimumPulseWidthRangeTableEntries[] =
{
    { 2.0e-9, 10.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrMinimumPulseWidthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrMinimumPulseWidthRangeTableEntries,
};

/*- AGX2K3K_ATTR_GLITCH_WIDTH -*/
static IviRangeTableEntry attrMaximumPulseWidthRangeTableEntries[] =
{
    { 6.0e-9, 10.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrMaximumPulseWidthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrMaximumPulseWidthRangeTableEntries,
};

/*- AGX2K3K_ATTR_GLITCH_RANGE -*/
static ViStatus _VI_FUNC agx2k3kAttrGlitchRange_CheckCallback (ViSession vi,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViReal64 greaterThanTime, lessThanTime;

    if (Ivi_RangeChecking (vi))
    {
        sscanf (value, "%Le, %Le", &greaterThanTime, &lessThanTime);

        if (greaterThanTime < 10.0e-9 || greaterThanTime > 9.99)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Greater Than Time (sec)");

        if (lessThanTime < 15.0e-9 || lessThanTime > 10.0)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Less Than Time (sec)");
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_PATTERN -*/
static ViStatus _VI_FUNC agx2k3kAttrPattern_CheckCallback (ViSession vi,
                                                           ViConstString channelName,
                                                           ViAttr attributeId,
                                                           ViConstString value)
{
    ViStatus error     = VI_SUCCESS;
    ViInt32  modelType = UNKNOWN;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       0, &modelType));

    if (IS_DSO_INSTR (modelType))
    {
        /*  Analog channels only */
        if (HAS_2CHANNELS (modelType))
        {
            viCheckErr (agx2k3k_CheckPattern (2, value));
        }
        else if (HAS_4CHANNELS (modelType))
        {
            viCheckErr (agx2k3k_CheckPattern (4, value));
        }
    }
    else if (IS_MSO_INSTR (modelType))
    {
        /*  Analog + digital channels */
        if (HAS_2CHANNELS (modelType))
        {
            viCheckErr (agx2k3k_CheckPattern (18, value));
        }
        else if (HAS_4CHANNELS (modelType))
        {
            viCheckErr (agx2k3k_CheckPattern (20, value));
        }
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrPattern_WriteCallback (ViSession vi,
                                                           ViSession io,
                                                           ViConstString channelName,
                                                           ViAttr attributeId,
                                                           ViConstString value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_SetAttributeViString (vi, channelName, AGX2K3K_ATTR_INSTR_TRIGGER_PATTERN, 0, value));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrPattern_ReadCallback (ViSession vi,
                                                          ViSession io,
                                                          ViConstString channelName,
                                                          ViAttr attributeId,
                                                          const ViConstString cacheValue)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_INSTR_TRIGGER_PATTERN, 0, BUFFER_SIZE, buffer));

    checkErr (Ivi_SetValInStringCallback (vi, attributeId, buffer));

Error:
    return error;
}

/*- AGX2K3K_ATTR_SBUS_CAN_BAUDRATE -*/
static IviRangeTableEntry attrCANBaudrateRangeTableEntries[] =
{
    { 10000, 1000000, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrCANBaudrateRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrCANBaudrateRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_CAN_SIGNAL -*/
static IviRangeTableEntry attrCANSignalRangeTableEntries[] =
{
    { AGX2K3K_VAL_CAN_SIGNAL_RX,           0, 0, "RX",   0 },
    { AGX2K3K_VAL_CAN_SIGNAL_TX,           0, 0, "TX",   0 },
    { AGX2K3K_VAL_CAN_SIGNAL_CAN_H,        0, 0, "CANH", 0 },
    { AGX2K3K_VAL_CAN_SIGNAL_CAN_L,        0, 0, "CANL", 0 },
    { AGX2K3K_VAL_CAN_SIGNAL_DIFFERENTIAL, 0, 0, "DIFF", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrCANSignalRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrCANSignalRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_CAN_TRIGGER -*/
static IviRangeTableEntry attrCANTriggerRangeTableEntries[] =
{
    { AGX2K3K_VAL_CAN_TRIGGER_SOF,        0, 0, "SOF",  0 },
    { AGX2K3K_VAL_CAN_TRIGGER_DATA,       0, 0, "DATA", 0 },
    { AGX2K3K_VAL_CAN_TRIGGER_ERROR,      0, 0, "ERR",  0 },
    { AGX2K3K_VAL_CAN_TRIGGER_IDDATA,     0, 0, "IDD",  0 },
    { AGX2K3K_VAL_CAN_TRIGGER_IDEITHER,   0, 0, "IDE",  0 },
    { AGX2K3K_VAL_CAN_TRIGGER_IDREMOTE,   0, 0, "IDR",  0 },
    { AGX2K3K_VAL_CAN_TRIGGER_ALL_ERRORS, 0, 0, "ALL",  0 },
    { AGX2K3K_VAL_CAN_TRIGGER_OVERLOAD,   0, 0, "OVER", 0 },
    { AGX2K3K_VAL_CAN_TRIGGER_ACK_ERROR,  0, 0, "ACK",  0 },
    { AGX2K3K_VAL_CAN_TRIGGER_EOF,        0, 0, "EOF",  0 }, /* 3TX &4X */
    { AGX2K3K_VAL_CAN_TRIGGER_FDDATA,     0, 0, "FDD",  0 },
    { AGX2K3K_VAL_CAN_TRIGGER_FORMERROR,  0, 0, "FORM", 0 },
    { AGX2K3K_VAL_CAN_TRIGGER_STUFFERROR, 0, 0, "STUF", 0 },
    { AGX2K3K_VAL_CAN_TRIGGER_CRCERROR,   0, 0, "CRC",  0 },
    { AGX2K3K_VAL_CAN_TRIGGER_SPECERROR,  0, 0, "SPEC", 0 },
    { AGX2K3K_VAL_CAN_TRIGGER_BRSBIT,     0, 0, "BRSB", 0 },
    { AGX2K3K_VAL_CAN_TRIGGER_CRCDBIT,    0, 0, "CRCD", 0 },
    { AGX2K3K_VAL_CAN_TRIGGER_EBACTIVE,   0, 0, "EBA",  0 },
    { AGX2K3K_VAL_CAN_TRIGGER_EBPASSIVE,  0, 0, "EBP",  0 },
    { AGX2K3K_VAL_CAN_TRIGGER_MESSAGE,    0, 0, "MESS", 0 },
    { AGX2K3K_VAL_CAN_TRIGGER_MSIGNAL,    0, 0, "MSIG", 0 },
    { AGX2K3K_VAL_CAN_TRIGGER_FDMSIGNAL,  0, 0, "FDMS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrCANTriggerRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrCANTriggerRangeTableEntries,
};

/* Serial Bus Source Check callback */
static ViStatus _VI_FUNC agx2k3kAttrSerialBusSource_CheckCallback (ViSession vi,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViConstString value)
{
    ViStatus error     = VI_SUCCESS;
    ViInt32  modelType = UNKNOWN;

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViInt32 (vi,
                                           VI_NULL,
                                           AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                           0, &modelType));

        if (IS_2000_SERIES (modelType))
        {
            viCheckErr (IVI_ERROR_INVALID_VALUE);
        }
        else if (IS_3000_SERIES (modelType) || IS_4000_SERIES (modelType) || IS_6000_SERIES (modelType))
        {
            if (IS_DSO_INSTR (modelType))
            {
                /* CHAN<n> + EXT */
                if (!strstr (value, "CHAN") && strcmp (value, "EXT") != 0)
                {
                    viCheckErr (IVI_ERROR_INVALID_VALUE);
                }
            }
            else if (IS_MSO_INSTR (modelType))
            {
                /* CHAN<n> + DIG<d> */
                if (!strstr (value, "CHAN") && !strstr (value, "DIG"))
                {
                    viCheckErr (IVI_ERROR_INVALID_VALUE);
                }
            }
        }
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_SBUS_CAN_SOURCE -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_SBUS_CAN_DATA -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_SBUS_CAN_DATA_LENGTH -*/
static IviRangeTableEntry attrCANDataLengthRangeTableEntries[] =
{
    { 1, 8, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrCANDataLengthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrCANDataLengthRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_CAN_ID -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_SBUS_CAN_ID_MODE -*/
static IviRangeTableEntry attrCANIdModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_CAN_ID_MODE_STANDARD, 0, 0, "STAN", 0 },
    { AGX2K3K_VAL_CAN_ID_MODE_EXTENDED, 0, 0, "EXT",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrCANIdModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrCANIdModeRangeTableEntries,
};


/* AGX2K3K_ATTR_SBUS_CAN_DISPLAY */
static IviRangeTableEntry attrSBusCANDisplayTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_CAN_DISPLAY_TYPE_HEXADECIMAL, 0, 0, "HEX",  0 },
    { AGX2K3K_VAL_SBUS_CAN_DISPLAY_TYPE_SYMBOLIC,    0, 0, "SYMB", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusCANDisplayTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusCANDisplayTypeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_CAN_FD_SAMPLE_POINT */
static IviRangeTableEntry attrSBusCANFDSamplePointRangeTableEntries[] =
{
    { 30, 90, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusCANFDSamplePointRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusCANFDSamplePointRangeTableEntries,
};
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_SBUS_CAN_SIGNAL_FD_BAUDRATE */
static IviRangeTableEntry attrSBusCANSignalFDBaudrateRangeTableEntries[] =
{
    { 10000, 10000000, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusCANSignalFDBaudrateRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusCANSignalFDBaudrateRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_SBUS_CAN_TRIGGER_IDFILTER_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_SBUS_CAN_TRIGGER_PATTERN_DATA_DLC */
static IviRangeTableEntry attrSBusCANTriggerPatternDataDlcRangeTableEntries[] =
{
    { -1, 64, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusCANTriggerPatternDataDlcRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusCANTriggerPatternDataDlcRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_SBUS_CAN_TRIGGER_PATTERN_DATA_START */
static IviRangeTableEntry attrSBusCANTriggerPatternDataStartRangeTableEntries[] =
{
    { 0, 63, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusCANTriggerPatternDataStartRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusCANTriggerPatternDataStartRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_MESSAGE */
/* use common read callback agx2k3kViQuotedString_ReadCallback */

/* use common write callback agx2k3kViQuotedString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_SIGNAL */
/* use common read callback agx2k3kViQuotedString_ReadCallback */

/* use common write callback agx2k3kViQuotedString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_VALUE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_SBUS_LIN_DISPLAY */
static IviRangeTableEntry attrSBusLINDisplayTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_LIN_DISPLAY_TYPE_HEXADECIMAL, 0, 0, "HEX",  0 },
    { AGX2K3K_VAL_SBUS_LIN_DISPLAY_TYPE_SYMBOLIC,    0, 0, "SYMB", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusLINDisplayTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusLINDisplayTypeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_FRAME */
/* use common read callback agx2k3kViQuotedString_ReadCallback */

/* use common write callback agx2k3kViQuotedString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_SIGNAL */
/* use common read callback agx2k3kViQuotedString_ReadCallback */

/* use common write callback agx2k3kViQuotedString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_VALUE */

/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_CLOCK */
static IviRangeTableEntry attrSBusSENTClockPeriodRangeTableEntries[] =
{
    { 1E-6, 300E-6, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTClockPeriodRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTClockPeriodRangeTableEntries,
};
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_CRC */
static IviRangeTableEntry attrSBusSENTCRCFormatRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_SENT_CRC_LEGACY,      0, 0, "LEG", 0 },
    { AGX2K3K_VAL_SBUS_SENT_CRC_RECOMMENDED, 0, 0, "REC", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTCRCFormatRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTCRCFormatRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_DISPLAY */
static IviRangeTableEntry attrSBusSENTDisplayBaseRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_SENT_DISPLAY_BASE_HEX,      0, 0, "HEX",  0 },
    { AGX2K3K_VAL_SBUS_SENT_DISPLAY_BASE_DECIMAL,  0, 0, "DEC",  0 },
    { AGX2K3K_VAL_SBUS_SENT_DISPLAY_BASE_SYMBOLIC, 0, 0, "SYMB", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTDisplayBaseRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTDisplayBaseRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_FORMAT */
static IviRangeTableEntry attrSBusSENTMessageFormatRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_SENT_MESSAGE_FORMAT_NIBBLES,  0, 0, "NIBB", 0 },
    { AGX2K3K_VAL_SBUS_SENT_MESSAGE_FORMAT_FSIGNAL,  0, 0, "FSIG", 0 },
    { AGX2K3K_VAL_SBUS_SENT_MESSAGE_FORMAT_FSSERIAL, 0, 0, "FSS",  0 },
    { AGX2K3K_VAL_SBUS_SENT_MESSAGE_FORMAT_FESERIAL, 0, 0, "FES",  0 },
    { AGX2K3K_VAL_SBUS_SENT_MESSAGE_FORMAT_SSERIAL,  0, 0, "SSER", 0 },
    { AGX2K3K_VAL_SBUS_SENT_MESSAGE_FORMAT_ESERIAL,  0, 0, "ESER", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTMessageFormatRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTMessageFormatRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_IDLE */
static IviRangeTableEntry attrSBusSENTIdleStateRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_SENT_IDLE_STATE_LOW,  0, 0, "LOW",  0 },
    { AGX2K3K_VAL_SBUS_SENT_IDLE_STATE_HIGH, 0, 0, "HIGH", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTIdleStateRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTIdleStateRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_LENGTH */
static IviRangeTableEntry attrSBusSENTLengthNibblesRangeTableEntries[] =
{
    { 1, 6, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTLengthNibblesRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTLengthNibblesRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_PPULSE_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME */
/* NULL callback */

/* AGX2K3K_ATTR_SBUS_SENT_SIGNAL_DISPLAY_ENABLED */
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsDisplayEnabled_ReadCallback (ViSession vi,
                                                                                ViSession io,
                                                                                ViConstString channelName,
                                                                                ViAttr attributeId,
                                                                                ViBoolean *value)
{
    ViStatus error = VI_SUCCESS;

    if (!Ivi_Simulating (vi))
    {
        ViChar rdBuffer[BUFFER_SIZE];
        checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                            0, BUFFER_SIZE, rdBuffer));
        viCheckErr (viQueryf (io, ":%s:SENT:%s:DISP?", "%hd", channelName, rdBuffer, value));
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsDisplayEnabled_WriteCallback (ViSession vi,
                                                                                 ViSession io,
                                                                                 ViConstString channelName,
                                                                                 ViAttr attributeId,
                                                                                 ViBoolean value)
{
    ViStatus error = VI_SUCCESS;

    if (!Ivi_Simulating (vi))
    {
        ViChar rdBuffer[BUFFER_SIZE];
        checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                            0, BUFFER_SIZE, rdBuffer));
        viCheckErr (viPrintf (io, ":%s:SENT:%s:DISP %d;", channelName, rdBuffer, value ? 1 : 0));
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_SENT_SIGNAL_LENGTH */
static IviRangeTableEntry attrSBusSENTSignalLengthRangeTableEntries[] =
{
    { 1, 24, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTSignalLengthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTSignalLengthRangeTableEntries,
};
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsLength_ReadCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViInt32 *value)
{
    ViStatus error = VI_SUCCESS;

    if (!Ivi_Simulating (vi))
    {
        ViChar rdBuffer[BUFFER_SIZE];
        checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                            0, BUFFER_SIZE, rdBuffer));
        viCheckErr (viQueryf (io, ":%s:SENT:%s:LENG?", "%d", channelName, rdBuffer, value));
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsLength_WriteCallback (ViSession vi,
                                                                         ViSession io,
                                                                         ViConstString channelName,
                                                                         ViAttr attributeId,
                                                                         ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                        0, BUFFER_SIZE, rdBuffer));
    if (!Ivi_Simulating (vi))
    {
        viCheckErr (viPrintf (io, ":%s:SENT:%s:LENG %d;", channelName, rdBuffer, value));
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_SENT_SIGNAL_MULTIPLIER */
static IviRangeTableEntry attrSBusSENTSignalMultiplierRangeTableEntries[] =
{
    { 1, 24, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTSignalMultiplierRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTSignalMultiplierRangeTableEntries,
};
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsMultiplier_ReadCallback (ViSession vi,
                                                                            ViSession io,
                                                                            ViConstString channelName,
                                                                            ViAttr attributeId,
                                                                            ViReal64 *value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                        0, BUFFER_SIZE, rdBuffer));
    if (!Ivi_Simulating (vi))
    {
        viCheckErr (viQueryf (io, ":%s:SENT:%s:MULT?", "%lf", channelName, rdBuffer, value));
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsMultiplier_WriteCallback (ViSession vi,
                                                                             ViSession io,
                                                                             ViConstString channelName,
                                                                             ViAttr attributeId,
                                                                             ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                        0, BUFFER_SIZE, rdBuffer));
    if (!Ivi_Simulating (vi))
    {
        viCheckErr (viPrintf (io, ":%s:SENT:%s:MULT %lf;", channelName, rdBuffer, value));
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_SENT_SIGNAL_OFFSET */
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsOffset_ReadCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViReal64 *value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                        0, BUFFER_SIZE, rdBuffer));
    if (!Ivi_Simulating (vi))
    {
        viCheckErr (viQueryf (io, ":%s:SENT:%s:OFFS?", "%lf", channelName, rdBuffer, value));
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsOffset_WriteCallback (ViSession vi,
                                                                         ViSession io,
                                                                         ViConstString channelName,
                                                                         ViAttr attributeId,
                                                                         ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                        0, BUFFER_SIZE, rdBuffer));
    if (!Ivi_Simulating (vi))
    {
        viCheckErr (viPrintf (io, ":%s:SENT:%s:OFFS %lf;", channelName, rdBuffer, value));
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_SENT_SIGNAL_ORDER */
static IviRangeTableEntry attrSBusSENTSignalOrderRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_SENT_SIGNAL_ORDER_MSNFIRST, 0, 0, "MSNF", 0 },
    { AGX2K3K_VAL_SBUS_SENT_SIGNAL_ORDER_LSNFIRST, 0, 0, "LSNF", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTSignalOrderRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTSignalOrderRangeTableEntries,
};
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsOrder_ReadCallback (ViSession vi,
                                                                       ViSession io,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViInt32 *value)
{
    ViStatus         error = VI_SUCCESS;

    IviRangeTablePtr table;

    ViChar           rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                        0, BUFFER_SIZE, rdBuffer));
    checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &table));

    if (!Ivi_Simulating (vi))
    {
        ViChar buffer[BUFFER_SIZE];
        size_t buffer_size = sizeof (buffer);

        if (channelName != VI_NULL)
        {
            sprintf (buffer, ":%s:SENT:%s:ORD", channelName, rdBuffer);
            error = viPrintf (io, "%s?", buffer);
        }

        viCheckErr (error);

        viCheckErr (viScanf (io, "%#s", &buffer_size, buffer));
        viCheckErr (agx2k3k_GetValueFromCmd (buffer, table, value));
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsOrder_WriteCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViInt32 value)
{
    ViStatus         error = VI_SUCCESS;

    ViString         command_value;
    IviRangeTablePtr table;

    ViChar           rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                        0, BUFFER_SIZE, rdBuffer));

    checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &table));
    viCheckErr (agx2k3k_GetCmdFromIntValue (value, table, &command_value));


    if (!Ivi_Simulating (vi))
    {
        if (strlen (command_value) != 0)
        {
            if (channelName != VI_NULL)
            {
                ViChar buffer[BUFFER_SIZE];

                sprintf (buffer, ":%s:SENT:%s:ORD ", channelName, rdBuffer);

                error = viPrintf (io, "%s %s", buffer, command_value);
            }
            viCheckErr (error);
        }
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_SENT_SIGNAL_START */
static IviRangeTableEntry attrSBusSENTSignalStartRangeTableEntries[] =
{
    { 0, 23, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTSignalStartRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTSignalStartRangeTableEntries,
};
static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsStart_ReadCallback (ViSession vi,
                                                                       ViSession io,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViInt32 *value)
{
    ViStatus error = VI_SUCCESS;

    ViChar   rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                        0, BUFFER_SIZE, rdBuffer));
    if (!Ivi_Simulating (vi))
    {
        viCheckErr (viQueryf (io, ":%s:SENT:%s:STAR?", "%d", channelName, rdBuffer, value));
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrSbusSentSignalsStart_WriteCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                        0, BUFFER_SIZE, rdBuffer));
    if (!Ivi_Simulating (vi))
    {
        viCheckErr (viPrintf (io, ":%s:SENT:%s:STAR %d;", channelName, rdBuffer, value));
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_SENT_TRIGGER_TOLERANCE */
static IviRangeTableEntry attrSBusSENTTriggerTolerancePercentRangeTableEntries[] =
{
    { 1, 18, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTTriggerTolerancePercentRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTTriggerTolerancePercentRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_LENGTH */
static IviRangeTableEntry attrSBusSENTTriggerSlowLengthRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_SLOW_LENGTH_SHORT, 0, 0, "SHOR", 0 },
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_SLOW_LENGTH_LONG,  0, 0, "LONG", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTTriggerSlowLengthRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTTriggerSlowLengthRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_TRIGGER */

static IviRangeTableEntry attrSBusSENTTriggerModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_MODE_SFCMESSAGE, 0, 0, "SFCM", 0 },
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_MODE_SSCMESSAGE, 0, 0, "SSCM", 0 },
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_MODE_FCDATA,     0, 0, "FCD",  0 },
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_MODE_SCMID,      0, 0, "SCM",  0 },
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_MODE_SCDATA,     0, 0, "SCD",  0 },
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_MODE_TOLERROR,   0, 0, "TOL",  0 },
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_MODE_FCCERROR,   0, 0, "FCC",  0 },
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_MODE_SCCERROR,   0, 0, "SCC",  0 },
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_MODE_CRCERROR,   0, 0, "CRC",  0 },
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_MODE_PPERROR,    0, 0, "PPER", 0 },
    { AGX2K3K_VAL_SBUS_SENT_TRIGGER_MODE_SSPERROR,   0, 0, "SSP",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTTriggerModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTTriggerModeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_TOLERANCE */
static IviRangeTableEntry attrSBusSENTTolerancePercentRangeTableEntries[] =
{
    { 3, 30, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTTolerancePercentRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTTolerancePercentRangeTableEntries,
};

/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_SOURCE */
static IviRangeTableEntry attrSBusSENTSourceRangeTable_2ChannelsEntries[] =
{
    { AGX2K3K_VAL_SBUS_SENT_SOURCE_CHANNEL1, 0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_SBUS_SENT_SOURCE_CHANNEL2, 0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_SBUS_SENT_SOURCE_DIGITAL0, 0, 0, "DIG0",  0 },
    { AGX2K3K_VAL_SBUS_SENT_SOURCE_DIGITAL1, 0, 0, "DIG1",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable      attrSBusSENTSourceRangeTable_2Channels =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTSourceRangeTable_2ChannelsEntries,
};
static IviRangeTableEntry attrSBusSENTSourceRangeTable_4ChannelsEntries[] =
{
    { AGX2K3K_VAL_SBUS_SENT_SOURCE_CHANNEL1, 0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_SBUS_SENT_SOURCE_CHANNEL2, 0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_SBUS_SENT_SOURCE_CHANNEL3, 0, 0, "CHAN3", 0 },
    { AGX2K3K_VAL_SBUS_SENT_SOURCE_CHANNEL4, 0, 0, "CHAN4", 0 },
    { AGX2K3K_VAL_SBUS_SENT_SOURCE_DIGITAL0, 0, 0, "DIG0",  0 },
    { AGX2K3K_VAL_SBUS_SENT_SOURCE_DIGITAL1, 0, 0, "DIG1",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTSourceRangeTable_4Channels =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTSourceRangeTable_4ChannelsEntries,
};
static ViStatus _VI_FUNC agx2k3kAttrSBusSENTSource_RangeTableCallback (ViSession vi,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       IviRangeTablePtr *rangeTablePtr)
{
    ViStatus         error  = VI_SUCCESS;
    IviRangeTablePtr tblPtr = VI_NULL;

    ViInt32          modelType = UNKNOWN;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       0, &modelType));

    if (HAS_2CHANNELS (modelType))
    {
        tblPtr = &attrSBusSENTSourceRangeTable_2Channels;
    }
    else if (HAS_4CHANNELS (modelType))
    {
        tblPtr = &attrSBusSENTSourceRangeTable_4Channels;
    }

Error:
    *rangeTablePtr = tblPtr;
    return error;
}

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_TRIGGER_FAST_DATA */
/* use common read callback agx2k3kViQuotedString_ReadCallback */

/* use common write callback agx2k3kViQuotedString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_DATA */
static IviRangeTableEntry attrSBusSENTTriggerSlowDataLongRangeTableEntries[] =
{
    { -1, 4095, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTTriggerSlowDataLongRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTTriggerSlowDataLongRangeTableEntries,
};

static IviRangeTableEntry attrSBusSENTTriggerSlowDataShortRangeTableEntries[] =
{
    { -1, 65535, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTTriggerSlowDataShortRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTTriggerSlowDataShortRangeTableEntries,
};
static ViStatus _VI_FUNC agx2k3kAttrSBusSENTTriggerSLOWData_RangeTableCallback (ViSession vi,
                                                                                ViConstString channelName,
                                                                                ViAttr attributeId,
                                                                                IviRangeTablePtr *rangeTablePtr)
{
    ViStatus         error      = VI_SUCCESS;
    IviRangeTablePtr tblPtr     = VI_NULL;
    ViInt32          slowLength = 0;

    if (Ivi_RangeChecking (vi))
    {
        if (channelName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (channelName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    checkErr (Ivi_GetAttributeViInt32 (vi, channelName, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_LENGTH,
                                       0, &slowLength));
    if (slowLength == AGX2K3K_VAL_SBUS_SENT_TRIGGER_SLOW_LENGTH_SHORT)
    {
        tblPtr = &attrSBusSENTTriggerSlowDataShortRangeTable;
    }
    else   /* AGX2K3K_VAL_SBUS_SENT_TRIGGER_SLOW_LENGTH_LONG */
    {
        tblPtr = &attrSBusSENTTriggerSlowDataLongRangeTable;
    }

Error:
    *rangeTablePtr = tblPtr;
    return error;
}



/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_ID */
static IviRangeTableEntry attrSBusSENTTriggerSlowIDLongRangeTableEntries[] =
{
    { -1, 255, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTTriggerSlowIDLongRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTTriggerSlowIDLongRangeTableEntries,
};

static IviRangeTableEntry attrSBusSENTTriggerSlowIDShortRangeTableEntries[] =
{
    { -1, 15, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSBusSENTTriggerSlowIDShortRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSBusSENTTriggerSlowIDShortRangeTableEntries,
};
static ViStatus _VI_FUNC agx2k3kAttrSBusSENTTriggerSLOWID_RangeTableCallback (ViSession vi,
                                                                              ViConstString channelName,
                                                                              ViAttr attributeId,
                                                                              IviRangeTablePtr *rangeTablePtr)
{
    ViStatus         error      = VI_SUCCESS;
    IviRangeTablePtr tblPtr     = VI_NULL;
    ViInt32          slowLength = 0;

    if (Ivi_RangeChecking (vi))
    {
        if (channelName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (channelName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    checkErr (Ivi_GetAttributeViInt32 (vi, channelName, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_LENGTH,
                                       0, &slowLength));
    if (slowLength == AGX2K3K_VAL_SBUS_SENT_TRIGGER_SLOW_LENGTH_SHORT)
    {
        tblPtr = &attrSBusSENTTriggerSlowIDShortRangeTable;
    }
    else   /* AGX2K3K_VAL_SBUS_SENT_TRIGGER_SLOW_LENGTH_LONG */
    {
        tblPtr = &attrSBusSENTTriggerSlowIDLongRangeTable;
    }

Error:
    *rangeTablePtr = tblPtr;
    return error;
}
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */



/*- AGX2K3K_ATTR_PATTERN_QUALIFIER -*/
static IviRangeTableEntry attrPatternQualifierRangeTableEntries[] =
{
    { AGX2K3K_VAL_PATTERN_ENTERED,     0, 0, "ENT",  0 },
    { AGX2K3K_VAL_PATTERN_GREATERTHAN, 0, 0, "GRE",  0 },
    { AGX2K3K_VAL_PATTERN_LESSTHAN,    0, 0, "LESS", 0 },
    { AGX2K3K_VAL_PATTERN_INRANGE,     0, 0, "INR",  0 },
    { AGX2K3K_VAL_PATTERN_OUTRANGE,    0, 0, "OUTR", 0 },
    { AGX2K3K_VAL_PATTERN_TIMEOUT,     0, 0, "TIM",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrPatternQualifierRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    "",
    attrPatternQualifierRangeTableEntries,
};

/*- AGX2K3K_ATTR_PATTERN_MIN -*/
static IviRangeTableEntry attrMinimumPatternRangeTableEntries[] =
{
    { 5.0e-9, 10.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrMinimumPatternRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrMinimumPatternRangeTableEntries,
};

/*- AGX2K3K_ATTR_PATTERN_MAX -*/
static IviRangeTableEntry attrMaximumPatternRangeTableEntries[] =
{
    { 5.0e-9, 10.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrMaximumPatternRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrMaximumPatternRangeTableEntries,
};

/*- AGX2K3K_ATTR_PATTERN_RANGE -*/
static ViStatus _VI_FUNC agx2k3kAttrPatternRange_CheckCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViReal64 greaterThanTime, lessThanTime;

    if (Ivi_RangeChecking (vi))
    {
        sscanf (value, "%Le, %Le", &greaterThanTime, &lessThanTime);

        if (greaterThanTime < 10.0e-9 || greaterThanTime > 9.99)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Greater Than Time (sec)");

        if (lessThanTime < 15.0e-9 || lessThanTime > 10.0)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Less Than Time (sec)");
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_SBUS_IIC_SCL -*/
/* User common callback functions */

/*- AGX2K3K_ATTR_SBUS_IIC_SDA -*/
static ViStatus _VI_FUNC agx2k3kAttrIICSda_CheckCallback (ViSession vi,
                                                          ViConstString channelName,
                                                          ViAttr attributeId,
                                                          ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    checkErr (agx2k3kAttrSerialBusSource_CheckCallback (vi,
                                                        channelName,
                                                        attributeId,
                                                        value));

    checkErr (Ivi_GetAttributeViString (vi,
                                        channelName,
                                        AGX2K3K_ATTR_SBUS_IIC_SCL,
                                        0,
                                        BUFFER_SIZE,
                                        buffer));

    if (!strcmp (value, buffer))
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Incorrect value.");
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_SBUS_IIC_TYPE -*/
static IviRangeTableEntry attrIICTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_IIC_TYPE_START,        0, 0, "STAR",   0 },
    { AGX2K3K_VAL_IIC_TYPE_STOP,         0, 0, "STOP",   0 },
    { AGX2K3K_VAL_IIC_TYPE_NACK,         0, 0, "NACK",   0 },
    { AGX2K3K_VAL_IIC_TYPE_RESTART,      0, 0, "REST",   0 },
    { AGX2K3K_VAL_IIC_TYPE_READEEPROM,   0, 0, "READE",  0 },
    { AGX2K3K_VAL_IIC_TYPE_READ7,        0, 0, "READ7",  0 },
    { AGX2K3K_VAL_IIC_TYPE_WRITE7,       0, 0, "WRIT7",  0 },
    { AGX2K3K_VAL_IIC_TYPE_WRITE10,      0, 0, "WRIT10", 0 },
    { AGX2K3K_VAL_IIC_TYPE_READ7_DATA2,  0, 0, "R7D2",   0 },
    { AGX2K3K_VAL_IIC_TYPE_WRITE7_DATA2, 0, 0, "W7D2",   0 },
    { AGX2K3K_VAL_IIC_TYPE_ADDRESS_NACK, 0, 0, "ANAC",   0 },
    { AGX2K3K_VAL_IIC_TYPE_ADDRESS,      0, 0, "ADDR",   0 },
    { AGX2K3K_VAL_IIC_TYPE_WRITE_NACK,   0, 0, "DNAC",   0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrIICTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrIICTypeRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_IIC_QUALIFIER -*/
static IviRangeTableEntry attrIICQualifierRangeTableEntries[] =
{
    { AGX2K3K_VAL_IIC_QUALIFIER_EQUAL,       0, 0, "EQU",  0 },
    { AGX2K3K_VAL_IIC_QUALIFIER_NEQUAL,      0, 0, "NOT",  0 },
    { AGX2K3K_VAL_IIC_QUALIFIER_LESSTHAN,    0, 0, "LESS", 0 },
    { AGX2K3K_VAL_IIC_QUALIFIER_GREATERTHAN, 0, 0, "GRE",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrIICQualifierRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrIICQualifierRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrIICQualifier_CheckCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  type;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       channelName,
                                       AGX2K3K_ATTR_SBUS_IIC_TYPE,
                                       0, &type));

    if (type != AGX2K3K_VAL_IIC_TYPE_READEEPROM)
        viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);

    checkErr (Ivi_DefaultCheckCallbackViInt32 (vi, channelName, attributeId, value));

Error:
    return error;
}

/*- AGX2K3K_ATTR_SBUS_IIC_ADDRESS -*/
static ViStatus _VI_FUNC agx2k3kAttrIICAddress_CheckCallback (ViSession vi,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  type;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       channelName,
                                       AGX2K3K_ATTR_SBUS_IIC_TYPE,
                                       0, &type));

    if (type == AGX2K3K_VAL_IIC_TYPE_WRITE10)
    {
        if ((value < 0x00 || value > 0x3FF) && (value != -1 || value != 0xFFFFFFFF))
            viCheckErr (IVI_ERROR_INVALID_PARAMETER);
    }
    else
    {
        if ((value < 0x00 || value > 0x7F) && (value != -1 || value != 0xFFFFFFFF))
            viCheckErr (IVI_ERROR_INVALID_PARAMETER);
    }

    checkErr (Ivi_DefaultCheckCallbackViInt32 (vi, channelName, attributeId, value));

Error:
    return error;
}

/*- AGX2K3K_ATTR_SBUS_IIC_DATA -*/
/*- AGX2K3K_ATTR_SBUS_IIC_DATA2 -*/
static IviRangeTableEntry attrIICDataRangeTableEntries[] =
{
    { -1, 255, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrIICDataRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrIICDataRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_IIC_SIZE -*/
static IviRangeTableEntry attrIICSizeRangeTableEntries[] =
{
    { AGX2K3K_VAL_IIC_SIZE_BIT7, 0, 0, "BIT7", 0 },
    { AGX2K3K_VAL_IIC_SIZE_BIT8, 0, 0, "BIT8", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrIICSizeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrIICSizeRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_I2S_ALIGNMENT */
static IviRangeTableEntry attrI2SAlignmentRangeTableEntries[] =
{
    { AGX2K3K_VAL_I2S_ALIGNMENT_I2S, 0, 0, "I2S", 0 },
    { AGX2K3K_VAL_I2S_ALIGNMENT_LJ,  0, 0, "LJ",  0 },
    { AGX2K3K_VAL_I2S_ALIGNMENT_RJ,  0, 0, "RJ",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrI2SAlignmentRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrI2SAlignmentRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_I2S_CLOCK_SLOPE */
static IviRangeTableEntry attrI2SClockSlopeRangeTableEntries[] =
{
    { AGX2K3K_VAL_I2S_CLOCK_SLOPE_NEGATIVE, 0, 0, "NEG", 0 },
    { AGX2K3K_VAL_I2S_CLOCK_SLOPE_POSITIVE, 0, 0, "POS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrI2SClockSlopeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrI2SClockSlopeRangeTableEntries,
};


/* AGX2K3K_ATTR_SBUS_I2S_RECEIVER_WIDTH */
/* AGX2K3K_ATTR_SBUS_I2S_TRANSMIT_WIDTH */
static IviRangeTableEntry attrI2SRxTxWidthRangeTableEntries[] =
{
    { 4, 32, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrI2SRxTxWidthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrI2SRxTxWidthRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_I2S_SOURCE_CLOCK */
/* Use common callback functions */

/* AGX2K3K_ATTR_SBUS_I2S_SOURCE_WS */
static ViStatus _VI_FUNC agx2k3kAttrI2SWSSource_CheckCallback (ViSession vi,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   clksource[BUFFER_SIZE];

    checkErr (agx2k3kAttrSerialBusSource_CheckCallback (vi,
                                                        channelName,
                                                        attributeId,
                                                        value));

    checkErr (Ivi_GetAttributeViString (vi,
                                        channelName,
                                        AGX2K3K_ATTR_SBUS_I2S_SOURCE_CLOCK,
                                        0,
                                        BUFFER_SIZE,
                                        clksource));

    if (!strcmp (value, clksource))
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Incorrect value.");
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_I2S_SOURCE_DATA */
static ViStatus _VI_FUNC agx2k3kAttrI2SDataSource_CheckCallback (ViSession vi,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   clksource[BUFFER_SIZE];
    ViChar   fsource[BUFFER_SIZE];

    checkErr (agx2k3kAttrSerialBusSource_CheckCallback (vi,
                                                        channelName,
                                                        attributeId,
                                                        value));

    checkErr (Ivi_GetAttributeViString (vi,
                                        channelName,
                                        AGX2K3K_ATTR_SBUS_I2S_SOURCE_CLOCK,
                                        0,
                                        BUFFER_SIZE,
                                        clksource));

    checkErr (Ivi_GetAttributeViString (vi,
                                        channelName,
                                        AGX2K3K_ATTR_SBUS_I2S_SOURCE_WS,
                                        0,
                                        BUFFER_SIZE,
                                        fsource));

    if (!strcmp (value, clksource) || !strcmp (value, fsource))
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Incorrect value.");
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_I2S_TRIGGER */
static IviRangeTableEntry attrI2STriggerRangeTableEntries[] =
{
    { AGX2K3K_VAL_I2S_TRIGGER_EQUAL,     0, 0, "EQU",  0 },
    { AGX2K3K_VAL_I2S_TRIGGER_NOT_EQUAL, 0, 0, "NOT",  0 },
    { AGX2K3K_VAL_I2S_TRIGGER_LESS,      0, 0, "LESS", 0 },
    { AGX2K3K_VAL_I2S_TRIGGER_GREATER,   0, 0, "GRE",  0 },
    { AGX2K3K_VAL_I2S_TRIGGER_IN_RANGE,  0, 0, "INR",  0 },
    { AGX2K3K_VAL_I2S_TRIGGER_OUT_RANGE, 0, 0, "OUTR", 0 },
    { AGX2K3K_VAL_I2S_TRIGGER_INCREASE,  0, 0, "INCR", 0 },
    { AGX2K3K_VAL_I2S_TRIGGER_DECREASE,  0, 0, "DECR", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrI2STriggerRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrI2STriggerRangeTableEntries,
};


/* AGX2K3K_ATTR_SBUS_I2S_TRIGGER_AUDIO */
static IviRangeTableEntry attrI2STriggerAudioRangeTableEntries[] =
{
    { AGX2K3K_VAL_I2S_TRIGGER_AUDIO_RIGHT,  0, 0, "RIGH", 0 },
    { AGX2K3K_VAL_I2S_TRIGGER_AUDIO_LEFT,   0, 0, "LEFT", 0 },
    { AGX2K3K_VAL_I2S_TRIGGER_AUDIO_EITHER, 0, 0, "EITH", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrI2STriggerAudioRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrI2STriggerAudioRangeTableEntries,
};



/* AGX2K3K_ATTR_SBUS_I2S_TRIGGER_DATA */
static ViStatus _VI_FUNC agx2k3kAttrI2STriggerData_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViString command;

    viCheckErr (Ivi_GetStringFromTable (gs_ViStringCommands, attributeId, &command));

    if (!Ivi_Simulating (vi))
    {
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];
            viCheckErr (viPrintf (io, ":%s:I2S:TRIG:PATT:FORM BIN", channelName));
            sprintf (buffer, command, channelName);
            error = viPrintf (io, "%s \"%s\"", buffer, value);
        }
        viCheckErr (error);
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW */
/* AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH */
static ViStatus _VI_FUNC agx2k3kAttrI2STriggerRange_CheckCallback (ViSession vi,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViInt32 value)
{
    ViStatus error    = VI_SUCCESS;
    ViInt32  rwidth   = 0;
    ViInt32  twidth   = 0;
    ViInt32  minWidth = 0;
    ViUInt32 mask     = 0xFFFFFFFF;


    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       channelName,
                                       AGX2K3K_ATTR_SBUS_I2S_RECEIVER_WIDTH,
                                       VI_NULL,
                                       &rwidth));
    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       channelName,
                                       AGX2K3K_ATTR_SBUS_I2S_TRANSMIT_WIDTH,
                                       VI_NULL,
                                       &twidth));

    minWidth = rwidth < twidth ? rwidth : twidth;

    /*  Left shift the 0xFFFFFFFF minWidth bits to 0x111...111000...00 */
    mask = mask << minWidth;

    /*  Check whether the value is in the range of bit width. */
    if (value > 0)
    {
        if ((value & mask))
        {
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Incorrect value.");
        }
    }
    else
    {
        if (((~value) & mask))
        {
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Incorrect value.");
        }
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrI2STriggerRange_ReadCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViInt32* value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;
    ViInt32  lowRange = 0, highRange = 0;

    viCheckErr (Ivi_GetStringFromTable (gs_ViInt32Commands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        /*
         * If the channelName is not NULL pointer, attribute is
         * channel based.
         */
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];

            sprintf (buffer, cmd, channelName);

            error = viQueryf (io, "%s?", "%ld,%ld", buffer, &lowRange, &highRange);
        }
        else
        {
            error = viQueryf (io, "%s?", "%ld,%ld", cmd, &lowRange, &highRange);
        }
        viCheckErr (error);
    }

    if (attributeId == AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW)
    {
        *value = lowRange;

        viCheckErr (Ivi_SetAttributeViInt32 (vi,
                                             channelName,
                                             AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH,
                                             IVI_VAL_SET_CACHE_ONLY,
                                             highRange));
    }
    else if (attributeId == AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH)
    {
        *value = highRange;

        viCheckErr (Ivi_SetAttributeViInt32 (vi,
                                             channelName,
                                             AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW,
                                             IVI_VAL_SET_CACHE_ONLY,
                                             lowRange));
    }
Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrI2STriggerRange_WriteCallback (ViSession vi,
                                                                   ViSession io,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;
    ViInt32  lowRange = 0, highRange = 0;

    viCheckErr (Ivi_GetStringFromTable (gs_ViInt32Commands, attributeId, &cmd));
    if (attributeId == AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW)
    {
        lowRange = value;

        viCheckErr (Ivi_GetAttributeViInt32 (vi,
                                             channelName,
                                             AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH,
                                             VI_NULL,
                                             &highRange));
    }
    else if (attributeId == AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH)
    {
        highRange = value;

        viCheckErr (Ivi_GetAttributeViInt32 (vi,
                                             channelName,
                                             AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW,
                                             VI_NULL,
                                             &lowRange));
    }

    if (!Ivi_Simulating (vi))
    {
        /*
         * If the channelName is not NULL pointer, attribute is
         * channel based.
         */
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];

            sprintf (buffer, cmd, channelName);

            error = viPrintf (io, "%s %ld,%ld", buffer, lowRange, highRange);
        }
        else
        {
            error = viPrintf (io, "%s %ld,%ld", cmd, lowRange, highRange);
        }
        viCheckErr (error);
    }
Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_I2S_WS_LOW */
static IviRangeTableEntry attrI2SWSLowRangeTableEntries[] =
{
    { AGX2K3K_VAL_I2S_WS_LOW_LEFT,  0, 0, "LEFT", 0 },
    { AGX2K3K_VAL_I2S_WS_LOW_RIGHT, 0, 0, "RIGH", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrI2SWSLowRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrI2SWSLowRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_UART_BAUDRATE */
static IviRangeTableEntry attrUARTBaudrateRangeTableEntries[] =
{
    { 1200, 8000000, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUARTBaudrateRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrUARTBaudrateRangeTableEntries,
};


/* AGX2K3K_ATTR_SBUS_UART_BIT_ORDER */
static IviRangeTableEntry attrUARTBitOrderRangeTableEntries[] =
{
    { AGX2K3K_VAL_UART_BIT_ORDER_LSB_FIRST, 0, 0, "LSBF", 0 },
    { AGX2K3K_VAL_UART_BIT_ORDER_MSB_FIRST, 0, 0, "MSBF", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUARTBitOrderRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrUARTBitOrderRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_UART_COUNT_RESET */
static ViStatus _VI_FUNC agx2k3kAttrUARTCountReset_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViBoolean value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    viCheckErr (Ivi_GetStringFromTable (gs_ViBooleanCommands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        if ((channelName != VI_NULL) && (value == VI_TRUE))
        {
            ViChar buffer[BUFFER_SIZE];
            sprintf (buffer, cmd, channelName);
            error = viPrintf (io, "%s", buffer);
        }
        viCheckErr (error);
    }
Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_UART_COUNT_ERROR */
/* Use common callback functions */

/* AGX2K3K_ATTR_SBUS_UART_COUNT_TX */
/* Use common callback functions */

/* AGX2K3K_ATTR_SBUS_UART_COUNT_RX */
/* Use common callback functions */

/* AGX2K3K_ATTR_SBUS_UART_FRAMING */
static IviRangeTableEntry attrUARTFramingRangeTableEntries[] =
{
    { -1, 255, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUARTFramingRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrUARTFramingRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrUARTFraming_ReadCallback (ViSession vi,
                                                              ViSession io,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViInt32*        value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;


    viCheckErr (Ivi_GetStringFromTable (gs_ViInt32Commands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];
            ViChar retBuffer[BUFFER_SIZE];

            sprintf (buffer, cmd, channelName);

            error = viQueryf (io, "%s?", "%s", buffer, retBuffer);

            /*  Check whether the return value is an integer or not */
            if (strncmp (retBuffer, "OFF", 3) == 0)
            {
                *value = -1;
            }
            else
            {
                *value = atoi (retBuffer);
            }
        }
        viCheckErr (error);
    }
Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrUARTFraming_WriteCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    viCheckErr (Ivi_GetStringFromTable (gs_ViInt32Commands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        /*
         * If the channelName is not NULL pointer, attribute is
         * channel based.
         */
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];

            sprintf (buffer, cmd, channelName);

            if (value == -1)
            {
                error = viPrintf (io, "%s OFF", buffer);
            }
            else
            {
                error = viPrintf (io, "%s %ld", buffer, value);
            }
        }
        viCheckErr (error);
    }
Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_UART_PARITY */
static IviRangeTableEntry attrUARTParityRangeTableEntries[] =
{
    { AGX2K3K_VAL_UART_PARITY_EVEN, 0, 0, "EVEN", 0 },
    { AGX2K3K_VAL_UART_PARITY_ODD,  0, 0, "ODD",  0 },
    { AGX2K3K_VAL_UART_PARITY_NONE, 0, 0, "NONE", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUARTParityRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrUARTParityRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_UART_POLARITY */
static IviRangeTableEntry attrUARTPolarityRangeTableEntries[] =
{
    { AGX2K3K_VAL_UART_POLARITY_HIGH, 0, 0, "HIGH", 0 },
    { AGX2K3K_VAL_UART_POLARITY_LOW,  0, 0, "LOW",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUARTPolarityRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrUARTPolarityRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_UART_SOURCE_RX */
/* Use common callback functions */

/* AGX2K3K_ATTR_SBUS_UART_SOURCE_TX */
static ViStatus _VI_FUNC agx2k3kAttrUARTSourceTx_CheckCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rxsource[BUFFER_SIZE];

    checkErr (agx2k3kAttrSerialBusSource_CheckCallback (vi,
                                                        channelName,
                                                        attributeId,
                                                        value));

    checkErr (Ivi_GetAttributeViString (vi,
                                        channelName,
                                        AGX2K3K_ATTR_SBUS_UART_SOURCE_RX,
                                        0,
                                        BUFFER_SIZE,
                                        rxsource));

    if (!strcmp (value, rxsource))
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Incorrect value.");
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_UART_TRIGGER_BURST */
static IviRangeTableEntry attrUARTTriggerBurstRangeTableEntries[] =
{
    { -1, 4096, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUARTTriggerBurstRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrUARTTriggerBurstRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrUARTTriggerBurst_ReadCallback (ViSession vi,
                                                                   ViSession io,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViInt32*        value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;


    viCheckErr (Ivi_GetStringFromTable (gs_ViInt32Commands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];
            ViChar retBuffer[BUFFER_SIZE];

            sprintf (buffer, cmd, channelName);

            error = viQueryf (io, "%s?", "%s", buffer, retBuffer);

            /*  Check whether the return value is an integer or not */
            if (strncmp (retBuffer, "OFF", 3) == 0)
            {
                *value = -1;
            }
            else
            {
                *value = atoi (retBuffer);
            }
        }
        viCheckErr (error);
    }
Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrUARTTriggerBurst_WriteCallback (ViSession vi,
                                                                    ViSession io,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    viCheckErr (Ivi_GetStringFromTable (gs_ViInt32Commands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        /*
         * If the channelName is not NULL pointer, attribute is
         * channel based.
         */
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];

            sprintf (buffer, cmd, channelName);

            if (value == -1)
            {
                error = viPrintf (io, "%s OFF", buffer);
            }
            else
            {
                error = viPrintf (io, "%s %ld", buffer, value);
            }
        }
        viCheckErr (error);
    }
Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrUARTTriggerBurst_CheckCallback (ViSession vi,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViInt32 value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_DefaultCheckCallbackViInt32 (vi, channelName, attributeId, value));

    if (value == 0)
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Incorrect value.");
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SBUS_UART_TRIGGER_DATA */
static IviRangeTableEntry attrUARTTriggerDataRangeTableEntries[] =
{
    { 0, 255, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUARTTriggerDataRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrUARTTriggerDataRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_UART_TRIGGER_IDLE */
static IviRangeTableEntry attrUARTTriggerIdleRangeTableEntries[] =
{
    { 1E-6, 10.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUARTTriggerIdleRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrUARTTriggerIdleRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_UART_TRIGGER_QUALIFIER */
static IviRangeTableEntry attrUARTQualifierRangeTableEntries[] =
{
    { AGX2K3K_VAL_UART_TRIGGER_QUALIFIER_EQUAL,     0, 0, "EQU",  0 },
    { AGX2K3K_VAL_UART_TRIGGER_QUALIFIER_NOT_EQUAL, 0, 0, "NOT",  0 },
    { AGX2K3K_VAL_UART_TRIGGER_QUALIFIER_GREATER,   0, 0, "GRE",  0 },
    { AGX2K3K_VAL_UART_TRIGGER_QUALIFIER_LESS,      0, 0, "LESS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUARTQualifierRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrUARTQualifierRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_UART_TRIGGER_TYPE */
static IviRangeTableEntry attrUARTTriggerTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_UART_TRIGGER_RSTART,       0, 0, "RSTA", 0 },
    { AGX2K3K_VAL_UART_TRIGGER_RSTOP,        0, 0, "RSTO", 0 },
    { AGX2K3K_VAL_UART_TRIGGER_RDATA,        0, 0, "RDAT", 0 },
    { AGX2K3K_VAL_UART_TRIGGER_RD1,          0, 0, "RD1",  0 },
    { AGX2K3K_VAL_UART_TRIGGER_RD0,          0, 0, "RD0",  0 },
    { AGX2K3K_VAL_UART_TRIGGER_RDX,          0, 0, "RDX",  0 },
    { AGX2K3K_VAL_UART_TRIGGER_PARITY_ERROR, 0, 0, "PAR",  0 },
    { AGX2K3K_VAL_UART_TRIGGER_TSTART,       0, 0, "TSTA", 0 },
    { AGX2K3K_VAL_UART_TRIGGER_TSTOP,        0, 0, "TSTO", 0 },
    { AGX2K3K_VAL_UART_TRIGGER_TDATA,        0, 0, "TDAT", 0 },
    { AGX2K3K_VAL_UART_TRIGGER_TD1,          0, 0, "TD1",  0 },
    { AGX2K3K_VAL_UART_TRIGGER_TD0,          0, 0, "TD0",  0 },
    { AGX2K3K_VAL_UART_TRIGGER_TDX,          0, 0, "TDX",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUARTTriggerTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrUARTTriggerTypeRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_UART_WIDTH */
static IviRangeTableEntry attrUARTWidthRangeTableEntries[] =
{
    { 5, 9, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUARTWidthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrUARTWidthRangeTableEntries,
};


/*- AGX2K3K_ATTR_SBUS_LIN_BAUDRATE -*/
static IviRangeTableEntry attrLINBaudrateRangeTableEntries[] =
{
    { 2400, 62500, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrLINBaudrateRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrLINBaudrateRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrLINBandrate_CoerceCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViInt32 value,
                                                                ViInt32 *coercedValue)
{
    ViStatus error     = VI_SUCCESS;
    ViInt32  remainder = 0;

    checkErr (Ivi_DefaultCheckCallbackViInt32 (vi, channelName, attributeId, value));

    /* from 2400 b/s to 625 kb/s in 100 b/s increments. */
    remainder = value % 100;
    if (remainder < 50)
    {
        *coercedValue = value - remainder;
    }
    else
    {
        *coercedValue = value - remainder + 100;
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_SBUS_LIN_TRIGGER -*/
static IviRangeTableEntry attrLINTriggerRangeTableEntries[] =
{
    { AGX2K3K_VAL_LIN_TRIGGER_SYNCBREAK,   0, 0, "SYNC", 0 },
    { AGX2K3K_VAL_LIN_TRIGGER_ID,          0, 0, "ID",   0 },
    { AGX2K3K_VAL_LIN_TRIGGER_DATA,        0, 0, "DATA", 0 },
    { AGX2K3K_VAL_LIN_TRIGGER_PARITYERROR, 0, 0, "PAR",  0 },
    { AGX2K3K_VAL_LIN_TRIGGER_CSUMERROR,   0, 0, "CSUM", 0 },
    { AGX2K3K_VAL_LIN_TRIGGER_FRAME,       0, 0, "FRAM", 0 },
    { AGX2K3K_VAL_LIN_TRIGGER_FSIGNAL,     0, 0, "FSIG", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrLINTriggerRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrLINTriggerRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_LIN_SOURCE -*/
/* Use common callback function */

/*- AGX2K3K_ATTR_SBUS_LIN_PARITY -*/
/* Use common callback function */

/*- AGX2K3K_ATTR_SBUS_LIN_STANDARD -*/
static IviRangeTableEntry attrLINStandardRangeTableEntries[] =
{
    { AGX2K3K_VAL_LIN_STANDARD_LIN13, 0, 0, "LIN13", 0 },
    { AGX2K3K_VAL_LIN_STANDARD_LIN20, 0, 0, "LIN20", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrLINStandardRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrLINStandardRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_LIN_SYNC_BREAK -*/
static IviRangeTableEntry attrLINSyncBreakRangeTableEntries[] =
{
    { AGX2K3K_VAL_LIN_SYNC_BREAK_11_CLOCK, 0, 0, "+11", 0 },
    { AGX2K3K_VAL_LIN_SYNC_BREAK_12_CLOCK, 0, 0, "+12", 0 },
    { AGX2K3K_VAL_LIN_SYNC_BREAK_13_CLOCK, 0, 0, "+13", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrLINSyncBreakRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrLINSyncBreakRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_LIN_TRIGGER_ID -*/
static IviRangeTableEntry attrLINTriggerIdRangeTableEntries[] =
{
    { 0, 63, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrLINTriggerIdRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrLINTriggerIdRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA -*/
static ViStatus _VI_FUNC agx2k3kAttrLINTriggerData_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViString command;

    viCheckErr (Ivi_GetStringFromTable (gs_ViStringCommands, attributeId, &command));

    if (!Ivi_Simulating (vi))
    {
        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];
            viCheckErr (viPrintf (io, ":%s:LIN:TRIG:PATT:FORM BIN", channelName));
            sprintf (buffer, command, channelName);
            error = viPrintf (io, "%s \"%s\"", buffer, value);
        }
        viCheckErr (error);
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrLINTriggerData_ReadCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 const ViConstString cacheValue)
{
    ViStatus error = VI_SUCCESS;
    ViString command;
    ViChar   * pdata = VI_NULL;
    ViChar   * pend  = VI_NULL;

    viCheckErr (Ivi_GetStringFromTable (gs_ViStringCommands, attributeId, &command));

    if (!Ivi_Simulating (vi))
    {
        ViChar   buffer[BUFFER_SIZE];
        ViChar   * pbuffer       = VI_NULL;
        ViUInt32 allocated_count = 0;
        ViUInt32 count           = 0;
        ViUInt32 readed_count;

        if (channelName != VI_NULL)
        {
            ViChar buffer[BUFFER_SIZE];
            sprintf (buffer, command, channelName);
            error = viPrintf (io, "%s?", buffer);
        }
        else
        {
            error = viPrintf (io, "%s?", command);
        }
        viCheckErr (error);

        while ((error = viRead (io, (ViPBuf) buffer, BUFFER_SIZE, &readed_count)) == VI_SUCCESS_MAX_CNT)
        {
            if (allocated_count)
            {
                if (allocated_count <= count + readed_count)
                {
                    allocated_count += (allocated_count - count) + BUFFER_SIZE;
                    pdata            = (char *) realloc (pdata, allocated_count);
                }

                pend = pdata + count;
            }
            else
            {
                allocated_count = 2 * BUFFER_SIZE;
                pdata           = (char *) malloc (allocated_count);
                pend            = pdata;
            }

            memcpy (pend, buffer, readed_count);
            count += readed_count;
        }

        if (readed_count > 0)
        {
            /*
             * Check if the last character is alnum.
             * if this character is not alnum we know that it's '\n'.
             * Remove it.
             */
            if (!isalnum (buffer[readed_count - 1]))
                readed_count--;
            buffer[readed_count] = '\0';
        }

        /*
         * If function is read more data as BUFFER_SIZE, we must
         * copy last data from static buffer to dynamic buffer
         */
        if (pdata)
        {
            /*
             * For sure, check if the  buffer has enought element.
             * This condition should be FALSE every time.
             */
            if (allocated_count <= count + readed_count)
            {
                allocated_count += (allocated_count - count) + BUFFER_SIZE;
                pdata            = (char *) realloc (pdata, allocated_count);
            }
            pend = pdata + count;
            memcpy (pend, buffer, readed_count + 1);
            pbuffer = pdata;
        }
        else
            pbuffer = buffer;

        viCheckErr (error);

        checkErr (Ivi_SetValInStringCallback (vi, attributeId, pbuffer));
    }

Error:
    if (pdata)
        free (pdata);
    return error;
}

/*- AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA_LENGTH -*/
static IviRangeTableEntry attrLINDataLengthRangeTableEntries[] =
{
    { 1, 8, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrLINDataLengthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrLINDataLengthRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_SPI_MISO_WIDTH */
/* AGX2K3K_ATTR_SBUS_SPI_MOSI_WIDTH */
static IviRangeTableEntry attrSPIMxsxWidthRangeTableEntries[] =
{
    { 4, 64, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrSPIMxsxWidthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrSPIMxsxWidthRangeTableEntries,
};

/* AGX2K3K_ATTR_SBUS_SPI_WORD_WIDTH */
static IviRangeTableEntry attrSPIWordWidthRangeTableEntries[] =
{
    { 4, 16, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrSPIWordWidthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrSPIWordWidthRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_SPI_MISO_DATA -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_SBUS_SPI_MOSI_DATA -*/
/* Use common callback functions */


/*- AGX2K3K_ATTR_SBUS_SPI_CLKSOURCE -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_SBUS_SPI_FSOURCE -*/
static ViStatus _VI_FUNC agx2k3kAttrSPIFrameSource_CheckCallback (ViSession vi,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   clksource[BUFFER_SIZE];

    checkErr (agx2k3kAttrSerialBusSource_CheckCallback (vi,
                                                        channelName,
                                                        attributeId,
                                                        value));

    checkErr (Ivi_GetAttributeViString (vi,
                                        channelName,
                                        AGX2K3K_ATTR_SBUS_SPI_CLKSOURCE,
                                        0,
                                        BUFFER_SIZE,
                                        clksource));

    if (!strcmp (value, clksource))
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Incorrect value.");
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_SBUS_SPI_DSOURCE -*/
static ViStatus _VI_FUNC agx2k3kAttrSPIDataSource_CheckCallback (ViSession vi,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   clksource[BUFFER_SIZE];
    ViChar   fsource[BUFFER_SIZE];

    checkErr (agx2k3kAttrSerialBusSource_CheckCallback (vi,
                                                        channelName,
                                                        attributeId,
                                                        value));

    checkErr (Ivi_GetAttributeViString (vi,
                                        channelName,
                                        AGX2K3K_ATTR_SBUS_SPI_CLKSOURCE,
                                        0,
                                        BUFFER_SIZE,
                                        clksource));

    checkErr (Ivi_GetAttributeViString (vi,
                                        channelName,
                                        AGX2K3K_ATTR_SBUS_SPI_FSOURCE,
                                        0,
                                        BUFFER_SIZE,
                                        fsource));

    if (!strcmp (value, clksource) || !strcmp (value, fsource))
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Incorrect value.");
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_SBUS_SPI_TRIGGER_TYPE -*/
static IviRangeTableEntry attrSPITriggerTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_SPI_TRIGGER_MOSI, 0, 0, "MOSI", 0 },
    { AGX2K3K_VAL_SPI_TRIGGER_MISO, 0, 0, "MISO", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrSPITriggerTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrSPITriggerTypeRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_SPI_FRAME -*/
static IviRangeTableEntry attrSPIFrameRangeTableEntries[] =
{
    { AGX2K3K_VAL_SPI_FRAME_NCHIP,   0, 0, "NCH",  0 },
    { AGX2K3K_VAL_SPI_FRAME_CHIP,    0, 0, "CHIP", 0 },
    { AGX2K3K_VAL_SPI_FRAME_TIMEOUT, 0, 0, "TIM",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrSPIFrameRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrSPIFrameRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_SPI_SLOPE -*/
static IviRangeTableEntry attrSPISlopeRangeTableEntries[] =
{
    { AGX2K3K_VAL_SPI_SLOPE_POSITIVE, 0, 0, "POS", 0 },
    { AGX2K3K_VAL_SPI_SLOPE_NEGATIVE, 0, 0, "NEG", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrSPISlopeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrSPISlopeRangeTableEntries,
};

/*- AGX2K3K_ATTR_SBUS_SPI_TIMEOUT -*/
static IviRangeTableEntry attrSPITimeoutRangeTableEntries[] =
{
    { 500.0e-9, 10.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrSPITimeoutRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrSPITimeoutRangeTableEntries,
};


/*- AGX2K3K_ATTR_SBUS_SPI_BIT_ORDER -*/
static IviRangeTableEntry attrSPIBitOrderRangeTableEntries[] =
{
    { AGX2K3K_VAL_SPI_BITORDER_MSB_FIRST, 0, 0, "MSBF", 0 },
    { AGX2K3K_VAL_SPI_BITORDER_LSB_FIRST, 0, 0, "LSBF", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrSPIBitOrderRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    "",
    attrSPIBitOrderRangeTableEntries,
};

/* AGX2K3K_ATTR_EBURST_COUNT */
static IviRangeTableEntry attrEburstCountRangeTableEntries[] =
{
    { 1, 65535, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrEburstCountRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrEburstCountRangeTableEntries,
};

/* AGX2K3K_ATTR_EBURST_IDLE */
static IviRangeTableEntry attrEburstIdleRangeTableEntries[] =
{
    { 10E-9, 10, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrEburstIdleRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrEburstIdleRangeTableEntries,
};

/* AGX2K3K_ATTR_EBURST_SLOPE */
static IviRangeTableEntry attrEburstSlopeRangeTableEntries[] =
{
    { AGX2K3K_VAL_NEGATIVE, 0, 0, "NEG", 0 },
    { AGX2K3K_VAL_POSITIVE, 0, 0, "POS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrEburstSlopeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrEburstSlopeRangeTableEntries,
};

/* AGX2K3K_ATTR_TRIGGER_REJECT_FILTER */
static IviRangeTableEntry attrTriggerRejectFilterRangeTableEntries[] =
{
    { AGX2K3K_VAL_REJ_FILTER_OFF, 0, 0, "OFF", 0 },
    { AGX2K3K_VAL_LF_REJECT,      0, 0, "LFR", 0 },
    { AGX2K3K_VAL_HF_REJECT,      0, 0, "HFR", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTriggerRejectFilterRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTriggerRejectFilterRangeTableEntries,
};

/* AGX2K3K_ATTR_RUNT_POLARITY */
static IviRangeTableEntry attrRuntPolarityRangeTableEntries[] =
{
    { AGX2K3K_VAL_RUNT_POSITIVE, 0, 0, "POS",  0 },
    { AGX2K3K_VAL_RUNT_NEGATIVE, 0, 0, "NEG",  0 },
    { AGX2K3K_VAL_RUNT_EITHER,   0, 0, "EITH", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrRuntPolarityRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrRuntPolarityRangeTableEntries,
};

/* AGX2K3K_ATTR_RUNT_QUALIFIER */
static IviRangeTableEntry attrRuntQualifierRangeTableEntries[] =
{
    { AGX2K3K_VAL_RUNT_QUALIFIER_GREATER, 0, 0, "GRE",  0 },
    { AGX2K3K_VAL_RUNT_QUALIFIER_LESS,    0, 0, "LESS", 0 },
    { AGX2K3K_VAL_RUNT_QUALIFIER_NONE,    0, 0, "NONE", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrRuntQualifierRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrRuntQualifierRangeTableEntries,
};

/* AGX2K3K_ATTR_RUNT_TIME */
static IviRangeTableEntry attrRuntTimeRangeTableEntries[] =
{
    { 6E-9, 10, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrRuntTimeRangeTable =
{
    IVI_VAL_RANGED,
    VI_FALSE,
    VI_FALSE,
    "",
    attrRuntTimeRangeTableEntries,
};

/* AGX2K3K_ATTR_RUNT_HIGH_THRESHOLD */
static ViStatus _VI_FUNC agx2k3kAttrRuntHighThreshold_WriteCallback (ViSession vi,
                                                                     ViSession io,
                                                                     ViConstString channelName,
                                                                     ViAttr attributeId,
                                                                     ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   source[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_SOURCE, 0, BUFFER_SIZE, source));

    viCheckErr (viPrintf (io, ":TRIG:LEV:HIGH %g,%s", value, source));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrRuntHighThreshold_ReadCallback (ViSession vi,
                                                                    ViSession io,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViReal64 *value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   source[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_SOURCE, 0, BUFFER_SIZE, source));

    viCheckErr (viQueryf (io, ":TRIG:LEV:HIGH? %s", "%lf", source, value));

Error:
    return error;
}

/* AGX2K3K_ATTR_RUNT_LOW_THRESHOLD */
static ViStatus _VI_FUNC agx2k3kAttrRuntLowThreshold_WriteCallback (ViSession vi,
                                                                    ViSession io,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   source[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_SOURCE, 0, BUFFER_SIZE, source));

    viCheckErr (viPrintf (io, ":TRIG:LEV:LOW %g,%s", value, source));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrRuntLowThreshold_ReadCallback (ViSession vi,
                                                                   ViSession io,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViReal64 *value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   source[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_SOURCE, 0, BUFFER_SIZE, source));

    viCheckErr (viQueryf (io, ":TRIG:LEV:LOW? %s", "%lf", source, value));

Error:
    return error;
}

/* AGX2K3K_ATTR_SETUPHOLD_SLOPE */
static IviRangeTableEntry attrSetupHoldSlopeRangeTableEntries[] =
{
    { AGX2K3K_VAL_POSITIVE, 0, 0, "POS", 0 },
    { AGX2K3K_VAL_NEGATIVE, 0, 0, "NEG", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrSetupHoldSlopeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrSetupHoldSlopeRangeTableEntries,
};

/* AGX2K3K_ATTR_SETUPHOLD_CLKSRC */
/* Use common callback functions */

/* AGX2K3K_ATTR_SETUPHOLD_DATASRC */
static ViStatus _VI_FUNC agx2k3kAttrSetupHoldDataSource_CheckCallback (ViSession vi,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   clksource[BUFFER_SIZE];

    checkErr (agx2k3kAttrSerialBusSource_CheckCallback (vi,
                                                        channelName,
                                                        attributeId,
                                                        value));

    checkErr (Ivi_GetAttributeViString (vi,
                                        channelName,
                                        AGX2K3K_ATTR_SETUPHOLD_CLKSRC,
                                        0,
                                        BUFFER_SIZE,
                                        clksource));

    if (!strcmp (value, clksource))
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Incorrect value.");
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SETUPHOLD_HOLD_TIME */
static IviRangeTableEntry attrHoldRangeTableEntries[] =
{
    { 0.0, 10E-9, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrHoldRangeTable =
{
    IVI_VAL_RANGED,
    VI_FALSE,
    VI_FALSE,
    "",
    attrHoldRangeTableEntries,
};

/* AGX2K3K_ATTR_SETUPHOLD_SETUP_TIME */
static IviRangeTableEntry attrSetupRangeTableEntries[] =
{
    { 0.0, 10.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrSetupRangeTable =
{
    IVI_VAL_RANGED,
    VI_FALSE,
    VI_FALSE,
    "",
    attrSetupRangeTableEntries,
};

/* AGX2K3K_ATTR_TRANSITION_QUALIFIER */
static IviRangeTableEntry attrTransitionQualifierRangeTableEntries[] =
{
    { AGX2K3K_VAL_TRANSITION_QUALIFIER_GREATER, 0, 0, "GRE",  0 },
    { AGX2K3K_VAL_TRANSITION_QUALIFIER_LESS,    0, 0, "LESS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTransitionQualifierRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTransitionQualifierRangeTableEntries,
};

/* AGX2K3K_ATTR_TRANSITION_SLOPE */
static IviRangeTableEntry attrTransitionSlopeRangeTableEntries[] =
{
    { AGX2K3K_VAL_POSITIVE, 0, 0, "POS", 0 },
    { AGX2K3K_VAL_NEGATIVE, 0, 0, "NEG", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTransitionSlopeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTransitionSlopeRangeTableEntries,
};

/* AGX2K3K_ATTR_TRANSITION_TIME */
static IviRangeTableEntry attrTransitionTimeRangeTableEntries[] =
{
    { 3.0E-9, 10.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTransitionTimeRangeTable =
{
    IVI_VAL_RANGED,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTransitionTimeRangeTableEntries,
};

/*- AGX2K3K_ATTR_TV_TRIGGER_SIGNAL_FORMAT -*/
static IviRangeTableEntry attrTvTriggerSignalFormatRangeTableEntries[] =
{
    { AGX2K3K_VAL_GENERIC,    0, 0, "GEN",        0 },
    { AGX2K3K_VAL_NTSC,       0, 0, "NTSC",       0 },
    { AGX2K3K_VAL_PALM,       0, 0, "PALM",       0 },
    { AGX2K3K_VAL_PAL,        0, 0, "PAL",        0 },
    { AGX2K3K_VAL_SECAM,      0, 0, "SEC",        0 },
    { AGX2K3K_VAL_P480L60HZ,  0, 0, "P480L60HZ",  0 },
    { AGX2K3K_VAL_P720L60HZ,  0, 0, "P720L60HZ",  0 },
    { AGX2K3K_VAL_P1080L24HZ, 0, 0, "P1080L24HZ", 0 },
    { AGX2K3K_VAL_P1080L25HZ, 0, 0, "P1080L25HZ", 0 },
    { AGX2K3K_VAL_P1080L50HZ, 0, 0, "P1080L50HZ", 0 },
    { AGX2K3K_VAL_P1080L60HZ, 0, 0, "P1080L60HZ", 0 },
    { AGX2K3K_VAL_I1080L50HZ, 0, 0, "I1080L50HZ", 0 },
    { AGX2K3K_VAL_I1080L60HZ, 0, 0, "I1080L60HZ", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTvTriggerSignalFormatRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTvTriggerSignalFormatRangeTableEntries,
};

/*- AGX2K3K_ATTR_TV_TRIGGER_EVENT -*/
static IviRangeTableEntry attrTvTriggerEventRangeTableEntries[] =
{
    { AGX2K3K_VAL_TV_EVENT_FIELD1,      0, 0, "FIE1", 0 },
    { AGX2K3K_VAL_TV_EVENT_FIELD2,      0, 0, "FIE2", 0 },
    { AGX2K3K_VAL_TV_EVENT_ANY_FIELD,   0, 0, "AFI",  0 },
    { AGX2K3K_VAL_TV_EVENT_ANY_LINE,    0, 0, "ALIN", 0 },
    { AGX2K3K_VAL_TV_EVENT_LFIELD1,     0, 0, "LFI1", 0 },
    { AGX2K3K_VAL_TV_EVENT_LFIELD2,     0, 0, "LFI2", 0 },
    { AGX2K3K_VAL_TV_EVENT_LALTERNATE,  0, 0, "LALT", 0 },
    { AGX2K3K_VAL_TV_EVENT_LINE_NUMBER, 0, 0, "LINE", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrTvTriggerEventRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTvTriggerEventRangeTableEntries,
};

/*- AGX2K3K_ATTR_TV_TRIGGER_LINE_NUMBER -*/
static IviRangeTableEntry attrTvTriggerLineNumberRangeTableEntries[] =
{
    { 1, 625, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTvTriggerLineNumberRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrTvTriggerLineNumberRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrTvTriggerLineNumber_CheckCallback (ViSession vi,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  mode, standard, minimum = 1, maximum = 1;

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TV_TRIGGER_EVENT, VI_NULL, &mode));

    if (mode != AGX2K3K_VAL_TV_EVENT_LFIELD1 && mode != AGX2K3K_VAL_TV_EVENT_LFIELD2 &&
        mode != AGX2K3K_VAL_TV_EVENT_LALTERNATE)
    {
        viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);
    }

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TV_TRIGGER_SIGNAL_FORMAT, VI_NULL, &standard));

        switch (mode)
        {
        case AGX2K3K_VAL_TV_EVENT_LFIELD1:
        {
            switch (standard)
            {
            case AGX2K3K_VAL_NTSC:
            case AGX2K3K_VAL_PALM:
                maximum = 263;
                break;

            case AGX2K3K_VAL_PAL:
            case AGX2K3K_VAL_SECAM:
                maximum = 313;
                break;

            default:
                viCheckErr (IVI_ERROR_INVALID_VALUE);
                break;
            }
        } break;

        case AGX2K3K_VAL_TV_EVENT_LFIELD2:
        {
            switch (standard)
            {
            case AGX2K3K_VAL_NTSC:
                maximum = 262;
                break;

            case AGX2K3K_VAL_PAL:
            case AGX2K3K_VAL_SECAM:
            {
                minimum = 314;
                maximum = 625;
            } break;

            case AGX2K3K_VAL_PALM:
            {
                minimum = 264;
                maximum = 525;
            } break;

            default:
                viCheckErr (IVI_ERROR_INVALID_VALUE);
                break;
            }
        } break;

        case AGX2K3K_VAL_TV_EVENT_LALTERNATE:
        {
            switch (standard)
            {
            case AGX2K3K_VAL_NTSC:
            case AGX2K3K_VAL_PALM:
                maximum = 262;
                break;

            case AGX2K3K_VAL_PAL:
            case AGX2K3K_VAL_SECAM:
                maximum = 312;
                break;

            default:
                viCheckErr (IVI_ERROR_INVALID_VALUE);
                break;
            }
        } break;
        }

        if (value < minimum || value > maximum)
            viCheckErr (IVI_ERROR_INVALID_VALUE);
    }
Error:
    return error;
}

/*- AGX2K3K_ATTR_TV_TRIGGER_POLARITY -*/
static IviRangeTableEntry attrTvTriggerPolarityRangeTableEntries[] =
{
    { AGX2K3K_VAL_TV_POSITIVE, 0, 0, "POS", 0 },
    { AGX2K3K_VAL_TV_NEGATIVE, 0, 0, "NEG", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTvTriggerPolarityRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTvTriggerPolarityRangeTableEntries,
};

/*- AGX2K3K_ATTR_USB_TRIGGER -*/
static IviRangeTableEntry attrUSBTriggerRangeTableEntries[] =
{
    { AGX2K3K_VAL_USB_TRIGGER_SOP,  0, 0, "SOP",  0 },                  /*  SOP */
    { AGX2K3K_VAL_USB_TRIGGER_EOP,  0, 0, "EOP",  0 },                  /*  EOP */
    { AGX2K3K_VAL_USB_TRIGGER_RES,  0, 0, "RES",  0 },                  /*  Reset */
    { AGX2K3K_VAL_USB_TRIGGER_ENT,  0, 0, "ENT",  0 },                  /*  Enter Suspend */
    { AGX2K3K_VAL_USB_TRIGGER_EXIT, 0, 0, "EXIT", 0 },                  /*  Exit Suspend */
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUSBTriggerRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrUSBTriggerRangeTableEntries,
};

/*- AGX2K3K_ATTR_USB_SPEED -*/
static IviRangeTableEntry attrUSBSpeedRangeTableEntries[] =
{
    { AGX2K3K_VAL_USB_SPEED_LOW,  0, 0, "LOW",  0 },
    { AGX2K3K_VAL_USB_SPEED_FULL, 0, 0, "FULL", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrUSBSpeedRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrUSBSpeedRangeTableEntries,
};

/*- AGX2K3K_ATTR_USB_DPLUS -*/
static ViStatus _VI_FUNC agx2k3kAttrDPlus_CheckCallback (ViSession vi,
                                                         ViConstString channelName,
                                                         ViAttr attributeId,
                                                         ViConstString value)
{
    ViStatus error = VI_SUCCESS;

    if (Ivi_RangeChecking (vi))
    {
        if (!strstr (value, "CHAN") && !strstr (value, "DIG") && strcmp (value, "EXT") != 0)
        {
            viCheckErr (IVI_ERROR_INVALID_VALUE);
        }
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_USB_DMINUS -*/
static ViStatus _VI_FUNC agx2k3kAttrUSBDMinus_CheckCallback (ViSession vi,
                                                             ViConstString channelName,
                                                             ViAttr attributeId,
                                                             ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    if (Ivi_RangeChecking (vi))
    {
        if (!strstr (value, "CHAN") && !strstr (value, "DIG") && strcmp (value, "EXT") != 0)
        {
            viCheckErr (IVI_ERROR_INVALID_VALUE);
        }
    }

    checkErr (Ivi_GetAttributeViString (vi,
                                        VI_NULL,
                                        AGX2K3K_ATTR_USB_DPLUS,
                                        0,
                                        BUFFER_SIZE,
                                        buffer));

    if (!strcmp (value, buffer))
    {
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 5, "Incorrect value.");
    }

Error:
    return error;
}


/* AGX2K3K_ATTR_TRIGGER_ZONE_SOURCE */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_TRIGGER_ZONE_STATE_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_TRIGGER_ZONE_MODE */
static IviRangeTableEntry attrTriggerZoneModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_TRIGGER_ZONE_MODE_INTERSECT,    0, 0, "INT", 0 },
    { AGX2K3K_VAL_TRIGGER_ZONE_MODE_NOTINTERSECT, 0, 0, "NOT", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrTriggerZoneModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrTriggerZoneModeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_MULTICHANNEL_TRIGGER_ZONE_STATE_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */


/*- AGX2K3K_ATTR_ACQUISITION_TYPE -*/
static IviRangeTableEntry attrAcquisitionTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_NORMAL,      0, 0, "NORM", 0 },
    { AGX2K3K_VAL_PEAK_DETECT, 0, 0, "PEAK", 0 },
    { AGX2K3K_VAL_AVERAGE,     0, 0, "AVER", 0 },
    { AGX2K3K_VAL_HI_RES,      0, 0, "HRES", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrAcquisitionTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrAcquisitionTypeRangeTableEntries,
};


/*- AGX2K3K_ATTR_ACQUISITION_MODE -*/
static IviRangeTableEntry attrAcquisitionModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_ACQ_MODE_REALTIME,  0, 0, "RTIM", 0 },
    { AGX2K3K_VAL_ACQ_MODE_SEGMENT,   0, 0, "SEGM", 0 },
    { AGX2K3K_VAL_ACQ_MODE_MREALTIME, 0, 0, "MRT",  0 },
    { AGX2K3K_VAL_ACQ_MODE_EQUITIME,  0, 0, "ETIM", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrAcquisitionModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrAcquisitionModeRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrAcquisitionMode_CheckCallback (ViSession vi,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  acqType;

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_ACQUISITION_TYPE, VI_NULL, &acqType));

    if (acqType == AGX2K3K_VAL_AVERAGE)
        viCheckErr (IVI_ERROR_INVALID_CONFIGURATION);

Error:
    return error;
}

/* AGX2K3K_ATTR_SEGMENT_ANALYZE_ENABLE, with option SGM */
static ViStatus _VI_FUNC agx2k3kAttrSegmentAnalyzeEnable_WriteCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViBoolean value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    if (value == VI_TRUE)
    {
        viCheckErr (Ivi_GetStringFromTable (gs_ViBooleanCommands, attributeId, &cmd));
        if (!Ivi_Simulating (vi))
        {
            error = viPrintf (io, "%s", cmd);

            viCheckErr (error);
        }
    }
Error:
    return error;
}

/* AGX2K3K_ATTR_SEGMENT_COUNT, with option SGM */
static IviRangeTableEntry attrSegmentCountRangeTableEntries[] =
{
    { 2, 1000, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrSegmentCountRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrSegmentCountRangeTableEntries,
};

/* AGX2K3K_ATTR_SEGMENT_INDEX, with option SGM */

/*- AGX2K3K_ATTR_INITIATE_CONTINUOUS -*/
static ViStatus _VI_FUNC agx2k3kAttrInitiateContinuous_WriteCallback (ViSession vi,
                                                                      ViSession io,
                                                                      ViConstString channelName,
                                                                      ViAttr attributeId,
                                                                      ViBoolean value)
{
    ViStatus error = VI_SUCCESS;

    if (!Ivi_Simulating (vi))
    {
        viCheckErr (viPrintf (io, ":%s", value ? "RUN" : "SING"));
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_PROBE_SKEW -*/
static IviRangeTableEntry attrProbeSkewRangeTableEntries[] =
{
    { -100.0e-9, 100.0e-9, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrProbeSkewRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrProbeSkewRangeTableEntries,
};

/*- AGX2K3K_ATTR_PROBE_UNITS -*/
static IviRangeTableEntry attrProbeUnitsRangeTableEntries[] =
{
    { AGX2K3K_VAL_PROBE_UNITS_VOLTS, 0, 0, "VOLT", 0 },
    { AGX2K3K_VAL_PROBE_UNITS_AMPS,  0, 0, "AMP",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrProbeUnitsRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrProbeUnitsRangeTableEntries,
};

/*- AGX2K3K_ATTR_CHANNEL_LABEL -*/
static ViStatus _VI_FUNC agx2k3kAttrChannelLabel_CheckCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViConstString value)
{
    ViStatus error = VI_SUCCESS;

    if (value == VI_NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Channel Label");

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrChannelLabel_WriteCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   quotedString[BUFFER_SIZE];

    sprintf (quotedString, "\"%s\"", value);
    checkErr (Ivi_SetAttributeViString (vi, channelName, AGX2K3K_ATTR_INSTR_CHANNEL_LABEL, 0, quotedString));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrChannelLabel_ReadCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               const ViConstString cacheValue)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi,
                                        channelName,
                                        AGX2K3K_ATTR_INSTR_CHANNEL_LABEL,
                                        0,
                                        BUFFER_SIZE,
                                        buffer));

    checkErr (Ivi_SetValInStringCallback (vi, AGX2K3K_ATTR_CHANNEL_LABEL, buffer));

Error:
    return error;
}

/* AGX2K3K_ATTR_CHANNEL_PROBE_TEK_MODEL */
static IviRangeTableEntry attrChannelProbeTekModelRangeTableEntries[] =
{
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P5205,  0, 0, "P5205",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P5210,  0, 0, "P5210",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P6205,  0, 0, "P6205",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P6241,  0, 0, "P6241",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P6243,  0, 0, "P6243",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P6245,  0, 0, "P6245",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P6246,  0, 0, "P6246",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P6247,  0, 0, "P6247",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P6248,  0, 0, "P6248",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P6249,  0, 0, "P6249",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P6250,  0, 0, "P6250",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P6251,  0, 0, "P6251",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P670X,  0, 0, "P670X",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P671X,  0, 0, "P671X",  0 },
    { AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_TCP202, 0, 0, "TCP202", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrChannelProbeTekModelRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrChannelProbeTekModelRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */


/*- AGX2K3K_ATTR_DIG_POSITION -*/
static IviRangeTableEntry attrDigitalPositionRangeTableEntries[] =
{
    { 0, 15, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrDigitalPositionRangeTable =
{
    IVI_VAL_RANGED,
    VI_FALSE,
    VI_FALSE,
    "",
    attrDigitalPositionRangeTableEntries,
};

/*- AGX2K3K_ATTR_TIMEBASE_MODE -*/
static IviRangeTableEntry attrTimebaseModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_TIMEBASE_NORMAL, 0, 0, "MAIN", 0 },
    { AGX2K3K_VAL_TIMEBASE_WINDOW, 0, 0, "WIND", 0 },
    { AGX2K3K_VAL_TIMEBASE_XY,     0, 0, "XY",   0 },
    { AGX2K3K_VAL_TIMEBASE_ROLL,   0, 0, "ROLL", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrTimebaseModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTimebaseModeRangeTableEntries,
};

/*- AGX2K3K_ATTR_TIMEBASE_POSITION -*/
static IviRangeTableEntry attrTimebasePositionRangeTableEntries[] =
{
    { -5.00e+02, 5.00e+02, 5.00e+01, "", 0 },
    { -2.00e+02, 5.00e+02, 2.00e+01, "", 0 },
    { -1.00e+02, 5.00e+02, 1.00e+01, "", 0 },
    { -5.00e+01, 5.00e+02, 5.00e+00, "", 0 },
    { -2.00e+01, 5.00e+02, 2.00e+00, "", 0 },
    { -1.00e+01, 5.00e+02, 1.00e+00, "", 0 },
    { -5.00e+00, 5.00e+02, 5.00e-01, "", 0 },
    { -2.00e+00, 5.00e+02, 2.00e-01, "", 0 },
    { -1.00e+00, 5.00e+02, 1.00e-01, "", 0 },
    { -5.00e-01, 5.00e+02, 5.00e-02, "", 0 },
    { -2.00e-01, 2.00e+02, 2.00e-02, "", 0 },
    { -1.00e-01, 1.00e+02, 1.00e-02, "", 0 },
    { -5.00e-02, 5.00e+01, 5.00e-03, "", 0 },
    { -2.00e-02, 2.00e+01, 2.00e-03, "", 0 },
    { -1.00e-02, 1.00e+01, 1.00e-03, "", 0 },
    { -5.00e-03, 5.00e+00, 5.00e-04, "", 0 },
    { -2.00e-03, 2.00e+00, 2.00e-04, "", 0 },
    { -1.00e-03, 1.00e+00, 1.00e-04, "", 0 },
    { -5.00e-06, 1.00e+00, 5.00e-05, "", 0 },
    { -5.00e-06, 1.00e+00, 2.00e-05, "", 0 },
    { -5.00e-06, 1.00e+00, 1.00e-05, "", 0 },
    { -5.00e-06, 1.00e+00, 5.00e-06, "", 0 },
    { -5.00e-06, 1.00e+00, 2.00e-06, "", 0 },
    { -5.00e-06, 1.00e+00, 1.00e-06, "", 0 },
    { -5.00e-06, 1.00e+00, 5.00e-07, "", 0 },
    { -5.00e-06, 1.00e+00, 2.00e-07, "", 0 },
    { -5.00e-06, 1.00e+00, 1.00e-07, "", 0 },
    { -5.00e-06, 1.00e+00, 5.00e-08, "", 0 },
    { -5.00e-06, 1.00e+00, 2.00e-08, "", 0 },
    { -5.00e-06, 1.00e+00, 1.00e-08, "", 0 },
    { -5.00e-06, 1.00e+00, 5.00e-09, "", 0 },
    { -5.00e-06, 1.00e+00, 2.00e-09, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrTimebasePositionRangeTable =
{
    IVI_VAL_RANGED,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTimebasePositionRangeTableEntries,
};


static ViStatus _VI_FUNC agx2k3kAttrTimebasePosition_CheckCallback (ViSession vi,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViReal64 scale;
    ViReal64 min, max;

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_TIMEBASE_SCALE, 0, &scale));

        viCheckErr (Ivi_GetViReal64EntryFromCoercedVal (scale, &attrTimebasePositionRangeTable, &min, &max,
                                                        VI_NULL, VI_NULL, VI_NULL));


        if (value < min || value > max)
        {
            viCheckErr (IVI_ERROR_INVALID_VALUE);
        }
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_TIMEBASE_REFERENCE -*/
static IviRangeTableEntry attrTimebaseReferenceRangeTableEntries[] =
{
    { AGX2K3K_VAL_TIMEBASE_REF_LEFT,   0, 0, "LEFT", 0 },
    { AGX2K3K_VAL_TIMEBASE_REF_CENTER, 0, 0, "CENT", 0 },
    { AGX2K3K_VAL_TIMEBASE_REF_RIGHT,  0, 0, "RIGH", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrTimebaseReferenceRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrTimebaseReferenceRangeTableEntries,
};

/*- AGX2K3K_ATTR_TIMEBASE_SCALE -*/
static IviRangeTableEntry attrInstrTimebaseScaleRangeTableEntries[] =
{
    { 500.0e-12, 50.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrInstrTimebaseScaleRangeTable =
{
    IVI_VAL_RANGED,
    VI_FALSE,
    VI_FALSE,
    "",
    attrInstrTimebaseScaleRangeTableEntries,
};


static ViStatus _VI_FUNC agx2k3kAttrTimebaseScale_RangeTableCallback (ViSession vi,
                                                                      ViConstString channelName,
                                                                      ViAttr attributeId,
                                                                      IviRangeTablePtr *rangeTablePtr)
{
    ViStatus         error     = VI_SUCCESS;
    IviRangeTablePtr tblPtr    = VI_NULL;
    ViInt32          modelType = UNKNOWN;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       0, &modelType));

    tblPtr = &attrInstrTimebaseScaleRangeTable;

Error:
    *rangeTablePtr = tblPtr;
    return error;
}


/*- AGX2K3K_ATTR_TIMEBASE_VERNIER -*/
/* Use common callback functions */


/*- AGX2K3K_ATTR_WIN_TIMEBASE_POSITION -*/
static ViStatus _VI_FUNC agx2k3kAttrWindowTimebasePosition_CheckCallback (ViSession vi,
                                                                          ViConstString channelName,
                                                                          ViAttr attributeId,
                                                                          ViReal64 value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_DefaultCheckCallbackViReal64 (vi, VI_NULL, attributeId, value));

Error:
    return error;
}

/*- AGX2K3K_ATTR_WIN_TIMEBASE_RANGE -*/
static ViStatus _VI_FUNC agx2k3kAttrWindowTimebaseRange_CheckCallback (ViSession vi,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViReal64 timebaseRange;
    ViReal64 min = 20.0e-9;
    ViReal64 max;

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_HORZ_TIME_PER_RECORD, VI_NULL, &timebaseRange));

        max = timebaseRange / 2.0;

        if (value < min || value > max)
            viCheckErr (IVI_ERROR_INVALID_VALUE);
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_WIN_TIMEBASE_SCALE -*/
static ViStatus _VI_FUNC agx2k3kAttrWindowTimebaseScale_CheckCallback (ViSession vi,
                                                                       ViConstString channelName,
                                                                       ViAttr attributeId,
                                                                       ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViReal64 timebaseScale;
    ViReal64 min = 20.0e-9;
    ViReal64 max;

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_TIMEBASE_SCALE,
                                            VI_NULL, &timebaseScale));

        max = timebaseScale / 2.0;

        if (value < min || value > max)
            viCheckErr (IVI_ERROR_INVALID_VALUE);
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_NUM_AVERAGES -*/
static IviRangeTableEntry attrNumAveragesRangeTableEntries[] =
{
    { 2, 65536, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrNumAveragesRangeTable =
{
    IVI_VAL_RANGED,
    VI_FALSE,
    VI_FALSE,
    "",
    attrNumAveragesRangeTableEntries,
};


/*- AGX2K3K_ATTR_SAMPLE_MODE -*/
static IviRangeTableEntry attrSampleModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_REAL_TIME,       0, 0, "RTIM", 0 },
    { AGX2K3K_VAL_EQUIVALENT_TIME, 0, 0, "ETIM", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrSampleModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrSampleModeRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrSampleMode_ReadCallback (ViSession vi,
                                                             ViSession io,
                                                             ViConstString channelName,
                                                             ViAttr attributeId,
                                                             ViInt32 *value)
{
    ViStatus error = VI_SUCCESS;

    ViChar   rdBuffer[BUFFER_SIZE];
    size_t   rdBufferSize = sizeof (rdBuffer);

    viCheckErr (viBufWrite (io, (ViBuf) ":ACQ:MODE?", 10, VI_NULL));
    viCheckErr (viScanf (io, "%#s", &rdBufferSize, rdBuffer));

    viCheckErr (Ivi_GetViInt32EntryFromString (rdBuffer, &attrSampleModeRangeTable,
                                               value, VI_NULL, VI_NULL,
                                               VI_NULL, VI_NULL));

Error:
    return error;
}

/*- AGX2K3K_ATTR_MEAS_HIGH_REF -*/
static IviRangeTableEntry attrMeasHighRefRangeTableEntries[] =
{
    { 7.0, 95.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrMeasHighRefRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrMeasHighRefRangeTableEntries,
};

/*- AGX2K3K_ATTR_MEAS_LOW_REF -*/
static ViStatus _VI_FUNC agx2k3kAttrMeasLowRef_CheckCallback (ViSession vi,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViReal64 value)
{
    ViStatus error   = VI_SUCCESS;
    ViReal64 minimum = 5;
    ViReal64 maximum;

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEAS_HIGH_REF, 0, &maximum));

        if (value < minimum || value > maximum)
            viCheckErr (IVI_ERROR_INVALID_VALUE);
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_MEAS_MID_REF -*/
static ViStatus _VI_FUNC agx2k3kAttrMeasMidRef_CheckCallback (ViSession vi,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViReal64 minimum, maximum;

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEAS_LOW_REF, 0, &minimum));
        checkErr (Ivi_GetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_MEAS_HIGH_REF, 0, &maximum));

        if (value < minimum || value > maximum)
            viCheckErr (IVI_ERROR_INVALID_VALUE);
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_MEASURE_SOURCE -*/
static ViStatus _VI_FUNC agx2k3kAttrMeasureSource_CheckCallback (ViSession vi,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   source1[BUFFER_SIZE], source2[BUFFER_SIZE];

    sscanf (value, "%[^,],%s", source1, source2);

    if ((!strstr (source1, "CHAN") && !strstr (source1, "DIG") && strcmp (source1, "MATH") != 0) ||
        (!strstr (source2, "CHAN") && !strstr (source2, "DIG") && strcmp (source2, "MATH") != 0))
    {
        viCheckErr (IVI_ERROR_INVALID_VALUE);
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrMeasureSource_WriteCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViConstString value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MEAS_SOURCE,
                                        0, value));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrMeasureSource_ReadCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                const ViConstString cacheValue)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MEAS_SOURCE,
                                        0, BUFFER_SIZE, rdBuffer));

    checkErr (Ivi_SetValInStringCallback (vi, AGX2K3K_ATTR_MEASURE_SOURCE, rdBuffer));

Error:
    return error;
}

/*- AGX2K3K_ATTR_MEASURE_DELAY -*/
static ViStatus _VI_FUNC agx2k3kAttrMeasureDelay_CheckCallback (ViSession vi,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  edgeSpec1, edgeSpec2;

    sscanf (value, "DEL,%d,%d", &edgeSpec1, &edgeSpec2);

    checkErr (Ivi_DefaultCheckCallbackViInt32 (vi, VI_NULL, attributeId, edgeSpec1));
    checkErr (Ivi_DefaultCheckCallbackViInt32 (vi, VI_NULL, attributeId, edgeSpec2));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrMeasureDelay_WriteCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViConstString value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MEAS_DELAY,
                                        0, value));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrMeasureDelay_ReadCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               const ViConstString cacheValue)
{
    ViStatus error = VI_SUCCESS;
    ViChar   rdBuffer[BUFFER_SIZE];

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MEAS_DELAY,
                                        0, BUFFER_SIZE, rdBuffer));

    checkErr (Ivi_SetValInStringCallback (vi, AGX2K3K_ATTR_MEASURE_DELAY, rdBuffer));

Error:
    return error;
}

/*- AGX2K3K_ATTR_MEASURE_REF -*/
static ViStatus _VI_FUNC agx2k3kAttrMeasureRef_CheckCallback (ViSession vi,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViConstString value)
{
    /*  This is correct. Range checking provides by functions agx2k3kAttrMeasLowRef_CheckCallback, */
    /*  agx2k3kAttrMeasMidRef_CheckCallback and range table attrMeasHighRefRangeTable. */
    return VI_SUCCESS;
}

static ViStatus _VI_FUNC agx2k3kAttrMeasureRef_WriteCallback (ViSession vi,
                                                              ViSession io,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViConstString value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MEAS_REF,
                                        0, value));

Error:
    return error;
}


/*- AGX2K3K_ATTR_INSTR_MEAS_REF -*/


/*- AGX2K3K_ATTR_MATH_CHANNEL_ENABLED -*/
/* Use common callback functions */


/* AGX2K3K_ATTR_MATH_SOURCE1 & AGX2K3K_ATTR_MATH_SOURCE2 */

/* For basic math operations with Source 1 */
static agx2k3kStringTableEntries mathSimpleOpSource1StringTableEntries[] =
{
    { AGX2K3K_VAL_CHANNEL1, "CHAN1" },
    { AGX2K3K_VAL_CHANNEL2, "CHAN2" },
    { AGX2K3K_VAL_CHANNEL3, "CHAN3" },
    { AGX2K3K_VAL_CHANNEL4, "CHAN4" },
    { VI_NULL,              VI_NULL }
};

static agx2k3kStringTable mathSimpleOpSource1StringTable = mathSimpleOpSource1StringTableEntries;

/* For basic math operations with Source 2 (Channel 1 & 2) */
static agx2k3kStringTableEntries mathSimpleOpSource2Ch12StringTableEntries[] =
{
    { AGX2K3K_VAL_CHANNEL1, "CHAN1" },
    { AGX2K3K_VAL_CHANNEL2, "CHAN2" },
    { VI_NULL,              VI_NULL }
};

static agx2k3kStringTable mathSimpleOpSource2Ch12StringTable = mathSimpleOpSource2Ch12StringTableEntries;

/* For basic math operations with Source 2 (Channel 3 & 4) */
static agx2k3kStringTableEntries mathSimpleOpSource2Ch34StringTableEntries[] =
{
    { AGX2K3K_VAL_CHANNEL3, "CHAN3" },
    { AGX2K3K_VAL_CHANNEL4, "CHAN4" },
    { VI_NULL,              VI_NULL }
};

static agx2k3kStringTable mathSimpleOpSource2Ch34StringTable = mathSimpleOpSource2Ch34StringTableEntries;

/* For complex math operations with Source 1 */
static agx2k3kStringTableEntries mathComplexOpSource1StringTableEntries[] =
{
    { AGX2K3K_VAL_CHANNEL1,          "CHAN1" },
    { AGX2K3K_VAL_CHANNEL2,          "CHAN2" },
    { AGX2K3K_VAL_CHANNEL3,          "CHAN3" },
    { AGX2K3K_VAL_CHANNEL4,          "CHAN4" },
    { AGX2K3K_VAL_MATH_SOURCE1_GOFT, "GOFT"  },
    { VI_NULL,                       VI_NULL }
};

static agx2k3kStringTable mathComplexOpSource1StringTable = mathComplexOpSource1StringTableEntries;

/* For complex math operations with Source 2 */
static agx2k3kStringTableEntries mathComplexOpSource2StringTableEntries[] =
{
    { AGX2K3K_VAL_MATH_SOURCE2_NONE, "NONE"  },
    { VI_NULL,                       VI_NULL }
};

static agx2k3kStringTable mathComplexOpSource2StringTable = mathComplexOpSource2StringTableEntries;

static ViStatus _VI_FUNC agx2k3kAttrMathChannel_CheckCallback (ViSession vi,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViConstString value)
{
    ViStatus           error = VI_SUCCESS;
    ViConstString      sourceNameBuf;
    agx2k3kStringTable table;

    checkErr (agx2k3k_GetMathSourceProperties (vi, attributeId, VI_NULL, &table));

    error = agx2k3k_GetStr2BufFromStr1 (vi, table, value, &sourceNameBuf);
    if (error < VI_SUCCESS)
    {
        error = Ivi_CoerceChannelName (vi, value, &sourceNameBuf);
    }
    viCheckErr (error);

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrMathChannel_WriteCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViConstString value)
{
    ViStatus           error = VI_SUCCESS;
    ViConstString      sourceNameBuf;
    ViAttr             attrHidden;
    agx2k3kStringTable table;

    checkErr (agx2k3k_GetMathSourceProperties (vi, attributeId, &attrHidden, &table));

    checkErr (agx2k3k_GetStr2BufFromStr1 (vi, table, value, &sourceNameBuf));

    checkErr (agx2k3kViString_WriteCallback (vi, io, channelName, attrHidden, value));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrMathChannel_ReadCallback (ViSession vi,
                                                              ViSession io,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              const ViConstString cacheValue)
{
    ViStatus           error = VI_SUCCESS;
    ViConstString      sourceName;
    ViInt32            result;
    ViChar             buffer[BUFFER_SIZE];
    ViAttr             attrHidden;
    agx2k3kStringTable table;

    checkErr (agx2k3k_GetMathSourceProperties (vi, attributeId, &attrHidden, &table));

    checkErr (Ivi_GetAttributeViString (vi, VI_NULL, attrHidden, 0, BUFFER_SIZE, buffer));

    result = agx2k3k_GetStr1PtrFromStr2 (vi, table, &sourceName, buffer);
    if (result < VI_SUCCESS)
    {
        checkErr (Ivi_GetUserChannelName (vi, buffer, &sourceName));
    }

    checkErr (Ivi_SetValInStringCallback (vi, attributeId, sourceName));

Error:
    return error;
}

/*- AGX2K3K_ATTR_MATH_OPERATION -*/
static IviRangeTableEntry attrMathOperationRangeTableEntries[] =
{
    { AGX2K3K_VAL_MATH_OPERATION_ADD,           0, 0, "ADD",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_SUBTRACT,      0, 0, "SUBT", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_MULTIPLY,      0, 0, "MULT", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_INTEGRATE,     0, 0, "INT",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_DIFFERENTIATE, 0, 0, "DIFF", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_FFT,           0, 0, "FFT",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_SQUARE_ROOT,   0, 0, "SQRT", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_GOFT_PLUS,     0, 0, "ADD",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_GOFT_MINUS,    0, 0, "SUBT", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_GOFT_MULTIPLY, 0, 0, "MULT", 0 },
    { AGX2K3K_VAL_MAGNIFY,                      0, 0, "MAGN", 0 },
    { AGX2K3K_VAL_ABSOLUTE,                     0, 0, "ABS",  0 },
    { AGX2K3K_VAL_SQUARE,                       0, 0, "SQU",  0 },
    { AGX2K3K_VAL_LN,                           0, 0, "LN",   0 },
    { AGX2K3K_VAL_LOG,                          0, 0, "LOG",  0 },
    { AGX2K3K_VAL_EXP,                          0, 0, "EXP",  0 },
    { AGX2K3K_VAL_TEN,                          0, 0, "TEN",  0 },
    { AGX2K3K_VAL_LOWPASS,                      0, 0, "LOWP", 0 },
    { AGX2K3K_VAL_HIGHPASS,                     0, 0, "HIGH", 0 },
    { AGX2K3K_VAL_DIVIDE,                       0, 0, "DIV",  0 },
    { AGX2K3K_VAL_LINEAR,                       0, 0, "LIN",  0 },
    { AGX2K3K_VAL_TREND,                        0, 0, "TREN", 0 },
    { AGX2K3K_VAL_BTIMING,                      0, 0, "BTIM", 0 },
    { AGX2K3K_VAL_BSTATE,                       0, 0, "BST",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_AVERAGE,       0, 0, "AVER", 0 }, /* 4X & 3TX */
    { AGX2K3K_VAL_MATH_OPERATION_SMOOTH,        0, 0, "SMO",  0 }, /* 4X & 3TX */
    { AGX2K3K_VAL_MATH_OPERATION_ENVELOPE,      0, 0, "ENV",  0 }, /* 4X & 3TX */
    { AGX2K3K_VAL_MATH_OPERATION_MAXHOLD,       0, 0, "MAXH", 0 }, /* 4X & 3TX */
    { AGX2K3K_VAL_MATH_OPERATION_MINHOLD,       0, 0, "MINH", 0 }, /* 4X & 3TX */
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrMathOperationRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrMathOperationRangeTableEntries,
};

static IviRangeTableEntry attrInstrMathOperationRangeTableEntries[] =
{
    { AGX2K3K_VAL_MATH_OPERATION_ADD,           0, 0, "ADD",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_SUBTRACT,      0, 0, "SUBT", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_MULTIPLY,      0, 0, "MULT", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_INTEGRATE,     0, 0, "INT",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_DIFFERENTIATE, 0, 0, "DIFF", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_FFT,           0, 0, "FFT",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_SQUARE_ROOT,   0, 0, "SQRT", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_MAGNIFY,       0, 0, "MAGN", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_ABSOLUTE,      0, 0, "ABS",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_SQUARE,        0, 0, "SQU",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_LN,            0, 0, "LN",   0 },
    { AGX2K3K_VAL_MATH_OPERATION_LOG,           0, 0, "LOG",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_EXP,           0, 0, "EXP",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_TEN,           0, 0, "TEN",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_LOWPASS,       0, 0, "LOWP", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_HIGHPASS,      0, 0, "HIGH", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_DIVIDE,        0, 0, "DIV",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_LINEAR,        0, 0, "LIN",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_TREND,         0, 0, "TREN", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_BTIMING,       0, 0, "BTIM", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_BSTATE,        0, 0, "BST",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_AVERAGE,       0, 0, "AVER", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_SMOOTH,        0, 0, "SMO",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_ENVELOPE,      0, 0, "ENV",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_MAXHOLD,       0, 0, "MAXH", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_MINHOLD,       0, 0, "MINH", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_CLOCK,         0, 0, "CLOC", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_NONE,          0, 0, "",     0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrInstrMathOperationRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrInstrMathOperationRangeTableEntries,
};

/*- AGX2K3K_ATTR_INSTR_MATH_GOFT_OPERATION -*/
static IviRangeTableEntry attrMathGoftOperationRangeTableEntries[] =
{
    { AGX2K3K_VAL_MATH_OPERATION_GOFT_PLUS,     0, 0, "ADD",  0 },
    { AGX2K3K_VAL_MATH_OPERATION_GOFT_MINUS,    0, 0, "SUBT", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_GOFT_MULTIPLY, 0, 0, "MULT", 0 },
    { AGX2K3K_VAL_MATH_OPERATION_NONE,          0, 0, "",     0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrMathGoftOperationRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrMathGoftOperationRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrMathOperation_WriteCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViInt32 value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  modelType;

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       0, &modelType));

    if (!IS_4000_SERIES (modelType) && !IS_6000_SERIES (modelType))
    {
        /* If the user is going to set g(t) operation, send command with *
         * AGX2K3K_ATTR_INSTR_MATH_GOFT_OPERATION                         */
        if (value == AGX2K3K_VAL_MATH_OPERATION_GOFT_PLUS
            ||
            value == AGX2K3K_VAL_MATH_OPERATION_GOFT_MINUS
            ||
            value == AGX2K3K_VAL_MATH_OPERATION_GOFT_MULTIPLY)
        {
            checkErr (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MATH_GOFT_OPERATION, 0, value));
            checkErr (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MATH_OPERATION, 0, AGX2K3K_VAL_MATH_OPERATION_NONE));
        }
        else
        {
            checkErr (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MATH_OPERATION, 0, value));
            checkErr (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MATH_GOFT_OPERATION, 0, AGX2K3K_VAL_MATH_OPERATION_NONE));
        }
    }
    else
    {
        checkErr (Ivi_SetAttributeViInt32 (vi, channelName, AGX2K3K_ATTR_INSTR_MATH_OPERATION_MULTICHANNEL, 0, value));
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrMathOperation_ReadCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViInt32 *value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  mathRet;
    ViInt32  goftRet;

    ViInt32  modelType;

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       0, &modelType));

    if (!IS_4000_SERIES (modelType) && !IS_6000_SERIES (modelType))
    {
        checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MATH_OPERATION, 0, &mathRet));
        checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MATH_GOFT_OPERATION, 0, &goftRet));

        if (goftRet != AGX2K3K_VAL_MATH_OPERATION_NONE)
        {
            *value = goftRet;
        }
        else if (mathRet != AGX2K3K_VAL_MATH_OPERATION_NONE)
        {
            *value = mathRet;
        }
    }
    else
    {
        checkErr (Ivi_GetAttributeViInt32 (vi, channelName, AGX2K3K_ATTR_INSTR_MATH_OPERATION_MULTICHANNEL, 0, &mathRet));
        if (mathRet != AGX2K3K_VAL_MATH_OPERATION_NONE)
        {
            *value = mathRet;
        }
    }


Error:
    return error;
}

/*- AGX2K3K_ATTR_MATH_SCALE -*/
static IviRangeTableEntry attrMathScaleDifferentiateRangeTableEntries[] =
{
    { 1.00e-03, 1.00e+03, 5.00e+01, "", 0 },
    { 1.00e-03, 1.00e+03, 2.00e+01, "", 0 },
    { 1.00e-03, 1.00e+03, 1.00e+01, "", 0 },
    { 1.00e-02, 1.00e+04, 5.00e+00, "", 0 },
    { 1.00e-02, 1.00e+04, 2.00e+00, "", 0 },
    { 1.00e-02, 1.00e+04, 1.00e+00, "", 0 },
    { 1.00e-01, 1.00e+05, 5.00e-01, "", 0 },
    { 1.00e-01, 1.00e+05, 2.00e-01, "", 0 },
    { 1.00e-01, 1.00e+05, 1.00e-01, "", 0 },
    { 1.00e+00, 1.00e+06, 5.00e-02, "", 0 },
    { 1.00e+00, 1.00e+06, 2.00e-02, "", 0 },
    { 1.00e+00, 1.00e+06, 1.00e-02, "", 0 },
    { 1.00e+01, 1.00e+07, 5.00e-03, "", 0 },
    { 1.00e+01, 1.00e+07, 2.00e-03, "", 0 },
    { 1.00e+01, 1.00e+07, 1.00e-03, "", 0 },
    { 1.00e+02, 1.00e+08, 5.00e-04, "", 0 },
    { 1.00e+02, 1.00e+08, 2.00e-04, "", 0 },
    { 1.00e+02, 1.00e+08, 1.00e-04, "", 0 },
    { 1.00e+03, 1.00e+09, 5.00e-05, "", 0 },
    { 1.00e+03, 1.00e+09, 2.00e-05, "", 0 },
    { 1.00e+03, 1.00e+09, 1.00e-05, "", 0 },
    { 1.00e+04, 1.00e+10, 5.00e-06, "", 0 },
    { 1.00e+04, 1.00e+10, 2.00e-06, "", 0 },
    { 1.00e+04, 1.00e+10, 1.00e-06, "", 0 },
    { 1.00e+05, 1.00e+11, 5.00e-07, "", 0 },
    { 1.00e+05, 1.00e+11, 2.00e-07, "", 0 },
    { 1.00e+05, 1.00e+11, 1.00e-07, "", 0 },
    { 1.00e+06, 1.00e+11, 5.00e-08, "", 0 },
    { 1.00e+06, 1.00e+11, 2.00e-08, "", 0 },
    { 1.00e+06, 1.00e+11, 1.00e-08, "", 0 },
    { 1.00e+07, 1.00e+11, 5.00e-09, "", 0 },
    { 1.00e+07, 1.00e+11, 2.00e-09, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrMathScaleDifferentiateRangeTable =
{
    IVI_VAL_RANGED,
    VI_FALSE,
    VI_FALSE,
    "",
    attrMathScaleDifferentiateRangeTableEntries,
};

static IviRangeTableEntry attrMathScaleIntegrateRangeTableEntries[] =
{
    { 1.00e-02, 1.00e+04, 5.00e+01, "", 0 },
    { 1.00e-02, 1.00e+03, 2.00e+01, "", 0 },
    { 1.00e-02, 1.00e+03, 1.00e+01, "", 0 },
    { 1.00e-03, 1.00e+03, 5.00e+00, "", 0 },
    { 1.00e-03, 1.00e+02, 2.00e+00, "", 0 },
    { 1.00e-03, 1.00e+02, 1.00e+00, "", 0 },
    { 1.00e-04, 1.00e+02, 5.00e-01, "", 0 },
    { 1.00e-04, 1.00e+01, 2.00e-01, "", 0 },
    { 1.00e-04, 1.00e+01, 1.00e-01, "", 0 },
    { 1.00e-05, 1.00e+01, 5.00e-02, "", 0 },
    { 1.00e-05, 1.00e+00, 2.00e-02, "", 0 },
    { 1.00e-05, 1.00e+00, 1.00e-02, "", 0 },
    { 1.00e-06, 1.00e+00, 5.00e-03, "", 0 },
    { 1.00e-06, 1.00e-01, 2.00e-03, "", 0 },
    { 1.00e-06, 1.00e-01, 1.00e-03, "", 0 },
    { 1.00e-07, 1.00e-01, 5.00e-04, "", 0 },
    { 1.00e-07, 1.00e-02, 2.00e-04, "", 0 },
    { 1.00e-07, 1.00e-02, 1.00e-04, "", 0 },
    { 1.00e-08, 1.00e-02, 5.00e-05, "", 0 },
    { 1.00e-08, 1.00e-03, 2.00e-05, "", 0 },
    { 1.00e-08, 1.00e-03, 1.00e-05, "", 0 },
    { 1.00e-09, 1.00e-03, 5.00e-06, "", 0 },
    { 1.00e-09, 1.00e-04, 2.00e-06, "", 0 },
    { 1.00e-09, 1.00e-04, 1.00e-06, "", 0 },
    { 1.00e-10, 1.00e-04, 5.00e-07, "", 0 },
    { 1.00e-10, 1.00e-05, 2.00e-07, "", 0 },
    { 1.00e-10, 1.00e-05, 1.00e-07, "", 0 },
    { 1.00e-11, 1.00e-05, 5.00e-08, "", 0 },
    { 1.00e-11, 1.00e-06, 2.00e-08, "", 0 },
    { 1.00e-11, 1.00e-06, 1.00e-08, "", 0 },
    { 1.00e-12, 1.00e-06, 5.00e-09, "", 0 },
    { 1.00e-12, 1.00e-07, 2.00e-09, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrMathScaleIntegrateRangeTable =
{
    IVI_VAL_RANGED,
    VI_FALSE,
    VI_FALSE,
    "",
    attrMathScaleIntegrateRangeTableEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrMathScale_CheckCallback (ViSession vi,
                                                             ViConstString channelName,
                                                             ViAttr attributeId,
                                                             ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  operation;
    ViReal64 minimum = 0, maximum = 0;
    ViReal64 scale;
    ViInt32  modelType;

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       0, &modelType));
    if (Ivi_RangeChecking (vi))
    {
        if (!IS_4000_SERIES (modelType) && !IS_6000_SERIES (modelType))
        {
            checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_INSTR_MATH_OPERATION, 0, &operation));
        }
        else
        {
            checkErr (Ivi_GetAttributeViInt32 (vi, channelName, AGX2K3K_ATTR_INSTR_MATH_OPERATION_MULTICHANNEL, 0, &operation));
        }

        switch (operation)
        {
        case AGX2K3K_VAL_MATH_OPERATION_ADD:
        case AGX2K3K_VAL_MATH_OPERATION_SUBTRACT:
        case AGX2K3K_VAL_MATH_OPERATION_MULTIPLY:
        {
            minimum = 10.0e-3;
            maximum = 100.0;
        } break;

        case AGX2K3K_VAL_MATH_OPERATION_INTEGRATE:
        {
            checkErr (Ivi_GetAttributeViReal64 (vi,
                                                VI_NULL,
                                                AGX2K3K_ATTR_TIMEBASE_SCALE,
                                                0,
                                                &scale));

            viCheckErr (Ivi_GetViReal64EntryFromCoercedVal (scale,
                                                            &attrMathScaleIntegrateRangeTable,
                                                            &minimum,
                                                            &maximum,
                                                            VI_NULL, VI_NULL, VI_NULL));
        } break;

        case AGX2K3K_VAL_MATH_OPERATION_DIFFERENTIATE:
        {
            checkErr (Ivi_GetAttributeViReal64 (vi,
                                                VI_NULL,
                                                AGX2K3K_ATTR_TIMEBASE_SCALE,
                                                0,
                                                &scale));

            viCheckErr (Ivi_GetViReal64EntryFromCoercedVal (scale,
                                                            &attrMathScaleDifferentiateRangeTable,
                                                            &minimum,
                                                            &maximum,
                                                            VI_NULL, VI_NULL, VI_NULL));
        } break;

        case AGX2K3K_VAL_MATH_OPERATION_SQUARE_ROOT:
        {
            minimum = 0.1;
            maximum = 10;
        } break;

        case AGX2K3K_VAL_MATH_OPERATION_FFT:
        {
            minimum = 1.0;
            maximum = 100.0;
        } break;

        case AGX2K3K_VAL_MATH_OPERATION_MAGNIFY:
        case AGX2K3K_VAL_MATH_OPERATION_ABSOLUTE:
        case AGX2K3K_VAL_MATH_OPERATION_SQUARE:
        case AGX2K3K_VAL_MATH_OPERATION_LN:
        case AGX2K3K_VAL_MATH_OPERATION_LOG:
        case AGX2K3K_VAL_MATH_OPERATION_EXP:
        case AGX2K3K_VAL_MATH_OPERATION_TEN:
        case AGX2K3K_VAL_MATH_OPERATION_LOWPASS:
        case AGX2K3K_VAL_MATH_OPERATION_HIGHPASS:
        case AGX2K3K_VAL_MATH_OPERATION_DIVIDE:
        case AGX2K3K_VAL_MATH_OPERATION_LINEAR:
        case AGX2K3K_VAL_MATH_OPERATION_TREND:
        case AGX2K3K_VAL_MATH_OPERATION_BTIMING:
        case AGX2K3K_VAL_MATH_OPERATION_BSTATE:
        case AGX2K3K_VAL_MATH_OPERATION_AVERAGE:
        case AGX2K3K_VAL_MATH_OPERATION_SMOOTH:
        case AGX2K3K_VAL_MATH_OPERATION_ENVELOPE:
        case AGX2K3K_VAL_MATH_OPERATION_MAXHOLD:
        case AGX2K3K_VAL_MATH_OPERATION_MINHOLD:
        {
            minimum = 0.1;
            maximum = 1.0;
        }
        break;
        }

        if (value < minimum || value > maximum)
            viCheckErr (IVI_ERROR_INVALID_VALUE);
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_MATH_OFFSET -*/
static ViStatus _VI_FUNC agx2k3kAttrMathOffset_CheckCallback (ViSession vi,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViReal64 value)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_DefaultCheckCallbackViReal64 (vi, channelName, attributeId, value));

Error:
    return error;
}

/*- AGX2K3K_ATTR_MATH_SPAN -*/
static IviRangeTableEntry attrMathSpanRangeTableEntries[] =
{
    { 1.0, 100.0e9, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrMathSpanRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrMathSpanRangeTableEntries,
};

/*- AGX2K3K_ATTR_MATH_CENTER -*/
static IviRangeTableEntry attrMathCenterRangeTableEntries[] =
{
    { 0.0, 25.0e9, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrMathCenterRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrMathCenterRangeTableEntries,
};

/*- AGX2K3K_ATTR_MATH_WINDOW -*/
static IviRangeTableEntry attrMathWindowRangeTableEntries[] =
{
    { AGX2K3K_VAL_MATH_WINDOW_HANNING,         0, 0, "HANN", 0 },
    { AGX2K3K_VAL_MATH_WINDOW_FLATTOP,         0, 0, "FLAT", 0 },
    { AGX2K3K_VAL_MATH_WINDOW_RECTANGULAR,     0, 0, "RECT", 0 },
    { AGX2K3K_VAL_MATH_WINDOW_BLACKMAN_HARRIS, 0, 0, "BHAR", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrMathWindowRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrMathWindowRangeTableEntries,
};

/* AGX2K3K_ATTR_MATH_SMOOTH_POINTS */
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_MATH_FFT_FREQUENCY_START */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_MATH_FFT_FREQUENCY_STOP */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */


/*- AGX2K3K_ATTR_WAVEGEN_FREQUENCY -*/
static IviRangeTableEntry attrWavegenFrequencyRangeTableEntries[] =
{
    { 0.1, 20.0e6, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrWavegenFrequencyRangeTable =
{
    IVI_VAL_RANGED,
    VI_FALSE,
    VI_TRUE,
    "",
    attrWavegenFrequencyRangeTableEntries,
};

/*- AGX2K3K_ATTR_WAVEGEN_FUNCTION -*/
static IviRangeTableEntry attrWavegenFunctionRangeTableEntries[] =
{
    { AGX2K3K_VAL_WAVEGEN_SINE,   0, 0, "SIN",  0 },
    { AGX2K3K_VAL_WAVEGEN_SQUARE, 0, 0, "SQU",  0 },
    { AGX2K3K_VAL_WAVEGEN_RAMP,   0, 0, "RAMP", 0 },
    { AGX2K3K_VAL_WAVEGEN_PULSE,  0, 0, "PULS", 0 },
    { AGX2K3K_VAL_WAVEGEN_DC,     0, 0, "NOIS", 0 },
    { AGX2K3K_VAL_WAVEGEN_NOISE,  0, 0, "DC",   0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrWavegenFunctionRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrWavegenFunctionRangeTableEntries,
};

/*- AGX2K3K_ATTR_WAVEGEN_PERIOD -*/
static IviRangeTableEntry attrWavegenPeriodRangeTableEntries[] =
{
    { 50.0e-9, 10.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrWavegenPeriodRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrWavegenPeriodRangeTableEntries,
};
/*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH -*/
static ViStatus _VI_FUNC agx2k3kAttrWavegenPulseWidth_CheckCallback (ViSession vi,
                                                                     ViConstString channelName,
                                                                     ViAttr attributeId,
                                                                     ViReal64 value)
{
    ViStatus error = VI_SUCCESS;
    ViReal64 minValue, maxValue;


    checkErr (Ivi_GetAttributeViReal64 (vi, channelName, AGX2K3K_ATTR_WAVEGEN_PERIOD,
                                        0, &maxValue));

    maxValue = maxValue > 20e-9;
    if (maxValue < 20e-9)
    {
        maxValue = 20e-9;
    }
    minValue = 20e-9;

    if (value < minValue || value > maxValue)
    {
        viCheckErr (IVI_ERROR_INVALID_VALUE);
    }

Error:
    return error;
}

/*- AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY -*/
static IviRangeTableEntry attrWavegenRampSymmetryRangeTableEntries[] =
{
    { 0.0, 100.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrWavegenRampSymmetryRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrWavegenRampSymmetryRangeTableEntries,
};

/*- AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE -*/
static IviRangeTableEntry attrWavegenSquareDutyCycleRangeTableEntries[] =
{
    { 20.0, 80.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrWavegenSquareDutyCycleRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrWavegenSquareDutyCycleRangeTableEntries,
};

/*- AGX2K3K_ATTR_WAVEGEN_RESET -*/
static ViStatus _VI_FUNC agx2k3kAttrWavegenReset_WriteCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViBoolean value)
{
    ViStatus error = VI_SUCCESS;
    ViString cmd;

    viCheckErr (Ivi_GetStringFromTable (gs_ViBooleanCommands, attributeId, &cmd));
    if (!Ivi_Simulating (vi))
    {
        if (value == VI_TRUE)
        {
            error = viPrintf (io, "%s", cmd);
        }
        viCheckErr (error);
    }
Error:
    return error;
}

/*- AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE -*/
/* Use common callback functions */

/*- AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE -*/
static IviRangeTableEntry attrWavegenLoadImpedanceRangeTableEntries[] =
{
    { AGX2K3K_VAL_WAVEGEN_IMP_FIFTY,    0, 0, "FIFT", 0 },
    { AGX2K3K_VAL_WAVEGEN_IMP_ONE_MEGA, 0, 0, "ONEM", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrWavegenLoadImpedanceRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrWavegenLoadImpedanceRangeTableEntries,
};

/* AGX2K3K_ATTR_WMEMORY_COPY */
static ViStatus _VI_FUNC agx2k3kAttrWmemoryCopy_CheckCallback (ViSession vi,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  mathOper;

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViInt32 (vi,
                                           VI_NULL,
                                           AGX2K3K_ATTR_MATH_OPERATION,
                                           0, &mathOper));

        if (strncmp (value, "FUNC", 4) == 0)
        {
            if (mathOper != AGX2K3K_VAL_MATH_OPERATION_ADD && mathOper != AGX2K3K_VAL_MATH_OPERATION_SUBTRACT)
            {
                viCheckErr (IVI_ERROR_INVALID_VALUE);
            }
        }
        else if (strncmp (value, "CHAN", 4) == 0)
        {
            /*  Do nothing. */
        }
        else
        {
            viCheckErr (IVI_ERROR_INVALID_VALUE);
        }
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_WMEMORY_SKEW */
static IviRangeTableEntry attrWmemorySkewRangeTableEntries[] =
{
    { -1.0, 1.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrWmemorySkewRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrWmemorySkewRangeTableEntries,
};


/* AGX2K3K_ATTR_WMEMORY_Y_OFFSET */
static IviRangeTableEntry attrWmemoryYOffsetRangeTableEntries[] =
{
    { -50.0, 50.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrWmemoryYOffsetRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrWmemoryYOffsetRangeTableEntries,
};

/* AGX2K3K_ATTR_WMEMORY_Y_RANGE */
static IviRangeTableEntry attrWmemoryYRangeRangeTableEntries[] =
{
    { 16e-3, 40.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrWmemoryYRangeRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrWmemoryYRangeRangeTableEntries,
};

/* AGX2K3K_ATTR_WMEMORY_Y_SCALE */
static IviRangeTableEntry attrWmemoryYScaleRangeTableEntries[] =
{
    { 2e-3, 5.0, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};
static IviRangeTable      attrWmemoryYScaleRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    "",
    attrWmemoryYScaleRangeTableEntries,
};

/* AGX2K3K_ATTR_RECALL_WMEMORY_FILE_PATH */
/* Use common callback functions */

/* AGX2K3K_ATTR_SAVE_WMEMORY_SOURCE */
static ViStatus _VI_FUNC agx2k3kAttrSaveWmemory_CheckCallback (ViSession vi,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  mathOper;

    if (Ivi_RangeChecking (vi))
    {
        checkErr (Ivi_GetAttributeViInt32 (vi,
                                           VI_NULL,
                                           AGX2K3K_ATTR_MATH_OPERATION,
                                           0, &mathOper));

        if (strncmp (value, "FUNC", 4) == 0)
        {
            if (mathOper != AGX2K3K_VAL_MATH_OPERATION_ADD && mathOper != AGX2K3K_VAL_MATH_OPERATION_SUBTRACT)
            {
                viCheckErr (IVI_ERROR_INVALID_VALUE);
            }
        }
        else if ((strncmp (value, "CHAN", 4) == 0) || (strncmp (value, "WMEM", 4) == 0))
        {
            /*  Do nothing. */
        }
        else
        {
            viCheckErr (IVI_ERROR_INVALID_VALUE);
        }
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SAVE_WMEMORY_FILE_PATH */
/* Use common callback functions */

/* AGX2K3K_ATTR_DVM_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_DVM_AUTO_RANGE_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_DVM_CURRENT */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_DVM_FREQUENCY */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_DVM_MODE */
static IviRangeTableEntry attrDvmModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_DVM_MODE_ACRMS,     0, 0, "ACRM", 0 },
    { AGX2K3K_VAL_DVM_MODE_DC,        0, 0, "DC",   0 },
    { AGX2K3K_VAL_DVM_MODE_DCRMS,     0, 0, "DCRM", 0 },
    { AGX2K3K_VAL_DVM_MODE_FREQUENCY, 0, 0, "FREQ", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrDvmModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrDvmModeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_DVM_ANALOG_SOURCE */
static IviRangeTableEntry attrDvmAnalogSourceRangeTableEntries[] =
{
    { AGX2K3K_VAL_DVM_ANALOG_CHANNEL_1, 0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_DVM_ANALOG_CHANNEL_2, 0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_DVM_ANALOG_CHANNEL_3, 0, 0, "CHAN3", 0 },
    { AGX2K3K_VAL_DVM_ANALOG_CHANNEL_4, 0, 0, "CHAN4", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrDvmAnalogSourceRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrDvmAnalogSourceRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_REFERENCE_SIGNAL_MODE */
static IviRangeTableEntry attrReferenceSignalModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_REFERENCE_SIGNAL_MODE_OFF, 0, 0, "OFF", 0 },
    { AGX2K3K_VAL_REFERENCE_SIGNAL_MODE_OUT, 0, 0, "OUT", 0 },
    { AGX2K3K_VAL_REFERENCE_SIGNAL_MODE_IN,  0, 0, "IN",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrReferenceSignalModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrReferenceSignalModeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_FUNCTION_VERTICAL_AXIS */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_FUNCTION_REFERENCE_LEVEL */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_FUNCTION_NUM_AVERAGES */
static IviRangeTableEntry attrFunctionNumAveragesRangeTableEntries[] =
{
    { 2, 65536, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrFunctionNumAveragesRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrFunctionNumAveragesRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_MEASURE_POWER_PHASE_ANGLE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_APPARENT_POWER */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_AREA */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_POWER_LOSS_PER_CYCLE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_CREST_FACOTR */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_ENERGY_LOSS */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_POWER_FACTOR */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_INPUT_POWER */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_OFF_TIME */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_ON_TIME */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_OUTPUT_POWER */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_POWER_LOSS */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_REACTIVE_POWER */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_REAL_POWER */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_CONTINUOUSLY_DISPLAYED_RESULTS */
/* use common read callback agx2k3kViString_ReadCallback */

/* AGX2K3K_ATTR_MEASURE_INFORMATION_TYPE */
static IviRangeTableEntry attrMeasureInformationTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_MEASURE_STATISTICS_MODE_ON,      0, 0, "ON",   0 },
    { AGX2K3K_VAL_MEASURE_STATISTICS_MODE_CURRENT, 0, 0, "CURR", 0 },
    { AGX2K3K_VAL_MEASURE_STATISTICS_MODE_MINIMUM, 0, 0, "MIN",  0 },
    { AGX2K3K_VAL_MEASURE_STATISTICS_MODE_MAXIMUM, 0, 0, "MAX",  0 },
    { AGX2K3K_VAL_MEASURE_STATISTICS_MODE_MEAN,    0, 0, "MEAN", 0 },
    { AGX2K3K_VAL_MEASURE_STATISTICS_MODE_STDDEV,  0, 0, "STDD", 0 },
    { AGX2K3K_VAL_MEASURE_STATISTICS_MODE_COUNT,   0, 0, "COUN", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrMeasureInformationTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrMeasureInformationTypeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_POWER_HARMONICS_TABLE */
/* use common read callback agx2k3kViString_ReadCallback */

/* AGX2K3K_ATTR_POWER_HARMONICS_FAIL_COUNT */
/* use common read callback agx2k3kViInt32_ReadCallback */

/* AGX2K3K_ATTR_POWER_HARMONICS_POWER_FACTOR */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_POWER_HARMONICS_RUN_ITERATION_COUNT */
/* use common read callback agx2k3kViInt32_ReadCallback */

/* AGX2K3K_ATTR_POWER_HARMONICS_FAIL_PASS_STATUS */
static IviRangeTableEntry attrPowerHarmonicsFailPassStatusRangeTableEntries[] =
{
    { AGX2K3K_VAL_POWER_HARMONICS_STATUS_PASS,     0, 0, "PASS", 0 },
    { AGX2K3K_VAL_POWER_HARMONICS_STATUS_FAIL,     0, 0, "FAIL", 0 },
    { AGX2K3K_VAL_POWER_HARMONICS_STATUS_UNTESTED, 0, 0, "UNT",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrPowerHarmonicsFailPassStatusRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrPowerHarmonicsFailPassStatusRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* AGX2K3K_ATTR_POWER_HARMONICS_TOTAL_DISTORTION */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* AGX2K3K_ATTR_POWER_HARMONICS_CYCLE_COUNT */
static IviRangeTableEntry attrPowerHarmonicsCycleCountRangeTableEntries[] =
{
    { 1, 100, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrPowerHarmonicsCycleCountRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrPowerHarmonicsCycleCountRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_POWER_QUALITY_CYCLE_COUNT */
static IviRangeTableEntry attrPowerHarmonicsCycleQualityRangeTableEntries[] =
{
    { 1, 100, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrPowerHarmonicsCycleQualityRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrPowerHarmonicsCycleQualityRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_POWER_EFFICIENCY_DURATION */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_POWER_MODULATION_DURATION */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_POWER_OFF_DURAQTION */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_POWER_ON_DURATION */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_POWER_RIPPLE_DURATION */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_POWER_TRANSIENT_DURATION */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_POWER_IRUSH_AMPLITUDE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_POWER_IRUSH_MAX_VOLTAGE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_POWER_OFF_MAX_VOLTAGE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_POWER_ON_MAX_VOLTAGE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_POWER_OFF_DC_VOLTAGE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_POWER_ON_DC_VOLTAGE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_POWER_TRANSIENT_DC_VOLTAGE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */


/* AGX2K3K_ATTR_POWER_CLRESPONSE_FREQUENCY_START */

static IviRangeTableEntry attrPowerCLResponseFrequencyStartRangeTableEntries[] =
{
    {       0,       49,       20, "20",       0 },
    {      50,      499,      100, "100",      0 },
    {     500,     4999,     1000, "1000",     0 },
    {    5000,    49999,    10000, "10000",    0 },
    {   50000,   499999,   100000, "100000",   0 },
    {  500000,  4999999,  1000000, "1000000",  0 },
    { 5000000, 10000000, 10000000, "10000000", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrPowerCLResponseFrequencyStartRangeTable =
{
    IVI_VAL_COERCED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrPowerCLResponseFrequencyStartRangeTableEntries,
};

/* AGX2K3K_ATTR_POWER_CLRESPONSE_FREQUENCY_STOP */
static IviRangeTableEntry attrPowerCLResponseFrequencyStopRangeTableEntries[] =
{
    {        0,      499,      100, "100",      0 },
    {      500,     4999,     1000, "1000",     0 },
    {     5000,    49999,    10000, "10000",    0 },
    {    50000,   499999,   100000, "100000",   0 },
    {   500000,  4999999,  1000000, "1000000",  0 },
    {  5000000, 14999999, 10000000, "10000000", 0 },
    { 15000000, 20000000, 20000000, "20000000", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrPowerCLResponseFrequencyStopRangeTable =
{
    IVI_VAL_COERCED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrPowerCLResponseFrequencyStopRangeTableEntries,
};

/* AGX2K3K_ATTR_POWER_CLRESPONSE_YMAXIMUM */
static IviRangeTableEntry attrPowerCLResponseYMaximumRangeTableEntries[] =
{
    { -110, 120, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrPowerCLResponseYMaximumRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrPowerCLResponseYMaximumRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_POWER_CLRESPONSE_YMINIMUM */
static IviRangeTableEntry attrPowerCLResponseYMinmumRangeTableEntries[] =
{
    { -120, 110, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrPowerCLResponseYMinmumRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrPowerCLResponseYMinmumRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_POWER_EFFICIENCY_TYPE */
static IviRangeTableEntry attrPowerEfficiencyTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_POWER_EFFICIENCY_TYPE_DCDC, 0, 0, "DCDC", 0 },
    { AGX2K3K_VAL_POWER_EFFICIENCY_TYPE_DCAC, 0, 0, "DCAC", 0 },
    { AGX2K3K_VAL_POWER_EFFICIENCY_TYPE_ACDC, 0, 0, "ACDC", 0 },
    { AGX2K3K_VAL_POWER_EFFICIENCY_TYPE_ACAC, 0, 0, "ACAC", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrPowerEfficiencyTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrPowerEfficiencyTypeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_POWER_HARMONICS_REAL_POWER_TYPE */
static IviRangeTableEntry attrPowerHarmonicsRealPowerTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_POWER_HARMONICS_REAL_POWER_SOURCE_MEASURED, 0, 0, "MEAS", 0 },
    { AGX2K3K_VAL_POWER_HARMONICS_REAL_POWER_SOURCE_USER,     0, 0, "USER", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrPowerHarmonicsRealPowerTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrPowerHarmonicsRealPowerTypeRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_POWER_HARMONICS_REAL_POWER_VALUE */
static IviRangeTableEntry attrPowerHarmonicsRealPowerValueRangeTableEntries[] =
{
    { 1, 600, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrPowerHarmonicsRealPowerValueRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrPowerHarmonicsRealPowerValueRangeTableEntries,
};
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */



/* AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_CURSOR_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_MASK_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_MEASUREMENT_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_SEARCH_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_SEGMENTED_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */






/* AGX2K3K_ATTR_SBUS_A429_ERROR_COUNT */
/* use common read callback agx2k3kViInt32_ReadCallback */

/* AGX2K3K_ATTR_SBUS_A429_WORD_COUNT */
/* use common read callback agx2k3kViInt32_ReadCallback */

/* AGX2K3K_ATTR_SBUS_A429_TRIGGER_RANGE */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_FLEX_SYNC_FRAME_COUNT */
/* use common read callback agx2k3kViInt32_ReadCallback */

/* AGX2K3K_ATTR_SBUS_FLEX_TOTAL_FRAME_COUNT */
/* use common read callback agx2k3kViInt32_ReadCallback */


/* AGX2K3K_ATTR_SBUS_FLEX_EVENT_TRIGGER_MODE */
static IviRangeTableEntry attrSbusFlexEventTriggerModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_FLEX_EVENT_TRIGGER_MODE_WAKEUP, 0, 0, "WAK", 0 },
    { AGX2K3K_VAL_SBUS_FLEX_EVENT_TRIGGER_MODE_TSS,    0, 0, "TSS", 0 },
    { AGX2K3K_VAL_SBUS_FLEX_EVENT_TRIGGER_MODE_FES,    0, 0, "FES", 0 },
    { AGX2K3K_VAL_SBUS_FLEX_EVENT_TRIGGER_MODE_BSS,    0, 0, "BSS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSbusFlexEventTriggerModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSbusFlexEventTriggerModeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_BASE */
static IviRangeTableEntry attrSbusUsbBaseRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_USB_BASE_HEX,     0, 0, "HEX", 0 },
    { AGX2K3K_VAL_SBUS_USB_BASE_ASCII,   0, 0, "ASC", 0 },
    { AGX2K3K_VAL_SBUS_USB_BASE_BINARY,  0, 0, "BIN", 0 },
    { AGX2K3K_VAL_SBUS_USB_BASE_DECIMAL, 0, 0, "DEC", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSbusUsbBaseRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSbusUsbBaseRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_DIFFERENTIAL_SOURCE */
static IviRangeTableEntry attrSbusUsbDifferentialSourceRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_USB_DIFF_SOURCE_CHANNEL_1, 0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_SBUS_USB_DIFF_SOURCE_CHANNEL_2, 0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_SBUS_USB_DIFF_SOURCE_CHANNEL_3, 0, 0, "CHAN3", 0 },
    { AGX2K3K_VAL_SBUS_USB_DIFF_SOURCE_CHANNEL_4, 0, 0, "CHAN4", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSbusUsbDifferentialSourceRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSbusUsbDifferentialSourceRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_D_MINUS_SOURCE */
static IviRangeTableEntry attrSbusUsbDMinusSourceRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_CHANNEL_1,  0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_CHANNEL_2,  0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_CHANNEL_3,  0, 0, "CHAN3", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_CHANNEL_4,  0, 0, "CHAN4", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_0,  0, 0, "DIG0",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_1,  0, 0, "DIG1",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_2,  0, 0, "DIG2",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_3,  0, 0, "DIG3",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_4,  0, 0, "DIG4",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_5,  0, 0, "DIG5",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_6,  0, 0, "DIG6",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_7,  0, 0, "DIG7",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_8,  0, 0, "DIG8",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_9,  0, 0, "DIG9",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_10, 0, 0, "DIG10", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_11, 0, 0, "DIG11", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_12, 0, 0, "DIG12", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_13, 0, 0, "DIG13", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_14, 0, 0, "DIG14", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_DIGITAL_15, 0, 0, "DIG15", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSbusUsbDMinusSourceRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSbusUsbDMinusSourceRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_D_PLUS_SOURCE */
static IviRangeTableEntry attrSbusUsbDPlusSourceRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_CHANNEL_1,  0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_CHANNEL_2,  0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_CHANNEL_3,  0, 0, "CHAN3", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_CHANNEL_4,  0, 0, "CHAN4", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_0,  0, 0, "DIG0",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_1,  0, 0, "DIG1",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_2,  0, 0, "DIG2",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_3,  0, 0, "DIG3",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_4,  0, 0, "DIG4",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_5,  0, 0, "DIG5",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_6,  0, 0, "DIG6",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_7,  0, 0, "DIG7",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_8,  0, 0, "DIG8",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_9,  0, 0, "DIG9",  0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_10, 0, 0, "DIG10", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_11, 0, 0, "DIG11", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_12, 0, 0, "DIG12", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_13, 0, 0, "DIG13", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_14, 0, 0, "DIG14", 0 },
    { AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_DIGITAL_15, 0, 0, "DIG15", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSbusUsbDPlusSourceRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSbusUsbDPlusSourceRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_SPEED */
static IviRangeTableEntry attrSbusUsbSpeedRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_USB_SPEED_LOW,  0, 0, "LOW",  0 },
    { AGX2K3K_VAL_SBUS_USB_SPEED_FULL, 0, 0, "FULL", 0 },
    { AGX2K3K_VAL_SBUS_USB_SPEED_HIGH, 0, 0, "HIGH", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSbusUsbSpeedRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSbusUsbSpeedRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_MODE */
static IviRangeTableEntry attrSbusUsbTriggerModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_SOP,          0, 0, "SOP",   0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_EOP,          0, 0, "EOP",   0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_ENTERSUSPEND, 0, 0, "ENT",   0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_EXITSUSPEND,  0, 0, "EXIT",  0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_RESET,        0, 0, "RES",   0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_TOKEN,        0, 0, "TOK",   0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_DATA,         0, 0, "DATA",  0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_HANDSHAKE,    0, 0, "HAND",  0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_SPECIAL,      0, 0, "SPEC",  0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_ALLERRORS,    0, 0, "ALL",   0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PIDERROR,     0, 0, "PID",   0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_CRC5ERROR,    0, 0, "CRC5",  0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_CRC16ERROR,   0, 0, "CRC16", 0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_GLITCHERROR,  0, 0, "GLIT",  0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_STUFFERROR,   0, 0, "STUFF", 0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_SE1ERROR,     0, 0, "SE1",   0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSbusUsbTriggerModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSbusUsbTriggerModeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_ADDRESS_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_CRC_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_LENGTH */
static IviRangeTableEntry attrSbusUsbTriggerDataLengthRangeTableEntries[] =
{
    { 1, 20, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSbusUsbTriggerDataLengthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSbusUsbTriggerDataLengthRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_ENDPOINT_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_ET_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_FRAME_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_HUB_ADDRESS_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_PID_CHECK_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PID */
static IviRangeTableEntry attrSbusUsbTriggerDataPidRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_DATA0, 0, 0, "DATA0", 0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_DATA1, 0, 0, "DATA1", 0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_DATA2, 0, 0, "DATA2", 0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_MDATA, 0, 0, "MDAT",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSbusUsbTriggerDataPidRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSbusUsbTriggerDataPidRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_HANDSHAKE_PID */
static IviRangeTableEntry attrSbusUsbTriggerHandshakePidRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_HANDSHAKE_ACK,   0, 0, "ACK",   0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_HANDSHAKE_NAK,   0, 0, "NAK",   0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_HANDSHAKE_STALL, 0, 0, "STALL", 0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_HANDSHAKE_NYET,  0, 0, "NYET",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSbusUsbTriggerHandshakePidRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSbusUsbTriggerHandshakePidRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_SPECIAL_PID */
static IviRangeTableEntry attrSbusUsbTriggerSpecialPidRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_SPECIAL_PID_PING,  0, 0, "PING",  0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_SPECIAL_PID_PRE,   0, 0, "PRE",   0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_SPECIAL_PID_ERR,   0, 0, "ERR",   0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_SPECIAL_PID_SPLIT, 0, 0, "SPLIT", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSbusUsbTriggerSpecialPidRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSbusUsbTriggerSpecialPidRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_TOKEN_PID */
static IviRangeTableEntry attrSbusUsbTriggerTokenPidRangeTableEntries[] =
{
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_TOKEN_OUT,   0, 0, "OUT", 0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_TOKEN_IN,    0, 0, "IN",  0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_TOKEN_SETUP, 0, 0, "SET", 0 },
    { AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_TOKEN_SOF,   0, 0, "SOF", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSbusUsbTriggerTokenPidRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSbusUsbTriggerTokenPidRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_PORT_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_SC_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SBUS_USB_TRIGGER_SEU_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */
/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_ADDRESS_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_CRC_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_LENGTH */
static IviRangeTableEntry attrSearchSerialUsbDataLengthRangeTableEntries[] =
{
    { 1, 20, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSearchSerialUsbDataLengthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSearchSerialUsbDataLengthRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_ENDPOINT_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_ET_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_FRAME_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_HUB_ADDRESS_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_SEARCH_MODE */
static IviRangeTableEntry attrSearchSerialUsbSearchModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_MODE_TOKEN,       0, 0, "TOK",   0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_MODE_DATA,        0, 0, "DATA",  0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_MODE_HANDSHAKE,   0, 0, "HAND",  0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_MODE_SPECIAL,     0, 0, "SPEC",  0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_MODE_ALLERRORS,   0, 0, "ALL",   0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_MODE_PIDERROR,    0, 0, "PID",   0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_MODE_CRC5ERROR,   0, 0, "CRC5",  0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_MODE_CRC16ERROR,  0, 0, "CRC16", 0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_MODE_GLITCHERROR, 0, 0, "GLIT",  0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_MODE_STUFFERROR,  0, 0, "STUFF", 0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_MODE_SE1ERROR,    0, 0, "SE1",   0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSearchSerialUsbSearchModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSearchSerialUsbSearchModeRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_PID */
static IviRangeTableEntry attrSearchSerialUsbDataPidRangeTableEntries[] =
{
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_DATA0, 0, 0, "DATA0", 0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_DATA1, 0, 0, "DATA1", 0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_DATA2, 0, 0, "DATA2", 0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_MDATA, 0, 0, "MDAT",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSearchSerialUsbDataPidRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSearchSerialUsbDataPidRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_HANDSHAKE_PID */
static IviRangeTableEntry attrSearchSerialUsbHandshakePidRangeTableEntries[] =
{
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_HANDSHAKE_ACK,   0, 0, "ACK",   0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_HANDSHAKE_NAK,   0, 0, "NAK",   0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_HANDSHAKE_STALL, 0, 0, "STALL", 0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_HANDSHAKE_NYET,  0, 0, "NYET",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSearchSerialUsbHandshakePidRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSearchSerialUsbHandshakePidRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_SPECIAL_PID */
static IviRangeTableEntry attrSearchSerialUsbSpecialPidRangeTableEntries[] =
{
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_SPECIAL_PID_PING,  0, 0, "PING",  0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_SPECIAL_PID_PRE,   0, 0, "PRE",   0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_SPECIAL_PID_ERR,   0, 0, "ERR",   0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_SPECIAL_PID_SPLIT, 0, 0, "SPLIT", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSearchSerialUsbSpecialPidRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSearchSerialUsbSpecialPidRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_TOKEN_PID */
static IviRangeTableEntry attrSearchSerialUsbTokenPidRangeTableEntries[] =
{
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_TOKEN_OUT,   0, 0, "OUT", 0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_TOKEN_IN,    0, 0, "IN",  0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_TOKEN_SETUP, 0, 0, "SET", 0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_TOKEN_SOF,   0, 0, "SOF", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSearchSerialUsbTokenPidRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSearchSerialUsbTokenPidRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_PORT_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_SC_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_USB_SEU_PORTION */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */


/* AGX2K3K_ATTR_SEARCH_EVENT */
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_PEAK_EXCURSION */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_PEAK_MAXIMUM_PEAKS */
static IviRangeTableEntry attrSearchPeakNumberOfPeaksRangeTableEntries[] =
{
    { 1, 11, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSearchPeakNumberOfPeaksRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSearchPeakNumberOfPeaksRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_PEAK_THRESHOLD */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_MESSAGE */
/* use common read callback agx2k3kViQuotedString_ReadCallback */

/* use common write callback agx2k3kViQuotedString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_SIGNAL */
/* use common read callback agx2k3kViQuotedString_ReadCallback */

/* use common write callback agx2k3kViQuotedString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_VALUE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_FRAME */
/* use common read callback agx2k3kViQuotedString_ReadCallback */

/* use common write callback agx2k3kViQuotedString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_SIGNAL */
/* use common read callback agx2k3kViQuotedString_ReadCallback */

/* use common write callback agx2k3kViQuotedString_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_VALUE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_SENT_MODE */
static IviRangeTableEntry attrSearchSerialSentModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_SEARCH_SERIAL_SENT_MODE_FCDATA,   0, 0, "FCD",  0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_SENT_MODE_SCMID,    0, 0, "SCM",  0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_SENT_MODE_SCDATA,   0, 0, "SCD",  0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_SENT_MODE_CRCERROR, 0, 0, "CRC",  0 },
    { AGX2K3K_VAL_SEARCH_SERIAL_SENT_MODE_PPERROR,  0, 0, "PPER", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSearchSerialSentModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSearchSerialSentModeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_SENT_SLOW_DATA */
static IviRangeTableEntry attrSearchSerialSentSlowDataRangeTableEntries[] =
{
    { -1, 65535, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSearchSerialSentSlowDataRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSearchSerialSentSlowDataRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_SENT_SLOW_ID */
static IviRangeTableEntry attrSearchSerialSentSlowIDRangeTableEntries[] =
{
    { -1, 255, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSearchSerialSentSlowIDRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSearchSerialSentSlowIDRangeTableEntries,
};

/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */


/* AGX2K3K_ATTR_SEARCH_PEAK_SOURCE */
static IviRangeTableEntry attrSearchPeakSourceRangeTableEntries[] =
{
    { AGX2K3K_VAL_SEARCH_PEAK_SOURCE_FUNCTION1, 0, 0, "FUNC1", 0 },
    { AGX2K3K_VAL_SEARCH_PEAK_SOURCE_FUNCTION2, 0, 0, "FUNC2", 0 },
    { AGX2K3K_VAL_SEARCH_PEAK_SOURCE_FUNCTION3, 0, 0, "FUNC3", 0 },
    { AGX2K3K_VAL_SEARCH_PEAK_SOURCE_FUNCTION4, 0, 0, "FUNC4", 0 },
    { AGX2K3K_VAL_SEARCH_PEAK_SOURCE_MATH1,     0, 0, "MATH1", 0 },
    { AGX2K3K_VAL_SEARCH_PEAK_SOURCE_MATH2,     0, 0, "MATH2", 0 },
    { AGX2K3K_VAL_SEARCH_PEAK_SOURCE_MATH3,     0, 0, "MATH3", 0 },
    { AGX2K3K_VAL_SEARCH_PEAK_SOURCE_MATH4,     0, 0, "MATH4", 0 },
    { AGX2K3K_VAL_SEARCH_PEAK_SOURCE_NONE,      0, 0, "NONE",  0 },
    { AGX2K3K_VAL_SEARCH_PEAK_SOURCE_FFT,       0, 0, "FFT",   0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrSearchPeakSourceRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrSearchPeakSourceRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_SEARCH_SERIAL_SENT_FAST_DATA */
/* use common read callback agx2k3kViString_ReadCallback */

/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_FLOAT_ARB_WAVEFORM */
/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_ARB_WAVEFORM_POINT_COUNT */
/* use common read callback agx2k3kViInt32_ReadCallback */


/* AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_DAC_ARB_WAVEFORM */
/* use common write callback agx2k3kViString_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_STORE_ARB_WAVEFORM */
static IviRangeTableEntry attrWavegenStoreArbWaveformRangeTableEntries[] =
{
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_CHANNEL_1,  0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_CHANNEL_2,  0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_CHANNEL_3,  0, 0, "CHAN3", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_CHANNEL_4,  0, 0, "CHAN4", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_WMENORY_1,  0, 0, "WMEN1", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_WMENORY_2,  0, 0, "WMEN2", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_FUNCTION_1, 0, 0, "FUNC1", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_FUNCTION_2, 0, 0, "FUNC2", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_FUNCTION_3, 0, 0, "FUNC3", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_FUNCTION_4, 0, 0, "FUNC4", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_MATH_1,     0, 0, "MATH1", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_MATH_2,     0, 0, "MATH2", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_MATH_3,     0, 0, "MATH3", 0 },
    { AGX2K3K_VAL_STORE_ARB_WAVEFORM_MATH_4,     0, 0, "MATH4", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrWavegenStoreArbWaveformRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrWavegenStoreArbWaveformRangeTableEntries,
};
/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_COUNT */
static IviRangeTableEntry attrWavegenAmModulationCountRangeTableEntries[] =
{
    { 0, 100, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrWavegenAmModulationCountRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrWavegenAmModulationCountRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_FREQUENCY */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_DEVIATION */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_FREQUENCY */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_HOP_FREQUENCY */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_RATE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_MODULATION_SIGNAL_SHAPE */
static IviRangeTableEntry attrWavegenModulationSignalShapeRangeTableEntries[] =
{
    { AGX2K3K_VAL_WAVEGEN_MODULATION_SINEUSOID, 0, 0, "SIN",  0 },
    { AGX2K3K_VAL_WAVEGEN_MODULATION_SQUARE,    0, 0, "SQU",  0 },
    { AGX2K3K_VAL_WAVEGEN_MODULATION_RAMP,      0, 0, "RAMP", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrWavegenModulationSignalShapeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrWavegenModulationSignalShapeRangeTableEntries,
};

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_MODULATION_RAMP_SYMMETRY */
static IviRangeTableEntry attrWavegenModulationRampSymmetryRangeTableEntries[] =
{
    { 0, 100, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrWavegenModulationRampSymmetryRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrWavegenModulationRampSymmetryRangeTableEntries,
};

/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */


/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_MODULATION_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_MODULATION_TYPE */
static IviRangeTableEntry attrWavegenModulationTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_WAVEGEN_MODULATION_TYPE_AM,  0, 0, "AM",  0 },
    { AGX2K3K_VAL_WAVEGEN_MODULATION_TYPE_FM,  0, 0, "FM",  0 },
    { AGX2K3K_VAL_WAVEGEN_MODULATION_TYPE_FSK, 0, 0, "FSK", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrWavegenModulationTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrWavegenModulationTypeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_OUTPUT_POLARITY_INVERTED */
static IviRangeTableEntry attrWavegenOutputPolarityInvertedRangeTableEntries[] =
{
    { AGX2K3K_VAL_GENERATOR_INVERTED, 0, 0, "INV",  0 },
    { AGX2K3K_VAL_GENERATOR_NORMAL,   0, 0, "NORM", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrWavegenOutputPolarityInvertedRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrWavegenOutputPolarityInvertedRangeTableEntries,
};

/* AGX2K3K_ATTR_WAVEGEN_OUTPUT_MODE */
static IviRangeTableEntry attrWaveGenOutputModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_WAVEGEN_OUTPUT_MODE_NORMAL, 0, 0, "NORM", 0 },
    { AGX2K3K_VAL_WAVEGEN_OUTPUT_MODE_SINGLE, 0, 0, "SING", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrWaveGenOutputModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrWaveGenOutputModeRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */


/* AGX2K3K_ATTR_WAVEGEN_TRACK_PHASE */
static IviRangeTableEntry attrWaveGenTracePhaseRangeTableEntries[] =
{
    { -360, 360, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrWaveGenTracePhaseRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrWaveGenTracePhaseRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_TRACKING_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_AMPLITUDE_TRACKING_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_WAVEGEN_FREQUENCY_TRACKING_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_INTERPOLATION */
static IviRangeTableEntry attrInterpolationRangeTableEntries[] =
{
    { AGX2K3K_VAL_LINEAR_INTERPOLATION, 0, 0, "1", 0 },
    { AGX2K3K_VAL_NO_INTERPOLATION,     0, 0, "0", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrInterpolationRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_FALSE,
    VI_FALSE,
    "",
    attrInterpolationRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */


/* AGX2K3K_ATTR_FFT_AVERAGE_COUNT */
static IviRangeTableEntry attrFFTAverageCountRangeTableEntries[] =
{
    { 2, 65536, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrFFTAverageCountRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrFFTAverageCountRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */


/* AGX2K3K_ATTR_FFT_FREQUENCY_CENTER */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */
static IviRangeTableEntry attrFFTFrequencyCenterRangeTableEntries[] =
{
    { -25E+9, 25E+9, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrFFTFrequencyCenterRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrFFTFrequencyCenterRangeTableEntries,
};


/* AGX2K3K_ATTR_FFT_DISPLAY_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_FFT_DISPLAY_MODE */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_FFT_FREQUENCY_START */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_FFT_FREQUENCY_STOP */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */


/* AGX2K3K_ATTR_FFT_VERTICAL_OFFSET */
/* use common read callback agx2k3kViReal64_ReadCallback */
/* use common write callback agx2k3kViReal64_WriteCallback */


/* AGX2K3K_ATTR_FFT_VERTICAL_RANGE */
/* use common read callback agx2k3kViReal64_ReadCallback */
/* use common write callback agx2k3kViReal64_WriteCallback */


/* AGX2K3K_ATTR_FFT_VERTICAL_REFERENCE */
/* use common read callback agx2k3kViReal64_ReadCallback */
/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_FFT_VERTICAL_SCALE */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_FFT_SOURCE1 */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_FFT_FREQUENCY_SPAN */
/* use common read callback agx2k3kViReal64_ReadCallback */

/* use common write callback agx2k3kViReal64_WriteCallback */

/* AGX2K3K_ATTR_FFT_VERTICAL_UNIT */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_FFT_WINDOW */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

static IviRangeTableEntry attrFFTDisplayModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_FFT_DISPLAY_MODE_NORMAL,  0, 0, "NORM", 0 },
    { AGX2K3K_VAL_FFT_DISPLAY_MODE_AVERAGE, 0, 0, "AVER", 0 },
    { AGX2K3K_VAL_FFT_DISPLAY_MODE_MAXHOLD, 0, 0, "MAXH", 0 },
    { AGX2K3K_VAL_FFT_DISPLAY_MODE_MINHOLD, 0, 0, "MINH", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrFFTDisplayModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrFFTDisplayModeRangeTableEntries,
};

static IviRangeTableEntry attrFFTFrequencySpanRangeTableEntries[] =
{
    { 1, 100E+9, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable      attrFFTFrequencySpanRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrFFTFrequencySpanRangeTableEntries,
};
static IviRangeTableEntry attrFFTSourceRangeTableEntries[] =
{
    { AGX2K3K_VAL_FFT_SOURCE_CHANNEL1,  0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_FFT_SOURCE_CHANNEL2,  0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_FFT_SOURCE_CHANNEL3,  0, 0, "CHAN3", 0 },
    { AGX2K3K_VAL_FFT_SOURCE_CHANNEL4,  0, 0, "CHAN4", 0 },
    { AGX2K3K_VAL_FFT_SOURCE_FUNCTION1, 0, 0, "FUNC1", 0 },
    { AGX2K3K_VAL_FFT_SOURCE_FUNCTION2, 0, 0, "FUNC2", 0 },
    { AGX2K3K_VAL_FFT_SOURCE_MATH1,     0, 0, "MATH1", 0 },
    { AGX2K3K_VAL_FFT_SOURCE_MATH2,     0, 0, "MATH2", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrFFTSourceRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrFFTSourceRangeTableEntries,
};


static IviRangeTableEntry attrFFTVerticalUnitRangeTableEntries[] =
{
    { AGX2K3K_VAL_FFT_VERTICAL_UNIT_DECIBEL, 0, 0, "DEC",  0 },
    { AGX2K3K_VAL_FFT_VERTICAL_UNIT_VRMS,    0, 0, "VRMS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrFFTVerticalUnitRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrFFTVerticalUnitRangeTableEntries,
};

static IviRangeTableEntry attrFFTWindowRangeTableEntries[] =
{
    { AGX2K3K_VAL_FFT_WINDOW_RECTANGULAR, 0, 0, "RECT", 0 },
    { AGX2K3K_VAL_FFT_WINDOW_HANNING,     0, 0, "HANN", 0 },
    { AGX2K3K_VAL_FFT_WINDOW_FLATTOP,     0, 0, "FLAT", 0 },
    { AGX2K3K_VAL_FFT_WINDOW_BHARRIS,     0, 0, "BHAR", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrFFTWindowRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrFFTWindowRangeTableEntries,
};



/* AGX2K3K_ATTR_COUNTER_ENABLE */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_COUNTER_MODE */
static IviRangeTableEntry attrCounterModeRangeTable_3KTEntries[] =
{
    { AGX2K3K_VAL_COUNTER_MODE_FREQUENCY, 0, 0, "FREQ", 0 },
    { AGX2K3K_VAL_COUNTER_MODE_PERIOD,    0, 0, "PER",  0 },
    { AGX2K3K_VAL_COUNTER_MODE_TOTALIZE,  0, 0, "TOT",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrCounterModeRangeTable_3KT =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrCounterModeRangeTable_3KTEntries,
};

static IviRangeTableEntry attrCounterModeRangeTable_4KEntries[] =
{
    { AGX2K3K_VAL_COUNTER_MODE_FREQUENCY, 0, 0, "FREQ", 0 },
    { AGX2K3K_VAL_COUNTER_MODE_PERIOD,    0, 0, "PER",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrCounterModeRangeTable_4K =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrCounterModeRangeTable_4KEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrCounterMode_RangeTableCallback (ViSession vi,
                                                                    ViConstString channelName,
                                                                    ViAttr attributeId,
                                                                    IviRangeTablePtr *rangeTablePtr)
{
    ViStatus         error  = VI_SUCCESS;
    IviRangeTablePtr tblPtr = VI_NULL;

    ViInt32          modelType = UNKNOWN;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       0, &modelType));

    if (IS_3000T_SERIES (modelType))
    {
        tblPtr = &attrCounterModeRangeTable_3KT;
    }
    else if (IS_4000_SERIES (modelType) || IS_6000_SERIES (modelType))
    {
        tblPtr = &attrCounterModeRangeTable_4K;
    }
    else
    {
        return IVI_ERROR_ATTRIBUTE_NOT_SUPPORTED;
    }

Error:
    *rangeTablePtr = tblPtr;
    return error;
}
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */



/* AGX2K3K_ATTR_COUNTER_NUMBER_OF_DIGITS */
static IviRangeTableEntry attrCounterNumberOfDigitsRangeTableEntries[] =
{
    { 3, 8, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrCounterNumberOfDigitsRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrCounterNumberOfDigitsRangeTableEntries,
};
/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_COUNTER_SOURCE */
static IviRangeTableEntry attrCounterSourceRangeTable_2ChannelsEntries[] =
{
    { AGX2K3K_VAL_COUNTER_SOURCE_CHANNEL1, 0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_COUNTER_SOURCE_CHANNEL2, 0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_COUNTER_SOURCE_TQEVENT,  0, 0, "TQEV",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable      attrCounterSourceRangeTable_2Channels =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrCounterSourceRangeTable_2ChannelsEntries,
};
static IviRangeTableEntry attrCounterSourceRangeTable_4ChannelsEntries[] =
{
    { AGX2K3K_VAL_COUNTER_SOURCE_CHANNEL1, 0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_COUNTER_SOURCE_CHANNEL2, 0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_COUNTER_SOURCE_CHANNEL3, 0, 0, "CHAN3", 0 },
    { AGX2K3K_VAL_COUNTER_SOURCE_CHANNEL4, 0, 0, "CHAN4", 0 },
    { AGX2K3K_VAL_COUNTER_SOURCE_TQEVENT,  0, 0, "TQEV",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrCounterSourceRangeTable_4Channels =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrCounterSourceRangeTable_4ChannelsEntries,
};
static ViStatus _VI_FUNC agx2k3kAttrCounterSource_RangeTableCallback (ViSession vi,
                                                                      ViConstString channelName,
                                                                      ViAttr attributeId,
                                                                      IviRangeTablePtr *rangeTablePtr)
{
    ViStatus         error  = VI_SUCCESS;
    IviRangeTablePtr tblPtr = VI_NULL;

    ViInt32          modelType = UNKNOWN;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       0, &modelType));

    if (HAS_2CHANNELS (modelType))
    {
        tblPtr = &attrCounterSourceRangeTable_2Channels;
    }
    else if (HAS_4CHANNELS (modelType))
    {
        tblPtr = &attrCounterSourceRangeTable_4Channels;
    }

Error:
    *rangeTablePtr = tblPtr;
    return error;
}
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_ENABLED */
/* use common read callback agx2k3kViBoolean_ReadCallback */

/* use common write callback agx2k3kViBoolean_WriteCallback */

/* AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_POLARITY */
static IviRangeTableEntry attrCounterTotalizerEdgesRangeTableEntries[] =
{
    { AGX2K3K_VAL_COUNTER_TOTALIZER_EDGES_NEGATIVE, 0, 0, "NEG", 0 },
    { AGX2K3K_VAL_COUNTER_TOTALIZER_EDGES_POSITIVE, 0, 0, "POS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrCounterTotalizerEdgesRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrCounterTotalizerEdgesRangeTableEntries,
};
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_SOURCE */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_COUNTER_TOTALIZE_SLOPE */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */



/* AGX2K3K_ATTR_COMPLIANCE_USB_HUBS */

static IviRangeTableEntry attrComplianceUSBHubsNumberRangeTableEntries[] =
{
    { 0, 5, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrComplianceUSBHubsNumberRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrComplianceUSBHubsNumberRangeTableEntries,
};

/* use common read callback agx2k3kViInt32_ReadCallback */

/* use common write callback agx2k3kViInt32_WriteCallback */

/* AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_ADJACENT */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_COMPLIANCE_USB_TEST_CONNECTION */

/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_COMPLIANCE_USB_TEST_TYPE */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DIFFERENTIAL */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DMINUS */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */

/* AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DPLUS */
/* use common read callback agx2k3kEnum_ReadCallback */

/* use common write callback agx2k3kEnum_WriteCallback */


static IviRangeTableEntry attrChannelsRangeTable_2ChannelsEntries[] =
{
    { AGX2K3K_VAL_SOURCE_CHANNEL1, 0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_SOURCE_CHANNEL2, 0, 0, "CHAN2", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrChannelsRangeTable_2Channels =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrChannelsRangeTable_2ChannelsEntries,
};

static IviRangeTableEntry attrChannelsRangeTable_4ChannelsEntries[] =
{
    { AGX2K3K_VAL_SOURCE_CHANNEL1, 0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_SOURCE_CHANNEL2, 0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_SOURCE_CHANNEL3, 0, 0, "CHAN3", 0 },
    { AGX2K3K_VAL_SOURCE_CHANNEL4, 0, 0, "CHAN4", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable attrChannelsRangeTable_4Channels =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    attrChannelsRangeTable_4ChannelsEntries,
};

static ViStatus _VI_FUNC agx2k3kAttrChannels_RangeTableCallback (ViSession vi,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 IviRangeTablePtr *rangeTablePtr)
{
    ViStatus         error  = VI_SUCCESS;
    IviRangeTablePtr tblPtr = VI_NULL;

    ViInt32          modelType = UNKNOWN;

    checkErr (Ivi_GetAttributeViInt32 (vi,
                                       VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       0, &modelType));

    if (HAS_2CHANNELS (modelType))
    {
        tblPtr = &attrChannelsRangeTable_2Channels;
    }
    else if (HAS_4CHANNELS (modelType))
    {
        tblPtr = &attrChannelsRangeTable_4Channels;
    }

Error:
    *rangeTablePtr = tblPtr;
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_CheckPattern
 * Purpose:  This function check the trigger pattern format.
 *****************************************************************************/
static ViStatus agx2k3k_CheckPattern (ViInt32 expectedLength,
                                      ViConstString value)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  i;

    if (strlen (value) != expectedLength)
    {
        checkErr (IVI_ERROR_INVALID_VALUE);
    }
    for (i = 0; i < expectedLength; ++i)
    {
        if (!(value[i] == '0' || value[i] == '1' || value[i] == 'X' ||
              value[i] == 'R' || value[i] == 'F'))
        {
            checkErr (IVI_ERROR_INVALID_VALUE);
        }
    }

Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_GetMathSourceProperties
 * Purpose:  This function returns the associated hidden attribute id and string
 *           table of math source according to the current operation and math
 *           source attribute passed in.
 *****************************************************************************/
static ViStatus agx2k3k_GetMathSourceProperties (ViSession vi,
                                                 ViAttr attributeId,
                                                 ViAttr *            pattrHidden,
                                                 agx2k3kStringTable * pTable)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  iOperation;

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_MATH_OPERATION, 0, &iOperation));

    if (pattrHidden != VI_NULL)
    {
        /* Choose attribute per the current operation */
        if (iOperation == AGX2K3K_VAL_MATH_OPERATION_GOFT_PLUS
            ||
            iOperation == AGX2K3K_VAL_MATH_OPERATION_GOFT_MINUS
            ||
            iOperation == AGX2K3K_VAL_MATH_OPERATION_GOFT_MULTIPLY)
        {
            *pattrHidden = (attributeId == AGX2K3K_ATTR_MATH_SOURCE1 ?
                            AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE1 : AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE2);
        }
        else
        {
            *pattrHidden = (attributeId == AGX2K3K_ATTR_MATH_SOURCE1 ?
                            AGX2K3K_ATTR_INSTR_MATH_SOURCE1 : AGX2K3K_ATTR_INSTR_MATH_SOURCE2);
        }
    }

    if (pTable != VI_NULL)
    {
        /* Choose different range table per the current operation and  *
         * attribute id.                                               */
        if (agx2k3k_IsComplexMathOperation (iOperation))
        {
            *pTable = (attributeId == AGX2K3K_ATTR_MATH_SOURCE1 ?
                       mathComplexOpSource1StringTable : mathComplexOpSource2StringTable);
        }
        else
        {
            /* For simple math operations:                                        *
             * If Channel 1 or Channel 2 is selected for Source1, the Source2     *
             * selection could be Channel 1 or Channel 2. Likewise, if Channel 3  *
             * or Channel 4 is selected for Source1, the Source2 selection can be *
             * Channel 3 or Channel 4.                                            */

            if (attributeId == AGX2K3K_ATTR_MATH_SOURCE1)
                *pTable = mathSimpleOpSource1StringTable;
            else
            {
                ViChar szBuffer[BUFFER_SIZE];
                checkErr (Ivi_GetAttributeViString (vi, VI_NULL,
                                                    AGX2K3K_ATTR_MATH_SOURCE1,
                                                    0, BUFFER_SIZE, szBuffer));

                if (strcmp (szBuffer, AGX2K3K_VAL_CHANNEL1) == 0
                    ||
                    strcmp (szBuffer, AGX2K3K_VAL_CHANNEL2) == 0)
                    *pTable = mathSimpleOpSource2Ch12StringTable;
                else if (strcmp (szBuffer, AGX2K3K_VAL_CHANNEL3) == 0
                         ||
                         strcmp (szBuffer, AGX2K3K_VAL_CHANNEL4) == 0)
                    *pTable = mathSimpleOpSource2Ch34StringTable;
            }
        }
    }

Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_IsSourceDisplayed
 * Purpose:  This function checks whether the specified source is currently
 *           displayed or not.
 * Note:     Call this function when Ivi_LockSession is invoked. It should not
 *           be called when in simulation mode.
 *****************************************************************************/
static ViStatus agx2k3k_IsSourceDisplayed (ViSession vi,
                                           ViSession io,
                                           ViConstString cstrSource,
                                           ViBoolean *   pbDisplayed)
{
    ViStatus error = VI_SUCCESS;

    //viCheckErr (viQueryf (io, ":STAT? %s", "%d", cstrSource, pbDisplayed));
Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_ResetWaveformSource
 * Purpose:  This function find the correct waveform source and set it as the
 *           current wavefor source.
 * Note:     Call this function when Ivi_LockSession is invoked. It should not
 *           be called when in simulation mode.
 *****************************************************************************/
static ViStatus agx2k3k_ResetWaveformSource (ViSession vi,
                                             ViSession io,
                                             ViConstString * pstrSources,
                                             size_t iSourceSize,
                                             ViBoolean *     pbHasFound)
{
    ViStatus  error = VI_SUCCESS;
    size_t    i;
    ViBoolean bDisplayed;

    *pbHasFound = VI_FALSE;

    for (i = 0; i < iSourceSize; ++i)
    {
        checkErr (agx2k3k_IsSourceDisplayed (vi, io, pstrSources[i], &bDisplayed));
        if (bDisplayed)
        {
            /* We found the correct one and let's set it as the current *
             * waveform source.                                         */
            checkErr (Ivi_SetAttributeViString (vi, VI_NULL,
                                                AGX2K3K_ATTR_INSTR_DATA_SOURCE,
                                                0, pstrSources[i]));
            *pbHasFound = VI_TRUE;
            break;
        }
    }

Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_RectifyWaveformSource
 * Purpose:  This function rectifies the current waveform source to the correct
 *           one.
 * Note:     Call this function when Ivi_LockSession is invoked. It should not
 *           be called when in simulation mode.
 *****************************************************************************/
static ViStatus agx2k3k_RectifyWaveformSource (ViSession vi,
                                               ViSession io)
{
    ViStatus      error = VI_SUCCESS;
    ViInt32       iModelType;
    size_t        iDataSourceSize = 0, iChannelSize = 0;
    ViConstString * pDataSources  = NULL,
    * pChannels                   = NULL;
    ViBoolean     bHasFound;

    checkErr (Ivi_GetAttributeViInt32 (vi, VI_NULL,
                                       AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       0, &iModelType));

    /* Determine the channel data sources */
    if (HAS_4CHANNELS (iModelType))
    {
        pChannels    = gpstr4Channels;
        iChannelSize = sizeof (gpstr4Channels) / sizeof (gpstr4Channels[0]);
    }
    else if (HAS_2CHANNELS (iModelType))
    {
        pChannels    = gpstr2Channels;
        iChannelSize = sizeof (gpstr2Channels) / sizeof (gpstr2Channels[0]);
    }

    /* Determine the DSO/MSO data sources */
    if (IS_MSO_INSTR (iModelType))
    {
        pDataSources    = gpstrMSODataSources;
        iDataSourceSize = sizeof (gpstrMSODataSources) / sizeof (gpstrMSODataSources[0]);
    }
    else if (IS_DSO_INSTR (iModelType))
    {
        pDataSources    = gpstrDSODataSources;
        iDataSourceSize = sizeof (gpstrDSODataSources) / sizeof (gpstrDSODataSources[0]);
    }

    /* Find the correct waveform source and set it as the current source */
    checkErr (agx2k3k_ResetWaveformSource (vi, io, pChannels, iChannelSize, &bHasFound));
    if (!bHasFound)
        checkErr (agx2k3k_ResetWaveformSource (vi, io, pDataSources, iDataSourceSize, &bHasFound));

Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_VerifyWaveformSource
 * Purpose:  This function verifies and corrects the current waveform source.
 * Note:     Call this function when Ivi_LockSession is invoked.
 *****************************************************************************/
static ViStatus agx2k3k_VerifyWaveformSource (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
		ViChar    szBuf[BUFFER_SIZE];
		ViBoolean bDisplayed;

        checkErr (Ivi_GetAttributeViString (vi, VI_NULL,
                                            AGX2K3K_ATTR_INSTR_DATA_SOURCE,
                                            0, BUFFER_SIZE, szBuf));

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

        checkErr (agx2k3k_IsSourceDisplayed (vi, io, szBuf, &bDisplayed));

        /* If the current waveform source is not displayed, the source is *
         * incorrect and let's find the correct source.                   */
        //if (!bDisplayed)
            checkErr (agx2k3k_RectifyWaveformSource (vi, io));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    return error;
}

/*****************************************************************************
** HIDDEN ATTRIBUTES ********************************************************
*****************************************************************************/

static IviRangeTableEntry PowerHarmonicsLineRangeTableEntries[] =
{
    { AGX2K3K_VAL_F50,  0, 0, "F50",  0 },
    { AGX2K3K_VAL_F60,  0, 0, "F60",  0 },
    { AGX2K3K_VAL_F400, 0, 0, "F400", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable PowerHarmonicsLineRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    PowerHarmonicsLineRangeTableEntries,
};

static IviRangeTableEntry MarkerXunitRangeTableEntries[] =
{
    { AGX2K3K_VAL_SECONDS,   0, 0, "SEC",  0 },
    { AGX2K3K_VAL_HERTZ,     0, 0, "HERT", 0 },
    { AGX2K3K_VAL_DEGREES,   0, 0, "DEGR", 0 },
    { AGX2K3K_VAL_X_PERCENT, 0, 0, "PERC", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable MarkerXunitRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    MarkerXunitRangeTableEntries,
};

static IviRangeTableEntry MarkerYunitRangeTableEntries[] =
{
    { AGX2K3K_VAL_BASE,      0, 0, "BASE", 0 },
    { AGX2K3K_VAL_Y_PERCENT, 0, 0, "PERC", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable MarkerYunitRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    MarkerYunitRangeTableEntries,
};

static IviRangeTableEntry FunctionVtypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_VTYPE_DECIBEL, 0, 0, "DEC",  0 },
    { AGX2K3K_VAL_VTYPE_VRMS,    0, 0, "VRMS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable FunctionVtypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    FunctionVtypeRangeTableEntries,
};

static IviRangeTableEntry PercentRangeTableEntries[] =
{
    { 0, 100, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable PercentRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    PercentRangeTableEntries,
};

static IviRangeTableEntry SlopeRangeTableEntries[] =
{
    { AGX2K3K_VAL_SLOPE_NEGATIVE, 0, 0, "NEG", 0 },
    { AGX2K3K_VAL_SLOPE_POSITIVE, 0, 0, "POS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable SlopeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    SlopeRangeTableEntries,
};

static IviRangeTableEntry ChannelRangeTableEntries[] =
{
    { AGX2K3K_VAL_CHANNEL_1,  0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_CHANNEL_2,  0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_CHANNEL_3,  0, 0, "CHAN3", 0 },
    { AGX2K3K_VAL_CHANNEL_4,  0, 0, "CHAN4", 0 },
    { AGX2K3K_VAL_DIGITAL_0,  0, 0, "DIG0",  0 },
    { AGX2K3K_VAL_DIGITAL_1,  0, 0, "DIG1",  0 },
    { AGX2K3K_VAL_DIGITAL_2,  0, 0, "DIG2",  0 },
    { AGX2K3K_VAL_DIGITAL_3,  0, 0, "DIG3",  0 },
    { AGX2K3K_VAL_DIGITAL_4,  0, 0, "DIG4",  0 },
    { AGX2K3K_VAL_DIGITAL_5,  0, 0, "DIG5",  0 },
    { AGX2K3K_VAL_DIGITAL_6,  0, 0, "DIG6",  0 },
    { AGX2K3K_VAL_DIGITAL_7,  0, 0, "DIG7",  0 },
    { AGX2K3K_VAL_DIGITAL_8,  0, 0, "DIG8",  0 },
    { AGX2K3K_VAL_DIGITAL_9,  0, 0, "DIG9",  0 },
    { AGX2K3K_VAL_DIGITAL_10, 0, 0, "DIG10", 0 },
    { AGX2K3K_VAL_DIGITAL_11, 0, 0, "DIG11", 0 },
    { AGX2K3K_VAL_DIGITAL_12, 0, 0, "DIG12", 0 },
    { AGX2K3K_VAL_DIGITAL_13, 0, 0, "DIG13", 0 },
    { AGX2K3K_VAL_DIGITAL_14, 0, 0, "DIG14", 0 },
    { AGX2K3K_VAL_DIGITAL_15, 0, 0, "DIG15", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable ChannelRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    ChannelRangeTableEntries,
};

static IviRangeTableEntry ByteorderRangeTableEntries[] =
{
    { AGX2K3K_VAL_MSB_FIRST, 0, 0, "MSBF", 0 },
    { AGX2K3K_VAL_LSB_FIRST, 0, 0, "LSBF", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable ByteorderRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    ByteorderRangeTableEntries,
};

static IviRangeTableEntry DigitalChannelRangeTableEntries[] =
{
    { AGX2K3K_VAL_DIGITAL_0,  0, 0, "DIG0",  0 },
    { AGX2K3K_VAL_DIGITAL_1,  0, 0, "DIG1",  0 },
    { AGX2K3K_VAL_DIGITAL_2,  0, 0, "DIG2",  0 },
    { AGX2K3K_VAL_DIGITAL_3,  0, 0, "DIG3",  0 },
    { AGX2K3K_VAL_DIGITAL_4,  0, 0, "DIG4",  0 },
    { AGX2K3K_VAL_DIGITAL_5,  0, 0, "DIG5",  0 },
    { AGX2K3K_VAL_DIGITAL_6,  0, 0, "DIG6",  0 },
    { AGX2K3K_VAL_DIGITAL_7,  0, 0, "DIG7",  0 },
    { AGX2K3K_VAL_DIGITAL_8,  0, 0, "DIG8",  0 },
    { AGX2K3K_VAL_DIGITAL_9,  0, 0, "DIG9",  0 },
    { AGX2K3K_VAL_DIGITAL_10, 0, 0, "DIG10", 0 },
    { AGX2K3K_VAL_DIGITAL_11, 0, 0, "DIG11", 0 },
    { AGX2K3K_VAL_DIGITAL_12, 0, 0, "DIG12", 0 },
    { AGX2K3K_VAL_DIGITAL_13, 0, 0, "DIG13", 0 },
    { AGX2K3K_VAL_DIGITAL_14, 0, 0, "DIG14", 0 },
    { AGX2K3K_VAL_DIGITAL_15, 0, 0, "DIG15", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable DigitalChannelRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    DigitalChannelRangeTableEntries,
};

static IviRangeTableEntry BusSlopeRangeTableEntries[] =
{
    { AGX2K3K_VAL_BUS_NEGATIVE, 0, 0, "NEG",  0 },
    { AGX2K3K_VAL_BUS_POSITIVE, 0, 0, "POS",  0 },
    { AGX2K3K_VAL_BUS_EITHER,   0, 0, "EITH", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable BusSlopeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    BusSlopeRangeTableEntries,
};

static IviRangeTableEntry FunctionBusYunitsRangeTableEntries[] =
{
    { AGX2K3K_VAL_BUS_VOLT,   0, 0, "VOLT", 0 },
    { AGX2K3K_VAL_BUS_AMPERE, 0, 0, "AMP",  0 },
    { AGX2K3K_VAL_BUS_NONE,   0, 0, "NONE", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable FunctionBusYunitsRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    FunctionBusYunitsRangeTableEntries,
};

static IviRangeTableEntry FunctionTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_VAVERAGE,   0, 0, "VAV",  0 },
    { AGX2K3K_VAL_ACRMS,      0, 0, "ACRM", 0 },
    { AGX2K3K_VAL_VRATIO,     0, 0, "VRAT", 0 },
    { AGX2K3K_VAL_PERIOD,     0, 0, "PER",  0 },
    { AGX2K3K_VAL_FREQUENCY,  0, 0, "FREQ", 0 },
    { AGX2K3K_VAL_PWIDTH,     0, 0, "PWID", 0 },
    { AGX2K3K_VAL_NWIDTH,     0, 0, "NWID", 0 },
    { AGX2K3K_VAL_DUTY_CYCLE, 0, 0, "DUTY", 0 },
    { AGX2K3K_VAL_RISETIME,   0, 0, "RIS",  0 },
    { AGX2K3K_VAL_FALL_TIME,  0, 0, "FALL", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable FunctionTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    FunctionTypeRangeTableEntries,
};

static IviRangeTableEntry PowerHarmonicsDisplayStyleRangeTableEntries[] =
{
    { AGX2K3K_VAL_TABLE, 0, 0, "TAB", 0 },
    { AGX2K3K_VAL_BAR,   0, 0, "BAR", 0 },
    { AGX2K3K_VAL_OFF,   0, 0, "OFF", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable PowerHarmonicsDisplayStyleRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    PowerHarmonicsDisplayStyleRangeTableEntries,
};

static IviRangeTableEntry PowerHarmonicsStandardRangeTableEntries[] =
{
    { AGX2K3K_VAL_STANDARD_A, 0, 0, "A", 0 },
    { AGX2K3K_VAL_STANDARD_B, 0, 0, "B", 0 },
    { AGX2K3K_VAL_STANDARD_C, 0, 0, "C", 0 },
    { AGX2K3K_VAL_STANDARD_D, 0, 0, "D", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable PowerHarmonicsStandardRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    PowerHarmonicsStandardRangeTableEntries,
};

static IviRangeTableEntry VISourceRangeTableEntries[] =
{
    { AGX2K3K_VAL_V, 0, 0, "V", 0 },
    { AGX2K3K_VAL_I, 0, 0, "I", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable VISourceRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    VISourceRangeTableEntries,
};

static IviRangeTableEntry PowerFrequencyMaxRangeTableEntries[] =
{
    { AGX2K3K_VAL_10_HZ,   0, 0, "10",       0 },
    { AGX2K3K_VAL_100_HZ,  0, 0, "100",      0 },
    { AGX2K3K_VAL_1_KHZ,   0, 0, "1000",     0 },
    { AGX2K3K_VAL_10_KHZ,  0, 0, "10000",    0 },
    { AGX2K3K_VAL_100_KHZ, 0, 0, "100000",   0 },
    { AGX2K3K_VAL_1_MHZ,   0, 0, "1000000",  0 },
    { AGX2K3K_VAL_10_MHZ,  0, 0, "10000000", 0 },
    { AGX2K3K_VAL_20_MHZ,  0, 0, "20000000", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable PowerFrequencyMaxRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    PowerFrequencyMaxRangeTableEntries,
};

static IviRangeTableEntry PowerFrequencyMinRangeTableEntries[] =
{
    { AGX2K3K_VAL_1_HZ,    0, 0, "1",        0 },
    { AGX2K3K_VAL_10_HZ,   0, 0, "10",       0 },
    { AGX2K3K_VAL_100_HZ,  0, 0, "100",      0 },
    { AGX2K3K_VAL_1_KHZ,   0, 0, "1000",     0 },
    { AGX2K3K_VAL_10_KHZ,  0, 0, "10000",    0 },
    { AGX2K3K_VAL_100_KHZ, 0, 0, "100000",   0 },
    { AGX2K3K_VAL_1_MHZ,   0, 0, "1000000",  0 },
    { AGX2K3K_VAL_10_MHZ,  0, 0, "10000000", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable PowerFrequencyMinRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    PowerFrequencyMinRangeTableEntries,
};

static IviRangeTableEntry PowerQualityTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_FACTOR,   0, 0, "FACT", 0 },
    { AGX2K3K_VAL_REAL,     0, 0, "REAL", 0 },
    { AGX2K3K_VAL_APPARENT, 0, 0, "APP",  0 },
    { AGX2K3K_VAL_REACTIVE, 0, 0, "REAC", 0 },
    { AGX2K3K_VAL_CREST,    0, 0, "CRES", 0 },
    { AGX2K3K_VAL_ANGLE,    0, 0, "ANGL", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable PowerQualityTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    PowerQualityTypeRangeTableEntries,
};

static IviRangeTableEntry PowerSignalsCyclesRangeTableEntries[] =
{
    { 1, 100, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable PowerSignalsCyclesRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    PowerSignalsCyclesRangeTableEntries,
};

static IviRangeTableEntry AnalogChannelRangeTableEntries[] =
{
    { AGX2K3K_VAL_CHANNEL_1, 0, 0, "CHAN1", 0 },
    { AGX2K3K_VAL_CHANNEL_2, 0, 0, "CHAN2", 0 },
    { AGX2K3K_VAL_CHANNEL_3, 0, 0, "CHAN3", 0 },
    { AGX2K3K_VAL_CHANNEL_4, 0, 0, "CHAN4", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable AnalogChannelRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    AnalogChannelRangeTableEntries,
};

static IviRangeTableEntry PowerSwitchConductionRangeTableEntries[] =
{
    { AGX2K3K_VAL_WAVEFORM, 0, 0, "WAV", 0 },
    { AGX2K3K_VAL_RDS,      0, 0, "RDS", 0 },
    { AGX2K3K_VAL_VCE,      0, 0, "VCE", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable PowerSwitchConductionRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    PowerSwitchConductionRangeTableEntries,
};

static IviRangeTableEntry SBusBaseRangeTableEntries[] =
{
    { AGX2K3K_VAL_BASE_BINARY, 0, 0, "BIN", 0 },
    { AGX2K3K_VAL_BASE_HEX,    0, 0, "HEX", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable SBusBaseRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    SBusBaseRangeTableEntries,
};

static IviRangeTableEntry A429FormatRangeTableEntries[] =
{
    { AGX2K3K_VAL_FORMAT_LDSDI, 0, 0, "LDSD", 0 },
    { AGX2K3K_VAL_FORMAT_LDSSM, 0, 0, "LDSS", 0 },
    { AGX2K3K_VAL_FORMAT_LDATA, 0, 0, "LDAT", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable A429FormatRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    A429FormatRangeTableEntries,
};

static IviRangeTableEntry A429SignalRangeTableEntries[] =
{
    { AGX2K3K_VAL_SIGNAL_A,            0, 0, "A",    0 },
    { AGX2K3K_VAL_SIGNAL_B,            0, 0, "B",    0 },
    { AGX2K3K_VAL_SIGNAL_DIFFERENTIAL, 0, 0, "DIFF", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable A429SignalRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    A429SignalRangeTableEntries,
};

static IviRangeTableEntry A429SpeedRangeTableEntries[] =
{
    { AGX2K3K_VAL_A429_LOW,  0, 0, "LOW",  0 },
    { AGX2K3K_VAL_A429_HIGH, 0, 0, "HIGH", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable A429SpeedRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    A429SpeedRangeTableEntries,
};

static IviRangeTableEntry A429TriggerLabelRangeTableEntries[] =
{
    { -1, 255, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable A429TriggerLabelRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    A429TriggerLabelRangeTableEntries,
};

static IviRangeTableEntry A429TriggerTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_WSTART,    0, 0, "WSTA", 0 },
    { AGX2K3K_VAL_WSTOP,     0, 0, "WSTO", 0 },
    { AGX2K3K_VAL_LABEL,     0, 0, "LAB",  0 },
    { AGX2K3K_VAL_LBITS,     0, 0, "LBIT", 0 },
    { AGX2K3K_VAL_LRANGE,    0, 0, "LRAN", 0 },
    { AGX2K3K_VAL_PERROR,    0, 0, "PERR", 0 },
    { AGX2K3K_VAL_WERROR,    0, 0, "WERR", 0 },
    { AGX2K3K_VAL_GERROR,    0, 0, "GERR", 0 },
    { AGX2K3K_VAL_WGERRORS,  0, 0, "WGER", 0 },
    { AGX2K3K_VAL_ALLERRORS, 0, 0, "ALL",  0 },
    { AGX2K3K_VAL_ABITS,     0, 0, "ABIT", 0 },
    { AGX2K3K_VAL_AZBITS,    0, 0, "AZB",  0 },
    { AGX2K3K_VAL_AOBITS,    0, 0, "AOB",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable A429TriggerTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    A429TriggerTypeRangeTableEntries,
};

static IviRangeTableEntry FlexrayBaudrateRangeTableEntries[] =
{
    { AGX2K3K_VAL_2_AND_HALF_MB, 0, 0, "2500000",  0 },
    { AGX2K3K_VAL_5_MB,          0, 0, "5000000",  0 },
    { AGX2K3K_VAL_10_MB,         0, 0, "10000000", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable FlexrayBaudrateRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    FlexrayBaudrateRangeTableEntries,
};

static IviRangeTableEntry FlexrayChannelRangeTableEntries[] =
{
    { AGX2K3K_VAL_CHANNEL_A, 0, 0, "A", 0 },
    { AGX2K3K_VAL_CHANNEL_B, 0, 0, "B", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable FlexrayChannelRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    FlexrayChannelRangeTableEntries,
};

static IviRangeTableEntry FlexrayTriggerRangeTableEntries[] =
{
    { AGX2K3K_VAL_FRAME, 0, 0, "FRAM", 0 },
    { AGX2K3K_VAL_ERROR, 0, 0, "ERR",  0 },
    { AGX2K3K_VAL_EVENT, 0, 0, "EVEN", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable FlexrayTriggerRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    FlexrayTriggerRangeTableEntries,
};

static IviRangeTableEntry FlexrayTriggerErrorTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_ALL,  0, 0, "ALL",  0 },
    { AGX2K3K_VAL_HCRC, 0, 0, "HCRC", 0 },
    { AGX2K3K_VAL_FCRC, 0, 0, "FCRC", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable FlexrayTriggerErrorTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    FlexrayTriggerErrorTypeRangeTableEntries,
};

static IviRangeTableEntry FlexrayTriggerEventTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_WAKEUP,  0, 0, "WAK", 0 },
    { AGX2K3K_VAL_TSS,     0, 0, "TSS", 0 },
    { AGX2K3K_VAL_FES_DTS, 0, 0, "FES", 0 },
    { AGX2K3K_VAL_BSS,     0, 0, "BSS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable FlexrayTriggerEventTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    FlexrayTriggerEventTypeRangeTableEntries,
};

static IviRangeTableEntry FlexrayTriggerCcrepetitionRangeTableEntries[] =
{
    { AGX2K3K_VAL_REP_ALL, 0, 0, "ALL", 0 },
    { AGX2K3K_VAL_REP_2,   0, 0, "2",   0 },
    { AGX2K3K_VAL_REP_4,   0, 0, "4",   0 },
    { AGX2K3K_VAL_REP_8,   0, 0, "8",   0 },
    { AGX2K3K_VAL_REP_16,  0, 0, "16",  0 },
    { AGX2K3K_VAL_REP_32,  0, 0, "32",  0 },
    { AGX2K3K_VAL_REP_64,  0, 0, "64",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable FlexrayTriggerCcrepetitionRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    FlexrayTriggerCcrepetitionRangeTableEntries,
};

static IviRangeTableEntry FlexrayTriggerFrameTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_NORMAL,    0, 0, "NORM",  0 },
    { AGX2K3K_VAL_STRARTUP,  0, 0, "STAR",  0 },
    { AGX2K3K_VAL_NULL,      0, 0, "NULL",  0 },
    { AGX2K3K_VAL_SYNC,      0, 0, "SYNC",  0 },
    { AGX2K3K_VAL_NSTARTUP,  0, 0, "NSTA",  0 },
    { AGX2K3K_VAL_NNULI,     0, 0, "NNULI", 0 },
    { AGX2K3K_VAL_NSYNC,     0, 0, "NSYNC", 0 },
    { AGX2K3K_VAL_ALL_FRAME, 0, 0, "ALL",   0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable FlexrayTriggerFrameTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    FlexrayTriggerFrameTypeRangeTableEntries,
};

static IviRangeTableEntry DemoFunctionRangeTableEntries[] =
{
    { AGX2K3K_VAL_FUNC_SINUSOID,   0, 0, "SIN",  0 },
    { AGX2K3K_VAL_FUNC_NOISY,      0, 0, "NOIS", 0 },
    { AGX2K3K_VAL_FUNC_PHASE,      0, 0, "PHAS", 0 },
    { AGX2K3K_VAL_FUNC_RINGING,    0, 0, "RING", 0 },
    { AGX2K3K_VAL_FUNC_SINGLE,     0, 0, "SING", 0 },
    { AGX2K3K_VAL_FUNC_AM,         0, 0, "AM",   0 },
    { AGX2K3K_VAL_FUNC_CLK,        0, 0, "CLK",  0 },
    { AGX2K3K_VAL_FUNC_GLITCH,     0, 0, "GLIT", 0 },
    { AGX2K3K_VAL_FUNC_BURST,      0, 0, "BURS", 0 },
    { AGX2K3K_VAL_FUNC_MSO,        0, 0, "MSO",  0 },
    { AGX2K3K_VAL_FUNC_RUNT,       0, 0, "RUNT", 0 },
    { AGX2K3K_VAL_FUNC_TRANSITION, 0, 0, "TRAN", 0 },
    { AGX2K3K_VAL_FUNC_RFBURST,    0, 0, "RFB",  0 },
    { AGX2K3K_VAL_FUNC_SHOLD,      0, 0, "SHOL", 0 },
    { AGX2K3K_VAL_FUNC_LFSINE,     0, 0, "LFS",  0 },
    { AGX2K3K_VAL_FUNC_FMBURST,    0, 0, "FMB",  0 },
    { AGX2K3K_VAL_FUNC_ETE,        0, 0, "ETE",  0 },
    { AGX2K3K_VAL_FUNC_CAN,        0, 0, "CAN",  0 },
    { AGX2K3K_VAL_FUNC_LIN,        0, 0, "LIN",  0 },
    { AGX2K3K_VAL_FUNC_UART,       0, 0, "UART", 0 },
    { AGX2K3K_VAL_FUNC_I2C,        0, 0, "I2C",  0 },
    { AGX2K3K_VAL_FUNC_SPI,        0, 0, "SPI",  0 },
    { AGX2K3K_VAL_FUNC_I2S,        0, 0, "I2S",  0 },
    { AGX2K3K_VAL_FUNC_CANLIN,     0, 0, "CAN",  0 },
    { AGX2K3K_VAL_FUNC_ARRINC,     0, 0, "ARIN", 0 },
    { AGX2K3K_VAL_FUNC_FLEXRAY,    0, 0, "FLEX", 0 },
    { AGX2K3K_VAL_FUNC_MIL,        0, 0, "MIL",  0 },
    { AGX2K3K_VAL_FUNC_MIL2,       0, 0, "MIL2", 0 },
    { AGX2K3K_VAL_FUNC_USB,        0, 0, "USB",  0 },
    { AGX2K3K_VAL_FUNC_NMONOTONIC, 0, 0, "NMON", 0 },
    { AGX2K3K_VAL_FUNC_DCMOTOR,    0, 0, "DCM",  0 },
    { AGX2K3K_VAL_FUNC_HARMONICS,  0, 0, "HARM", 0 },
    { AGX2K3K_VAL_FUNC_COUPLING,   0, 0, "COUP", 0 },
    { AGX2K3K_VAL_FUNC_CFD,        0, 0, "CFD",  0 },
    { AGX2K3K_VAL_FUNC_SENT,       0, 0, "SENT", 0 },
    { AGX2K3K_VAL_FUNC_KEYSIGHT,   0, 0, "KEYS", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable DemoFunctionRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    DemoFunctionRangeTableEntries,
};

static IviRangeTableEntry PowerSignalsAutosetupTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_HARMONICS,  0, 0, "HARM", 0 },
    { AGX2K3K_VAL_EFFICIENCY, 0, 0, "EFF",  0 },
    { AGX2K3K_VAL_RIPPLE,     0, 0, "RIPP", 0 },
    { AGX2K3K_VAL_MODULATION, 0, 0, "MOD",  0 },
    { AGX2K3K_VAL_QUALITY,    0, 0, "QUAL", 0 },
    { AGX2K3K_VAL_SLEW,       0, 0, "SLEW", 0 },
    { AGX2K3K_VAL_SWITCH,     0, 0, "SWIT", 0 },
    { AGX2K3K_VAL_RDSVCE,     0, 0, "RDSV", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable PowerSignalsAutosetupTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    PowerSignalsAutosetupTypeRangeTableEntries,
};

static IviRangeTableEntry FlexrayTriggerFrameCcBaseRangeTableEntries[] =
{
    {  0, 63, 0, "", 0 },
    { -1, -1, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable FlexrayTriggerFrameCcBaseRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    FlexrayTriggerFrameCcBaseRangeTableEntries,
};

static IviRangeTableEntry IDRangeTableEntries[] =
{
    {               1,            2047, 0, "", 0 },
    { AGX2K3K_VAL_ALL, AGX2K3K_VAL_ALL, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable IDRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    IDRangeTableEntries,
};

static IviRangeTableEntry M1553TriggerRtaRangeTableEntries[] =
{
    { -1, 31, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable M1553TriggerRtaRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    M1553TriggerRtaRangeTableEntries,
};

static IviRangeTableEntry M1553TriggerTypeRangeTableEntries[] =
{
    { AGX2K3K_VAL_DSTART, 0, 0, "DSTA",  0 },
    { AGX2K3K_VAL_DSTOP,  0, 0, "DSTO",  0 },
    { AGX2K3K_VAL_CSTART, 0, 0, "CSTA",  0 },
    { AGX2K3K_VAL_CSTOP,  0, 0, "CSTO",  0 },
    { AGX2K3K_VAL_RTA,    0, 0, "RTA",   0 },
    { AGX2K3K_VAL_PERROR, 0, 0, "PERR",  0 },
    { AGX2K3K_VAL_SERROR, 0, 0, "SERR",  0 },
    { AGX2K3K_VAL_MERROR, 0, 0, "MERR",  0 },
    { AGX2K3K_VAL_RTA11,  0, 0, "RTA11", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable M1553TriggerTypeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    M1553TriggerTypeRangeTableEntries,
};

static IviRangeTableEntry SbusModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_A429,    0, 0, "A429",  0 },
    { AGX2K3K_VAL_M1553,   0, 0, "M1553", 0 },
    { AGX2K3K_VAL_FLEXRAY, 0, 0, "FLEX",  0 },
    { AGX2K3K_VAL_CAN,     0, 0, "CAN",   0 },
    { AGX2K3K_VAL_I2S,     0, 0, "I2S",   0 },
    { AGX2K3K_VAL_IIC,     0, 0, "IIC",   0 },
    { AGX2K3K_VAL_LIN,     0, 0, "LIN",   0 },
    { AGX2K3K_VAL_SPI,     0, 0, "SPI",   0 },
    { AGX2K3K_VAL_URAT,    0, 0, "UART",  0 },
    { AGX2K3K_VAL_USB,     0, 0, "USB",   0 }, /* Not applicable for 3000T X-Series and 3000 X-Series. */
    { AGX2K3K_VAL_SENT,    0, 0, "SENT",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable SbusModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    SbusModeRangeTableEntries,
};

static IviRangeTableEntry SearchSerialA429ModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_A429_LABEL,     0, 0, "LAB",  0 },
    { AGX2K3K_VAL_A429_LBITS,     0, 0, "LBIT", 0 },
    { AGX2K3K_VAL_A429_PERROR,    0, 0, "PERR", 0 },
    { AGX2K3K_VAL_A429_WERROR,    0, 0, "WERR", 0 },
    { AGX2K3K_VAL_A429_GERROR,    0, 0, "GERR", 0 },
    { AGX2K3K_VAL_A429_WGERRORS,  0, 0, "WGER", 0 },
    { AGX2K3K_VAL_A429_ALLERRORS, 0, 0, "ALL",  0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable SearchSerialA429ModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    SearchSerialA429ModeRangeTableEntries,
};

static IviRangeTableEntry LabelRangeTableEntries[] =
{
    { 0, 255, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable LabelRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    LabelRangeTableEntries,
};

static IviRangeTableEntry SearchSerialFlexrayCycleRangeTableEntries[] =
{
    /*AGX2K3K_VAL_ALL*/
    { AGX2K3K_VAL_ALL, AGX2K3K_VAL_ALL, 0, "", 0 },
    {               0,              63, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable SearchSerialFlexrayCycleRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    SearchSerialFlexrayCycleRangeTableEntries,
};

static IviRangeTableEntry SearchSerialFlexrayDataLengthRangeTableEntries[] =
{
    { 1, 12, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable SearchSerialFlexrayDataLengthRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    SearchSerialFlexrayDataLengthRangeTableEntries,
};

static IviRangeTableEntry SearchSerialFlexrayFrameRangeTableEntries[] =
{
    { AGX2K3K_VAL_ALL, AGX2K3K_VAL_ALL, 0, "", 0 },
    {               1,            2047, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable SearchSerialFlexrayFrameRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    SearchSerialFlexrayFrameRangeTableEntries,
};

static IviRangeTableEntry SearchSerialFlexrayModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_FLEXRAY_FRAME,  0, 0, "FRAM", 0 },
    { AGX2K3K_VAL_FLEXRAY_CYCLE,  0, 0, "CYCL", 0 },
    { AGX2K3K_VAL_FLEXRAY_DATA,   0, 0, "DATA", 0 },
    { AGX2K3K_VAL_FLEXRAY_HERROR, 0, 0, "HERR", 0 },
    { AGX2K3K_VAL_FLEXRAY_FERROR, 0, 0, "FERR", 0 },
    { AGX2K3K_VAL_FLEXRAY_AERROR, 0, 0, "AERR", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable SearchSerialFlexrayModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    SearchSerialFlexrayModeRangeTableEntries,
};

static IviRangeTableEntry M1553ModeRangeTableEntries[] =
{
    { AGX2K3K_VAL_M1553_DSTART, 0, 0, "DSTA",  0 },
    { AGX2K3K_VAL_M1553_CSTART, 0, 0, "CSTA",  0 },
    { AGX2K3K_VAL_M1553_RTA,    0, 0, "RTA",   0 },
    { AGX2K3K_VAL_M1553_PERROR, 0, 0, "PERR",  0 },
    { AGX2K3K_VAL_M1553_SERROR, 0, 0, "SERR",  0 },
    { AGX2K3K_VAL_M1553_MERROR, 0, 0, "MERR",  0 },
    { AGX2K3K_VAL_M1553_RTA11,  0, 0, "RTA11", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable M1553ModeRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    M1553ModeRangeTableEntries,
};

static IviRangeTableEntry SearchSerialM1553RtaRangeTableEntries[] =
{
    { 0, 31, 0, "", 0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable SearchSerialM1553RtaRangeTable =
{
    IVI_VAL_RANGED,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    SearchSerialM1553RtaRangeTableEntries,
};

static IviRangeTableEntry TriggerPatternFormatRangeTableEntries[] =
{
    { AGX2K3K_VAL_PATTERN_ASCII, 0, 0, "ASCII", 0 },
    { AGX2K3K_VAL_PATTERN_HEX,   0, 0, "HEX",   0 },
    { IVI_RANGE_TABLE_LAST_ENTRY }
};

static IviRangeTable TriggerPatternFormatRangeTable =
{
    IVI_VAL_DISCRETE,
    VI_TRUE,
    VI_TRUE,
    VI_NULL,
    TriggerPatternFormatRangeTableEntries,
};

/*****************************************************************************
 *----------------- Callback Declarations (Non-Exported) --------------------*
 *****************************************************************************/

static ViStatus _VI_FUNC agx2k3kAttrSearchSerialFlexrayCycle_ReadCallback (ViSession vi,
                                                                           ViSession io,
                                                                           ViConstString channelName,
                                                                           ViAttr attributeId,
                                                                           ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kAttrSearchSerialFlexrayCycle_WriteCallback (ViSession vi,
                                                                            ViSession io,
                                                                            ViConstString channelName,
                                                                            ViAttr attributeId,
                                                                            ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrSearchSerialFlexrayFrame_ReadCallback (ViSession vi,
                                                                           ViSession io,
                                                                           ViConstString channelName,
                                                                           ViAttr attributeId,
                                                                           ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kAttrSearchSerialFlexrayFrame_WriteCallback (ViSession vi,
                                                                            ViSession io,
                                                                            ViConstString channelName,
                                                                            ViAttr attributeId,
                                                                            ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrMeasStatMcount_ReadCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kAttrMeasStatMcount_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrMeasStatMcount_CheckCallback (ViSession vi,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrFlexrayTriggerEventBassId_ReadCallback (ViSession vi,
                                                                            ViSession io,
                                                                            ViConstString channelName,
                                                                            ViAttr attributeId,
                                                                            ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kAttrFlexrayTriggerEventBassId_WriteCallback (ViSession vi,
                                                                             ViSession io,
                                                                             ViConstString channelName,
                                                                             ViAttr attributeId,
                                                                             ViInt32 value);
static ViStatus _VI_FUNC agx2k3kAttrFlexrayTriggerFrameId_ReadCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kAttrFlexrayTriggerFrameId_WriteCallback (ViSession vi,
                                                                         ViSession io,
                                                                         ViConstString channelName,
                                                                         ViAttr attributeId,
                                                                         ViInt32 value);
static ViStatus _VI_FUNC agx2k3kFirstCurrentSource_ReadCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kFirstVoltSource_ReadCallback (ViSession vi,
                                                              ViSession io,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kSecondCurrentSource_ReadCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kSecondVoltSource_ReadCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViInt32 *value);
static ViStatus _VI_FUNC agx2k3kFirstCurrentSource_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViInt32 value);
static ViStatus _VI_FUNC agx2k3kFirstVoltSource_WriteCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViInt32 value);
static ViStatus _VI_FUNC agx2k3kSecondCurrentSource_WriteCallback (ViSession vi,
                                                                   ViSession io,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViInt32 value);
static ViStatus _VI_FUNC agx2k3kSecondVoltSource_WriteCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViInt32 value);


/*******************************************************************************
 * Function:  agx2k3k_ConfigureDemoFunction
 * Purpose:   This function selects the type of demo signal.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureDemoFunction (ViSession vi, ViInt32 DemoFunction)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_DEMO_FUNCTION,
                                          0, DemoFunction), 2, "Demo Function");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFunBus
 * Purpose:   This function configues the setting for function bus.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFunBus (ViSession vi,
                                           ViInt32 busClock, ViInt32 busSlope,
                                           ViReal64 busIncrementY,
                                           ViReal64 busOriginY, ViInt32 busUnitY)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_FUNCTION_BUS_CLOCK,
                                          0, busClock), 2, "Bus Clock");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_FUNCTION_BUS_SLOPE,
                                          0, busSlope), 3, "Bus Slope");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FUNCTION_BUS_YINCREMENT,
                                           0, busIncrementY), 4, "Bus Increment Y");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FUNCTION_BUS_YORIGIN,
                                           0, busOriginY), 5, "Bus Origin Y");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_FUNCTION_BUS_YUNITS,
                                          0, busUnitY), 6, "Bus Unit Y");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFunBusMultiChan
 * Purpose:   This function configues the setting for function bus.
 *            Note: This function is available only in 4000 series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFunBusMultiChan (ViSession vi, ViChar functionChannel[],
                                                    ViInt32 busClock, ViInt32 busSlope,
                                                    ViReal64 busIncrementY,
                                                    ViReal64 busOriginY, ViInt32 busUnitY)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_BUS_CLOCK_MULTICHANNEL,
                                          0, busClock), 3, "Bus Clock");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_BUS_SLOPE_MULTICHANNEL,
                                          0, busSlope), 4, "Bus Slope");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_BUS_YINCREMENT_MULTICHANNEL,
                                           0, busIncrementY), 5, "Bus Increment Y");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_BUS_YORIGIN_MULTICHANNEL,
                                           0, busOriginY), 6, "Bus Origin Y");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_BUS_YUNITS_MULTICHANNEL,
                                          0, busUnitY), 7, "Bus Unit Y");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFunTrendMeas
 * Purpose:   This function configues the setting for function measurement.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFunTrendMeas (ViSession vi,
                                                 ViInt32 trendMeasurement)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_FUNCTION_TREND_MEASUREMENT,
                                          0, trendMeasurement), 2, "Trend Measurement");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFunTrendMeas
 * Purpose:   This function configues the setting for function measurement.
 *            Note: This function is available only in 4000 series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTrendMeasMultiChan (ViSession vi, ViChar functionChannel[],
                                                       ViInt32 trendMeasurement)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_TREND_MEASUREMENT_MULTICHANNEL,
                                          0, trendMeasurement), 3, "Trend Measurement");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFunLinear
 * Purpose:   This function configures the setting for function line.
 *
 *            Note: This function is available with the DSOX3ADVM
 *                  advanced math license.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFunLinear (ViSession vi,
                                              ViReal64 linearGain,
                                              ViReal64 linearOffset)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FUNCTION_LINEAR_GAIN,
                                           0, linearGain), 2, "Linear Gain");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FUNCTION_LINEAR_OFFSET,
                                           0, linearOffset), 3, "Linear Offset");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFunLinearMultiChan
 * Purpose:   This function configures the setting for function line.
 *
 *            Note: This function is available only in 4000 series with math
 *            license.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFunLinearMultiChan (ViSession vi, ViChar functionChannel[],
                                                       ViReal64 linearGain,
                                                       ViReal64 linearOffset)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_LINEAR_GAIN_MULTICHANNEL,
                                           0, linearGain), 3, "Linear Gain");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_LINEAR_OFFSET_MULTICHANNEL,
                                           0, linearOffset), 4, "Linear Offset");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFunFrequency
 * Purpose:   This function configures the setting for Frequency function.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFunFrequency (ViSession vi,
                                                 ViReal64 highPass,
                                                 ViReal64 lowPass)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FUNCTION_FREQ_HIGHPASS,
                                           0, highPass), 2, "High Pass");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FUNCTION_FREQ_LOWPASS,
                                           0, lowPass), 3, "Low Pass");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFunFreqMultiChan
 * Purpose:   This function configures the setting for Frequency function.
 *            Note: This function is available only in 4000 series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFunFreqMultiChan (ViSession vi, ViChar functionChannel[],
                                                     ViReal64 highPass,
                                                     ViReal64 lowPass)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_FREQ_HIGHPASS_MULTICHANNEL,
                                           0, highPass), 3, "High Pass");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_FREQ_LOWPASS_MULTICHANNEL,
                                           0, lowPass), 4, "Low Pass");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFunFFTUnit
 * Purpose:   This function specifies FFT vertical units.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFunFFTUnit (ViSession vi,
                                               ViInt32 unit)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_FUNCTION_VTYPE,
                                          0, unit), 2, "Unit");

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFFTUnitMultiChan
 * Purpose:   This function specifies FFT vertical units.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFFTUnitMultiChan (ViSession vi, ViChar functionChannel[],
                                                     ViInt32 unit)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_VTYPE_MULTICHANNEL,
                                          0, unit), 3, "Unit");

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureFunInputOffset
 * Purpose:   This function configures the setting for integrate input offset function.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureFunInputOffset (ViSession vi,
                                                   ViReal64 inputOffset)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_FUNCTION_INTEGRATE_IOFFSET,
                                           0, inputOffset), 2, "Input Offset");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureInputOffsMultiChan
 * Purpose:   This function configures the setting for integrate input offset function.
 *			  Note: This function is available only in 4000 series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureInputOffsMultiChan (ViSession vi, ViChar functionChannel[],
                                                       ViReal64 inputOffset)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViReal64 (vi, functionChannel, AGX2K3K_ATTR_FUNCTION_INTEGRATE_IOFFSET_MULTICHANNEL,
                                           0, inputOffset), 3, "Input Offset");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureMarkerXCursorUnit
 * Purpose:   This function configures the X cursor unit
 *
 *            Note: This function is available only in 2000 series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMarkerXCursorUnit (ViSession vi,
                                                      ViInt32 XCursorUnit,
                                                      ViBoolean ResetXCursorLocation)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_MARKER_XUNIT,
                                          0, XCursorUnit), 2, "X Cursor Unit");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureMarkerYCursorUnit
 * Purpose:   This function configures the Y cursor unit.
 *
 *            Note: This function is available only in 2000 series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMarkerYCursorUnit (ViSession vi,
                                                      ViInt32 YCursorUnit,
                                                      ViBoolean ResetYCursorLocation)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_MARKER_YUNIT,
                                          0, YCursorUnit), 2, "Y Cursor Unit");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureMeasurementDelay
 *  Purpose:  This function configures the measurement delay.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMeasurementDelay (ViSession vi,
                                                     ViInt32 edgeSpec1,
                                                     ViInt32 edgeSpec2)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    checkErr (Ivi_LockSession (vi, VI_NULL));

    sprintf (buffer, "DEL,%d,%d", edgeSpec1, edgeSpec2);

    checkErr (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_DELAY, 0, buffer));

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureMeasSource
 *  Purpose:  This function configures the reference source for
 *            waveform measurements.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMeasSource (ViSession vi,
                                               ViConstString source1,
                                               ViConstString source2)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (source1 == NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");
    if (source2 == NULL)
        viCheckParm (IVI_ERROR_INVALID_PARAMETER, 3, "Null address for Error");

    if ((strlen (source1) + 1) > BUFFER_SIZE)
        viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    if ((strlen (source2) + 1) > BUFFER_SIZE)
        viCheckErr (IVI_ERROR_OUT_OF_MEMORY);

    sprintf (buffer, "%s,%s", source1, source2);

    checkErr (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_SOURCE, 0, buffer));

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureMeasureStatistics
 * Purpose:   This function configures the setting for the measurement statistics.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureMeasureStatistics (ViSession vi,
                                                      ViBoolean DeviationEnabled,
                                                      ViInt32 MaxStatisticsNumber)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_MEAS_STAT_RESD_ENABLED,
                                            0, DeviationEnabled), 2, "Deviation Enabled");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_MEAS_STAT_MCOUNT,
                                          0, MaxStatisticsNumber), 3, "Max Statistics Number");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*****************************************************************************
 *  Function: agx2k3k_ConfigureRefLevels
 *  Purpose:  This function configures the reference levels for
 *            waveform measurements.
 *****************************************************************************/
DllExport ViStatus _VI_FUNC  agx2k3k_ConfigureRefLevels (ViSession vi,
                                               ViReal64 low,
                                               ViReal64 mid,
                                               ViReal64 high)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_MEAS_LOW_REF,
                                           0, low), 2, "Low");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_MEAS_MID_REF,
                                           0, mid), 3, "Mid");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL,
                                           AGX2K3K_ATTR_MEAS_HIGH_REF,
                                           0, high), 4, "High");

    sprintf (buffer, "THR,PERC,%Le,%Le,%Le", high, mid, low);

    checkErr (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_MEASURE_REF, 0, buffer));

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ApplyPowerEfficiency
 * Purpose:   This function applies the efficiency power analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyPowerEfficiency (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:EFF:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ApplyPowerHarmonics
 * Purpose:   This function applies the current harmonics analysis
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyPowerHarmonics (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:HARM:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ApplyPowerInrush
 * Purpose:   This function applies the inrush current analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyPowerInrush (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:INR:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}
/*******************************************************************************
 * Function:  agx2k3k_ApplyPowerModulation
 * Purpose:   This function applies the selected modulation analysis type.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyPowerModulation (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:MOD:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}
/*******************************************************************************
 * Function:  agx2k3k_ApplyPowerOnOff
 * Purpose:   This function applies the selected turn on/off analysis test.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyPowerOnOff (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:ONOF:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ApplyPowerPSRR
 * Purpose:   This function applies the power supply rejection ratio (PSRR) analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyPowerPSRR (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:PSRR:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ApplyPowerSwitch
 * Purpose:   This function applies the switching loss analysis using the conduction calculation method, V reference, and I reference settings.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyPowerSwitch (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:SWIT:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ApplyPowerQuality
 * Purpose:   This function applies the selected power quality analysis type.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyPowerQuality (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:QUAL:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ApplyPowerRIPPIE
 * Purpose:   This function applies the output ripple analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyPowerRipple (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:RIPP:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ApplyPowerSLEW
 * Purpose:   This function applies the slew rate analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyPowerSLEW (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:SLEW:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ApplyPowerControlResponse
 * Purpose:   Performs the control loop response (Bode) analysis to help determine the margin of a control loop.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyPowerControlResponse (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

        viCheckErr (viPrintf (io, ":POW:CLR:APPL;"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ApplyPowerTransient
 * Purpose:   This function applies the transient analysis using the initial current and new current settings.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ApplyPowerTransient (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:TRAN:APPL"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_AutoSetupPowerSignal
 * Purpose:   This function performs automated oscilloscope setup for the signals in the specified type of power analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_AutoSetupPowerSignal (ViSession vi, ViInt32 PowerAnalysisType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SIGNALS_AUTOSETUP_TYPE,
                                          0, PowerAnalysisType), 2, "Power Analysis Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureSignalSource
 * Purpose:   This function configures the setting for signal voltage
 *            and current source.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSignalSource (ViSession vi,
                                                 ViInt32 CurrentFirstSource,
                                                 ViInt32 CurrentSecondSource,
                                                 ViInt32 VoltageFirstSource,
                                                 ViInt32 VoltageSecondSource)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    /* The Voltage should be set before Current, found this by test other than from
     * Programming Manual*/
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SIGNALS_VOLT_FIRST_SOURCE,
                                          0, VoltageFirstSource), 4, "Voltage First Source");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SIGNALS_VOLT_SECOND_SOURCE,
                                          0, VoltageSecondSource), 5, "Voltage Second Source");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SIGNALS_CURRENT_FIRST_SOURCE,
                                          0, CurrentFirstSource), 2, "Current First Source");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SIGNALS_CURRENT_SECOND_SOURCE,
                                          0, CurrentSecondSource), 3, "Current Second Source");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerSLEWSource
 * Purpose:   This function configures the slew rate analysis source.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerSLEWSource (ViSession vi, ViInt32 Source)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SLEW_SOURCE,
                                          0, Source), 2, "Source");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerQuality
 * Purpose:   This function configures the selected power quality analysis type.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerQuality (ViSession vi, ViInt32 QualityType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_QUALITY_TYPE,
                                          0, QualityType), 2, "Quality Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}





/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerTransient
 * Purpose:   This function goes to the next step of the transient analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerTransient (ViSession vi,
                                                   ViReal64 InitCurrent,
                                                   ViReal64 NewCurrent)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_TRANSIENT_IINITIAL,
                                           0, InitCurrent), 2, "Init Current");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_TRANSIENT_INEW,
                                           0, NewCurrent), 3, "New Current");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerPSRR
 * Purpose:   This function configures the setting for power supply rejection ratio (PSRR) analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerPSRR (ViSession vi,
                                              ViInt32 FreqMax,
                                              ViInt32 FreqMin,
                                              ViInt32 MaxRatioValue)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_PSRR_FREQUENCY_MAX,
                                          0, FreqMax), 2, "Freq Max");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_PSRR_FREQUENCY_MIN,
                                          0, FreqMin), 3, "Freq Min");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_PSRR_RMAX,
                                          0, MaxRatioValue), 4, "Max Ratio Value");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerSignal
 * Purpose:   This function configures the setting for power signal.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerSignal (ViSession vi,
                                                ViInt32 SignalCycles,
                                                ViReal64 SignalDuration,
                                                ViReal64 SignalInrushExpected,
                                                ViInt32 SignalOvershoot,
                                                ViReal64 MaxExpectedVoltage,
                                                ViReal64 SteadyStateVoltage)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SIGNALS_CYCLES,
                                          0, SignalCycles), 2, "Signal Cycles");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SIGNALS_DURATION,
                                           0, SignalDuration), 3, "Signal Duration");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SIGNALS_IEXPECTED,
                                           0, SignalInrushExpected), 4, "Signal Inrush Expected");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SIGNALS_OVERSHOOT,
                                          0, SignalOvershoot), 5, "Signal Overshoot");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SIGNALS_VMAXIMUM,
                                           0, MaxExpectedVoltage), 6, "Max Expected Voltage");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SIGNALS_VSTEADY,
                                           0, SteadyStateVoltage), 7, "Steady State Voltage");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerModulation
 * Purpose:   This function configures the selected modulation analysis type.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerModulation (ViSession vi,
                                                    ViInt32 ModulationSource,
                                                    ViInt32 ModulationType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_MODULATION_SOURCE,
                                          0, ModulationSource), 2, "Modulation Source");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_MODULATION_TYPE,
                                          0, ModulationType), 3, "Modulation Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerSwitch
 * Purpose:   This function configures the setting for power switch.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerSwitch (ViSession vi,
                                                ViInt32 SwitchConduction,
                                                ViInt32 CurrentSwitchPercent,
                                                ViInt32 VoltageSwitchPercent,
                                                ViReal64 SwitchRDS,
                                                ViReal64 SwitchVCE)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SWITCH_CONDUCTION,
                                          0, SwitchConduction), 2, "Switch Conduction");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SWITCH_IREFERENCE,
                                          0, CurrentSwitchPercent), 3, "Current Switch Percent");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SWITCH_VREFERENCE,
                                          0, VoltageSwitchPercent), 4, "Voltage Switch Percent");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SWITCH_RDS,
                                           0, SwitchRDS), 5, "Switch RDS");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_POWER_SWITCH_VCE,
                                           0, SwitchVCE), 6, "Switch VCE");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigurePowerHarmonics
 * Purpose:   This function configures the setting for power harmonics.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigurePowerHarmonics (ViSession vi,
                                                   ViInt32 DisplayStyle,
                                                   ViInt32 FreqSettingLine,
                                                   ViInt32 Standard)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_HARMONICS_DISPLAY_STYLE,
                                          0, DisplayStyle), 2, "Display Style");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_HARMONICS_LINE,
                                          0, FreqSettingLine), 3, "Freq Setting Line");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_POWER_HARMONICS_STANDARD,
                                          0, Standard), 4, "Standard");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_EnablePowerAnalysis
 * Purpose:   This function enables or disables power analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_EnablePowerAnalysis (ViSession vi, ViBoolean PowerAnalysisEnabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_POWER_ENABLED,
                                            0, PowerAnalysisEnabled), 2, "Power Analysis Enabled");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_LaunchAutoDeskew
 * Purpose:   This function launches the auto deskew process on the oscilloscope.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_LaunchAutoDeskew (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POWer:DESKew"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_NextPowerInrush
 * Purpose:   This function makes the inrush current analysis to the next step.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_NextPowerInrush (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:INR:NEXT"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_NextPowerTransient
 * Purpose:   This function goes to the next step of the transient analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_NextPowerTransient (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:TRAN:NEXT"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_NextPowerOnOff
 * Purpose:   This function makes the selected turn on/off analysis test to the next step.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_NextPowerOnOff (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:ONOF:NEXT"));
    }


    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_StopPowerOnOff
 * Purpose:   This function stops the selected turn on/off analysis test.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_StopPowerOnOff (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:ONOF:EXIT"));
    }


    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_StopPowerInrush
 * Purpose:   This funtion stops th inrush current power analysis.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_StopPowerInrush (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:INR:EXIT"));
    }


    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_StopPowerTransient
 * Purpose:   This function stops the transient analysis using the initial current and new current settings.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_StopPowerTransient (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));
    checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        viCheckErr (viPrintf (io, ":POW:TRAN:EXIT"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_SaveArbitraryWave
 * Purpose:   This function saves the current arbitrary waveform to a file.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_SaveArbitraryWave (ViSession vi,
                                             ViConstString fileName)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));
        viCheckErr (viPrintf (io, ":SAVE:ARB:STAR \"%s\"", fileName));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_SavePowerAnalysis
 * Purpose:   This function saves the power measurement application's current
 *            harmonics analysis result to a file.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_SavePowerAnalysis (ViSession vi,
                                             ViConstString fileName)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));
        viCheckErr (viPrintf (io, ":SAVE:POW \"%s\"", fileName));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_EnableSaveMaxWave
 * Purpose:   This function specifies whether maximum number of
 *            waveform data points is saved.
 *
 *            Note: This function is available only in 2000 series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_EnableSaveMaxWave (ViSession vi, ViBoolean SaveMaxWaveEnabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_SAVE_MAX_WAVE_ENABLED,
                                            0, SaveMaxWaveEnabled), 2, "Save Max Wave Enabled");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_SaveAnalysisResults
 * Purpose:   Configures save analysis results characteristics.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_SaveAnalysisResults (ViSession vi, ViConstString OutputFile, ViBoolean CursorEnabled,
                                               ViBoolean MaskEnabled, ViBoolean MeasurementEnabled, ViBoolean SearchEnabled,
                                               ViBoolean SegmentedEnabled)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (OutputFile == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (OutputFile) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_CURSOR_ENABLED,
                                            0, CursorEnabled), 3, "Cursor Enabled");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_MASK_ENABLED,
                                            0, MaskEnabled), 4, "Mask Enabled");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_MEASUREMENT_ENABLED,
                                            0, MeasurementEnabled), 5, "Measurement Enabled");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_SEARCH_ENABLED,
                                            0, SearchEnabled), 6, "Search Enabled");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_SEGMENTED_ENABLED,
                                            0, SegmentedEnabled), 7, "Segmented Enabled");

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);
        if (strcmp (OutputFile, "") != 0)
        {
            viCheckErr (viPrintf (io, ":SAVE:RES:STAR \"%s\";", OutputFile));
        }
        else
        {
            viCheckErr (viPrintf (io, ":SAVE:RES:STAR;"));
        }
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_SaveUSBSignalQualityTestResults
 * Purpose:   Saves USB 2.0 signal quality test results to a file.
 *
 *            Note:
 *            It is applicable for 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_SaveUSBSignalQualityTestResults (ViSession vi, ViConstString OutputFile)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (OutputFile == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (OutputFile) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        if (strcmp (OutputFile, "") != 0)
        {
            viCheckErr (viPrintf (io, ":SAVE:COMP:USB:STAR \"%s\";", OutputFile));
        }
        else
        {
            viCheckErr (viPrintf (io, ":SAVE:COMP:USB:STAR;"));
        }
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_SaveMultiChanWaveformData
 * Purpose:   Saves multi-channel waveform data to a file.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_SaveMultiChanWaveformData (ViSession vi, ViConstString OutputFile)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (OutputFile == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (OutputFile) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        if (strcmp (OutputFile, "") != 0)
        {
            viCheckErr (viPrintf (io, ":SAVE:MULT:STAR \"%s\";", OutputFile));
        }
        else
        {
            viCheckErr (viPrintf (io, ":SAVE:MULT:STAR;"));
        }
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}




/*******************************************************************************
 * Function:  agx2k3k_ConfigureSearchSerialA429
 * Purpose:   This function configures the setting for A429 search serial.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSearchSerialA429 (ViSession vi,
                                                     ViInt32 Label,
                                                     ViInt32 Mode,
                                                     ViConstString PatternData,
                                                     ViConstString PatternSDI,
                                                     ViConstString PatternSSM)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_A429_LABEL,
                                          0, Label), 2, "Label");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_A429_MODE,
                                          0, Mode), 3, "Mode");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_A429_PATTERN_DATA,
                                           0, PatternData), 4, "Pattern Data");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_A429_PATTERN_SDI,
                                           0, PatternSDI), 5, "Pattern SDI");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_A429_PATTERN_SSM,
                                           0, PatternSSM), 6, "Pattern SSM");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureSearchSerialFlexray
 * Purpose:   This function configures the setting for flexray search serial.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSearchSerialFlexray (ViSession vi,
                                                        ViInt32 Cycle,
                                                        ViInt32 Mode,
                                                        ViConstString Data,
                                                        ViInt32 FrameID,
                                                        ViInt32 DataLength)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_CYCLE,
                                          0, Cycle), 2, "Cycle");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_MODE,
                                          0, Mode), 3, "Mode");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_DATA,
                                           0, Data), 4, "Data");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_FRAME,
                                          0, FrameID), 5, "Frame ID");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_DATA_LENGTH,
                                          0, DataLength), 6, "Data Length");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureSearchSerialM1553
 * Purpose:   This function configures the setting for M1553 search serial.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSearchSerialM1553 (ViSession vi,
                                                      ViInt32 Mode,
                                                      ViConstString PatternData,
                                                      ViInt32 RemoteTerminalAddress)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_M1553_MODE,
                                          0, Mode), 2, "Mode");
    viCheckParm (Ivi_SetAttributeViString (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_M1553_PATTERN_DATA,
                                           0, PatternData), 3, "Pattern Data");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_SEARCH_SERIAL_M1553_RTA,
                                          0, RemoteTerminalAddress), 4, "Remote Terminal Address");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_AutoSetupA429
 * Purpose:   This function automatically configures oscilloscope settings to facilitate A429 triggering and serial decode.
 *******************************************************************************/

DllExport ViStatus _VI_FUNC agx2k3k_AutoSetupA429 (ViSession vi,
                                         ViConstString busName)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));
        viCheckErr (viPrintf (io, ":%s:A429:AUT", busName));
    }

    checkErr (agx2k3k_CheckStatus (vi));
Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_AutoSetupFlexray
 * Purpose:   This function automatically configures oscilloscope settings to
 *            facilitate FlexRay triggering and serial decode.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_AutoSetupFlexray (ViSession vi,
                                            ViConstString busName)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));
        viCheckErr (viPrintf (io, ":%s:FLEX:AUT", busName));
    }

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_AutoSetupM1553
 * Purpose:   This function automatically sets these options for decoding and
 *            triggering on MIL-STD-1553 signals.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_AutoSetupM1553 (ViSession vi,
                                          ViConstString busName)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));
        viCheckErr (viPrintf (io, ":%s:M1553:AUT", busName));
    }

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ResetSBusA429
 * Purpose:   This function resets the word and error counters for A429
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ResetSBusA429 (ViSession vi,
                                         ViConstString busName)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));
        viCheckErr (viPrintf (io, ":%s:A429:COUN:RES", busName));
    }

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ResetSBusFlexray
 * Purpose:   This function resets the FlexRay frame counters.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ResetSBusFlexray (ViSession vi,
                                            ViConstString busName)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));
        viCheckErr (viPrintf (io, ":%s:FLEX:COUN:RES", busName));
    }

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureSBusA429
 * Purpose:   This function configures the setting for ARINC 429 signals.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSBusA429 (ViSession vi,
                                             ViConstString BusName,
                                             ViInt32 Base,
                                             ViInt32 Format,
                                             ViInt32 Signal,
                                             ViInt32 Source,
                                             ViInt32 SignalSpeed)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_A429_BASE,
                                          0, Base), 3, "Base");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_A429_FORMAT,
                                          0, Format), 4, "Format");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_A429_SIGNAL,
                                          0, Signal), 5, "Signal");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_A429_SOURCE,
                                          0, Source), 6, "Source");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_A429_SPEED,
                                          0, SignalSpeed), 7, "Signal Speed");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}
/*******************************************************************************
 * Function:  agx2k3k_ConfigureSBusA429Trigger
 * Purpose:   This function configures the setting for ARINC 429 signals trigger.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSBusA429Trigger (ViSession vi,
                                                    ViChar BusName[],
                                                    ViInt32 TriggerLabel,
                                                    ViChar TriggerPatternData[],
                                                    ViChar TriggerPatternSDI[],
                                                    ViChar TriggerPatternSSM[],
                                                    ViInt32 TriggerType,
                                                    ViInt32 TriggerRangeMin,
                                                    ViInt32 TriggerRangeMax)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViReal64 (vi, BusName, AGX2K3K_ATTR_A429_TRIGGER_LABEL,
                                           0, TriggerLabel), 3, "Trigger Label");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_A429_TRIGGER_PATTERN_DATA,
                                           0, TriggerPatternData), 4, "Trigger Pattern Data");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_A429_TRIGGER_PATTERN_SDI,
                                           0, TriggerPatternSDI), 5, "Trigger Pattern SDI");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_A429_TRIGGER_PATTERN_SSM,
                                           0, TriggerPatternSSM), 6, "Trigger Pattern SSM");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_A429_TRIGGER_TYPE,
                                          0, TriggerType), 7, "Trigger Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureSBusFlexray
 * Purpose:   This function configures the setting for Flexray signals.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSBusFlexray (ViSession vi,
                                                ViConstString BusName,
                                                ViInt32 Baudrate,
                                                ViInt32 Channel,
                                                ViInt32 Source)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_FLEXRAY_BAUDRATE,
                                          0, Baudrate), 3, "Baudrate");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_FLEXRAY_CHANNEL,
                                          0, Channel), 4, "Channel");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_FLEXRAY_SOURCE,
                                          0, Source), 5, "Source");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}
/*******************************************************************************
 * Function:  agx2k3k_ConfigureSBusFlexrayTrigger
 * Purpose:   This function configures the setting for Flexray signals trigger.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSBusFlexrayTrigger (ViSession vi,
                                                       ViChar BusName[],
                                                       ViInt32 Trigger,
                                                       ViInt32 TriggerEventBssID,
                                                       ViInt32 TriggerEventType,
                                                       ViInt32 TriggerFrameCCBase,
                                                       ViInt32 TriggerFrameCCRepetition,
                                                       ViInt32 TriggerFrameID,
                                                       ViInt32 TriggerFrameType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_FLEXRAY_TRIGGER,
                                          0, Trigger), 3, "Trigger");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_FLEXRAY_TRIGGER_EVENT_BASS_ID,
                                          0, TriggerEventBssID), 4, "Trigger Event Bss ID");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_FLEXRAY_TRIGGER_EVENT_TYPE,
                                          0, TriggerEventType), 5, "Trigger Event Type");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_CC_BASE,
                                          0, TriggerFrameCCBase), 6, "Trigger Frame CCBase");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_CCREPETITION,
                                          0, TriggerFrameCCRepetition), 7, "Trigger Frame CCRepetition");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_ID,
                                          0, TriggerFrameID), 8, "Trigger Frame ID");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_TYPE,
                                          0, TriggerFrameType), 9, "Trigger Frame Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureSBusM1553
 * Purpose:   This function configures the setting for M1553 signals.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureSBusM1553 (ViSession vi,
                                              ViConstString BusName,
                                              ViInt32 Base,
                                              ViInt32 Source,
                                              ViInt32 TriggerRTA,
                                              ViConstString TriggerPatternData,
                                              ViInt32 TriggerType)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_M1553_BASE,
                                          0, Base), 3, "Base");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_M1553_SOURCE,
                                          0, Source), 4, "Source");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_M1553_TRIGGER_RTA,
                                          0, TriggerRTA), 5, "Trigger RTA");
    viCheckParm (Ivi_SetAttributeViString (vi, BusName, AGX2K3K_ATTR_M1553_TRIGGER_PATTERN_DATA,
                                           0, TriggerPatternData), 6, "Trigger Pattern Data");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, BusName, AGX2K3K_ATTR_M1553_TRIGGER_TYPE,
                                          0, TriggerType), 7, "Trigger Type");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_RecallDataFromFile
 * Purpose:   This function recalls a waveform from file.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_RecallDataFromFile (ViSession vi,
                                              ViConstString FileName,
                                              ViInt32 StartColumn)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));
        viCheckErr (viPrintf (io, ":REC:ARB:STAR \"%s\", %s", FileName, StartColumn));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_RecallSerialBusDataFromFile
 * Purpose:   Configures the recall file operations.
 *
 *            Note:
 *            It is applicable for 3000T X-Series and 4000 X-Series only.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_RecallSerialBusDataFromFile (ViSession vi, ViInt32 FileType, ViConstString FileName,
                                                       ViInt32 SerialBus)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (Ivi_RangeChecking (vi))
    {
        if (FileName == NULL)
            viCheckParm (IVI_ERROR_INVALID_PARAMETER, 2, "Null address for Error");

        if ((strlen (FileName) + 1) > BUFFER_SIZE)
            viCheckErr (IVI_ERROR_OUT_OF_MEMORY);
    }



    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        if (FileType == AGX2K3K_VAL_RECALL_FILE_DBC)
        {
            if (strcmp (FileName, "") != 0 && SerialBus != AGX2K3K_VAL_SBUS_NONE)
            {
                viCheckErr (viPrintf (io, ":REC:DBC:STAR \"%s\", SBUS%d;", FileName, SerialBus));
            }
            else if (strcmp (FileName, "") == 0 && SerialBus == AGX2K3K_VAL_SBUS_NONE)
            {
                viCheckErr (viPrintf (io, ":REC:DBC:STAR;"));
            }
            else if (strcmp (FileName, "") == 0)
            {
                viCheckErr (viPrintf (io, ":REC:DBC:STAR SBUS%d;", SerialBus));
            }
            else /* SerialBus == AGX2K3K_VAL_SBUS_NONE */
            {
                viCheckErr (viPrintf (io, ":REC:DBC:STAR \"%s\";", FileName));
            }
        }
        else if (FileType == AGX2K3K_VAL_RECALL_FILE_LDF)
        {
            if (strcmp (FileName, "") != 0 && SerialBus != AGX2K3K_VAL_SBUS_NONE)
            {
                viCheckErr (viPrintf (io, ":REC:LDF:STAR \"%s\", SBUS%d;", FileName, SerialBus));
            }
            else if (strcmp (FileName, "") == 0 && SerialBus == AGX2K3K_VAL_SBUS_NONE)
            {
                viCheckErr (viPrintf (io, ":REC:LDF:STAR;"));
            }
            else if (strcmp (FileName, "") == 0)
            {
                viCheckErr (viPrintf (io, ":REC:LDF:STAR SBUS%d;", SerialBus));
            }
            else /* SerialBus == AGX2K3K_VAL_SBUS_NONE */
            {
                viCheckErr (viPrintf (io, ":REC:LDF:STAR \"%s\";", FileName));
            }
        }
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ForceTrigger
 * Purpose:   This function causes an acquisition to be captured even though the
 *            trigger condition has not been met. This command is equivalent to
 *            the front panel [Force Trigger] key.
 *
 *            Note: This function is available only in 2000 series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ForceTrigger (ViSession vi)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    if (!Ivi_Simulating (vi))
    {
        ViSession io = Ivi_IOSession (vi);

        checkErr (Ivi_SetNeedToCheckStatus (vi, VI_TRUE));
        viCheckErr (viPrintf (io, "TRIG:FORC"));
    }

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureTriggerDelay
 * Purpose:   This function configures the seting for trigger delay.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTriggerDelay (ViSession vi,
                                                 ViInt32 ArmSlope, ViInt32 ArmSource,
                                                 ViReal64 DelayTime, ViInt32 TriggerCount,
                                                 ViInt32 TriggerSlope, ViInt32 TriggerSource)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_DELAY_ARM_SLOPE,
                                          0, ArmSlope), 2, "Arm Slope");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_DELAY_ARM_SOURCE,
                                          0, ArmSource), 3, "Arm Source");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_DELAY_TDELAY_TIME,
                                           0, DelayTime), 4, "Delay Time");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_DELAY_TRIGGER_COUNT,
                                          0, TriggerCount), 5, "Trigger Count");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_DELAY_TRIGGER_SLOPE,
                                          0, TriggerSlope), 6, "Trigger Slope");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_DELAY_TRIGGER_SOURCE,
                                          0, TriggerSource), 7, "Trigger Source");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureTriggerTV
 * Purpose:   This function configures the seting for trigger TV.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTriggerTV (ViSession vi,
                                              ViInt32 UDTVEnumber,
                                              ViBoolean UDTVHsyncEnabled,
                                              ViReal64 UDTVHtime,
                                              ViReal64 UDTVPGHtime)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));

    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_TV_UDTV_ENUMBER,
                                          0, UDTVEnumber), 2, "U DTVEnumber");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_TV_UDTV_HSYNC_ENABLED,
                                            0, UDTVHsyncEnabled), 3, "U DTVHsync Enabled");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_TV_UDTV_HTIME,
                                           0, UDTVHtime), 4, "U DTVHtime");
    viCheckParm (Ivi_SetAttributeViReal64 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_TV_UDTV_PGTHAN,
                                           0, UDTVPGHtime), 5, "U DTVPGHtime");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}


/*******************************************************************************
 * Function:  agx2k3k_ConfigureTriggerPattern
 * Purpose:   This function configures the seting for trigger pattern.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureTriggerPattern (ViSession vi,
                                                   ViInt32 Format, ViInt32 Qualifier,
                                                   ViReal64 GreaterThan, ViReal64 LessThan)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_TRIGGER_PATTERN_FORMAT,
                                          0, Format), 2, "Format");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureModulationNoise
 * Purpose:   This functions adds noise to the currently selected signal.
 *
 *            Note: This function is available only in 2000 series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureModulationNoise (ViSession vi,
                                                    ViInt32 ByteOrder,
                                                    ViBoolean InterpolateEnabled,
                                                    ViInt32 NoisePercent)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_WGEN_ARBITRARY_BYTEORDER,
                                          0, ByteOrder), 2, "Byte Order");
    viCheckParm (Ivi_SetAttributeViBoolean (vi, VI_NULL, AGX2K3K_ATTR_WGEN_ARBITRARY_INTERPOLATE,
                                            0, InterpolateEnabled), 3, "Interpolate Enabled");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, VI_NULL, AGX2K3K_ATTR_WGEN_MODULATION_NOISE,
                                          0, NoisePercent), 4, "Noise Percent");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/*******************************************************************************
 * Function:  agx2k3k_ConfigureModNoiseMultiChan
 * Purpose:   This functions adds noise to the currently selected signal.
 *
 *            Note: This function is available only in 4000 series.
 *******************************************************************************/
DllExport ViStatus _VI_FUNC agx2k3k_ConfigureModNoiseMultiChan (ViSession vi,
                                                      ViChar waveGenChannel[],
                                                      ViInt32 ByteOrder,
                                                      ViInt32 NoisePercent)
{
    ViStatus error = VI_SUCCESS;

    checkErr (Ivi_LockSession (vi, VI_NULL));


    viCheckParm (Ivi_SetAttributeViInt32 (vi, waveGenChannel, AGX2K3K_ATTR_WGEN_ARBITRARY_BYTEORDER_MULTICHANNEL,
                                          0, ByteOrder), 3, "Byte Order");
    viCheckParm (Ivi_SetAttributeViInt32 (vi, waveGenChannel, AGX2K3K_ATTR_WGEN_MODULATION_NOISE_MULTICHANNEL,
                                          0, NoisePercent), 4, "Noise Percent");

    checkErr (agx2k3k_CheckStatus (vi));

Error:
    Ivi_UnlockSession (vi, VI_NULL);
    return error;
}

/* Callback functions */

/* AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_CYCLE */
static ViStatus _VI_FUNC agx2k3kAttrSearchSerialFlexrayCycle_ReadCallback (ViSession vi,
                                                                           ViSession io,
                                                                           ViConstString channelName,
                                                                           ViAttr attributeId,
                                                                           ViInt32 *value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    viCheckErr (viQueryf (io, ":SEAR:SER:FLEX:CYCL?", "%s", buffer));
    if (!strcmp (buffer, "ALL"))
    {
        *value = AGX2K3K_VAL_ALL;
    }
    else
    {
        *value = atoi (buffer);
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrSearchSerialFlexrayCycle_WriteCallback (ViSession vi,
                                                                            ViSession io,
                                                                            ViConstString channelName,
                                                                            ViAttr attributeId,
                                                                            ViInt32 value)
{
    ViStatus error = VI_SUCCESS;

    if (value == AGX2K3K_VAL_ALL)
    {
        viCheckErr (viPrintf (io, ":SEAR:SER:FLEX:CYCL ALL"));
    }
    else
    {
        viCheckErr (viPrintf (io, ":SEAR:SER:FLEX:CYCL %d", value));
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_FRAME */
static ViStatus _VI_FUNC agx2k3kAttrSearchSerialFlexrayFrame_ReadCallback (ViSession vi,
                                                                           ViSession io,
                                                                           ViConstString channelName,
                                                                           ViAttr attributeId,
                                                                           ViInt32 *value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    viCheckErr (viQueryf (io, ":SEAR:SER:FLEX:FRAM?", "%s", buffer));
    if (!strcmp (buffer, "ALL"))
    {
        *value = AGX2K3K_VAL_ALL;
    }
    else
    {
        *value = atoi (buffer);
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrSearchSerialFlexrayFrame_WriteCallback (ViSession vi,
                                                                            ViSession io,
                                                                            ViConstString channelName,
                                                                            ViAttr attributeId,
                                                                            ViInt32 value)
{
    ViStatus error = VI_SUCCESS;

    if (value == AGX2K3K_VAL_ALL)
    {
        viCheckErr (viPrintf (io, ":SEAR:SER:FLEX:FRAM ALL"));
    }
    else
    {
        viCheckErr (viPrintf (io, ":SEAR:SER:FLEX:FRAM %d", value));
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_MEAS_STAT_MCOUNT */
static ViStatus _VI_FUNC agx2k3kAttrMeasStatMcount_ReadCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViInt32 *value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    viCheckErr (viQueryf (io, ":MEAS:STAT:MCO?", "%s", buffer));

    if (!strcmp (buffer, "INF"))
    {
        *value = AGX2K3K_VAL_INFINITE;
    }
    else
    {
        *value = atoi (buffer);
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrMeasStatMcount_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViInt32 value)
{
    ViStatus error = VI_SUCCESS;

    if (value == AGX2K3K_VAL_INFINITE)
    {
        viCheckErr (viPrintf (io, ":MEAS:STAT:MCO INF"));
    }
    else
    {
        viCheckErr (viPrintf (io, ":MEAS:STAT:MCO %d", value));
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrMeasStatMcount_CheckCallback (ViSession vi,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViInt32 value)
{
    ViStatus error = VI_SUCCESS;

    if ((value < 2 || value > 200) && (value != AGX2K3K_VAL_INFINITE))
    {
        viCheckErr (IVI_ERROR_INVALID_VALUE);
    }

Error:
    return error;
}


/* AGX2K3K_ATTR_FLEXRAY_TRIGGER_EVENT_BASS_ID */
static ViStatus _VI_FUNC agx2k3kAttrFlexrayTriggerEventBassId_ReadCallback (ViSession vi,
                                                                            ViSession io,
                                                                            ViConstString channelName,
                                                                            ViAttr attributeId,
                                                                            ViInt32 *value)
{
    ViStatus error = VI_SUCCESS;
    ViChar   buffer[BUFFER_SIZE];

    viCheckErr (viQueryf (io, "%s:FLEX:TRIG:EVEN:BSS:ID?", "%s", channelName, buffer));
    if (!strcmp (buffer, "ALL"))
    {
        *value = AGX2K3K_VAL_ALL;
    }
    else
    {
        *value = atoi (buffer);
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrFlexrayTriggerEventBassId_WriteCallback (ViSession vi,
                                                                             ViSession io,
                                                                             ViConstString channelName,
                                                                             ViAttr attributeId,
                                                                             ViInt32 value)
{
    ViStatus error = VI_SUCCESS;

    if (value == AGX2K3K_VAL_ALL)
    {
        viCheckErr (viPrintf (io, "%s:FLEX:TRIG:EVEN:BSS:ID ALL", channelName));
    }
    else
    {
        viCheckErr (viPrintf (io, "%s:FLEX:TRIG:EVEN:BSS:ID %d", channelName, value));
    }

Error:
    return error;
}

/* AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_ID */
static ViStatus _VI_FUNC agx2k3kAttrFlexrayTriggerFrameId_ReadCallback (ViSession vi,
                                                                        ViSession io,
                                                                        ViConstString channelName,
                                                                        ViAttr attributeId,
                                                                        ViInt32 *value)
{
    ViStatus error = VI_SUCCESS;

    ViChar   buffer[BUFFER_SIZE];

    viCheckErr (viQueryf (io, "%s:FLEX:TRIG:FRAM:ID?", "%s", channelName, buffer));
    if (!strcmp (buffer, "ALL"))
    {
        *value = AGX2K3K_VAL_ALL;
    }
    else
    {
        *value = atoi (buffer);
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kAttrFlexrayTriggerFrameId_WriteCallback (ViSession vi,
                                                                         ViSession io,
                                                                         ViConstString channelName,
                                                                         ViAttr attributeId,
                                                                         ViInt32 value)
{
    ViStatus error = VI_SUCCESS;

    if (value == AGX2K3K_VAL_ALL)
    {
        viCheckErr (viPrintf (io, "%s:FLEX:TRIG:FRAM:ID ALL", channelName));
    }
    else
    {
        viCheckErr (viPrintf (io, "%s:FLEX:TRIG:FRAM:ID %d", channelName, value));
    }

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kFirstCurrentSource_ReadCallback (ViSession vi,
                                                                 ViSession io,
                                                                 ViConstString channelName,
                                                                 ViAttr attributeId,
                                                                 ViInt32 *value)
{
    ViStatus         error = VI_SUCCESS;
    ViChar           source[BUFFER_SIZE];
    IviRangeTablePtr tblPtr = VI_NULL;

    viCheckErr (viQueryf (io, ":POW:SIGN:SOUR:CURR1?", "%s", source));

    checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &tblPtr));
    viCheckErr (Ivi_GetViInt32EntryFromString (source, tblPtr,
                                               value, VI_NULL, VI_NULL, VI_NULL, VI_NULL));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kFirstVoltSource_ReadCallback (ViSession vi,
                                                              ViSession io,
                                                              ViConstString channelName,
                                                              ViAttr attributeId,
                                                              ViInt32 *value)
{
    ViStatus         error = VI_SUCCESS;
    ViChar           source[BUFFER_SIZE];
    IviRangeTablePtr tblPtr = VI_NULL;

    viCheckErr (viQueryf (io, ":POW:SIGN:SOUR:VOLT1?", "%s", source));

    checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &tblPtr));
    viCheckErr (Ivi_GetViInt32EntryFromString (source, tblPtr,
                                               value, VI_NULL, VI_NULL, VI_NULL, VI_NULL));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kSecondCurrentSource_ReadCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViInt32 *value)
{
    ViStatus         error = VI_SUCCESS;
    ViChar           source[BUFFER_SIZE];
    IviRangeTablePtr tblPtr = VI_NULL;

    viCheckErr (viQueryf (io, ":POW:SIGN:SOUR:CURR2?", "%s", source));

    checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &tblPtr));
    viCheckErr (Ivi_GetViInt32EntryFromString (source, tblPtr,
                                               value, VI_NULL, VI_NULL, VI_NULL, VI_NULL));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kSecondVoltSource_ReadCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViInt32 *value)
{
    ViStatus         error = VI_SUCCESS;
    ViChar           source[BUFFER_SIZE];
    IviRangeTablePtr tblPtr = VI_NULL;

    viCheckErr (viQueryf (io, ":POW:SIGN:SOUR:VOLT2?", "%s", source));

    checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &tblPtr));
    viCheckErr (Ivi_GetViInt32EntryFromString (source, tblPtr,
                                               value, VI_NULL, VI_NULL, VI_NULL, VI_NULL));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kFirstCurrentSource_WriteCallback (ViSession vi,
                                                                  ViSession io,
                                                                  ViConstString channelName,
                                                                  ViAttr attributeId,
                                                                  ViInt32 value)
{
    ViStatus         error = VI_SUCCESS;
    ViString         source;
    IviRangeTablePtr tblPtr = VI_NULL;

    checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &tblPtr));
    viCheckErr (Ivi_GetViInt32EntryFromValue (value, tblPtr,
                                              VI_NULL, VI_NULL, VI_NULL, VI_NULL, &source, VI_NULL));

    viCheckErr (viPrintf (io, ":POW:SIGN:SOUR:CURR1 %s", source));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kFirstVoltSource_WriteCallback (ViSession vi,
                                                               ViSession io,
                                                               ViConstString channelName,
                                                               ViAttr attributeId,
                                                               ViInt32 value)
{
    ViStatus         error = VI_SUCCESS;
    ViString         source;
    IviRangeTablePtr tblPtr = VI_NULL;

    checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &tblPtr));
    viCheckErr (Ivi_GetViInt32EntryFromValue (value, tblPtr,
                                              VI_NULL, VI_NULL, VI_NULL, VI_NULL, &source, VI_NULL));

    viCheckErr (viPrintf (io, ":POW:SIGN:SOUR:VOLT1 %s", source));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kSecondCurrentSource_WriteCallback (ViSession vi,
                                                                   ViSession io,
                                                                   ViConstString channelName,
                                                                   ViAttr attributeId,
                                                                   ViInt32 value)
{
    ViStatus         error = VI_SUCCESS;
    ViString         source;
    IviRangeTablePtr tblPtr = VI_NULL;

    checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &tblPtr));
    viCheckErr (Ivi_GetViInt32EntryFromValue (value, tblPtr,
                                              VI_NULL, VI_NULL, VI_NULL, VI_NULL, &source, VI_NULL));

    viCheckErr (viPrintf (io, ":POW:SIGN:SOUR:CURR2 %s", source));

Error:
    return error;
}

static ViStatus _VI_FUNC agx2k3kSecondVoltSource_WriteCallback (ViSession vi,
                                                                ViSession io,
                                                                ViConstString channelName,
                                                                ViAttr attributeId,
                                                                ViInt32 value)
{
    ViStatus         error = VI_SUCCESS;
    ViString         source;
    IviRangeTablePtr tblPtr = VI_NULL;

    checkErr (Ivi_GetAttrRangeTable (vi, channelName, attributeId, &tblPtr));
    viCheckErr (Ivi_GetViInt32EntryFromValue (value, tblPtr,
                                              VI_NULL, VI_NULL, VI_NULL, VI_NULL, &source, VI_NULL));

    viCheckErr (viPrintf (io, ":POW:SIGN:SOUR:VOLT2 %s", source));

Error:
    return error;
}

/*****************************************************************************
 * Function: agx2k3k_InitAttributes
 * Purpose:  This function adds attributes to the IVI session, initializes
 *           instrument attributes, and sets attribute invalidation
 *           dependencies.
 *****************************************************************************/
static ViStatus agx2k3k_InitAttributes (ViSession vi,
                                        ViInt32 modelType,
                                        ViInt32 options)
{
    ViStatus error = VI_SUCCESS;
    ViInt32  flags = 0;
    ViChar   idnBuffer[BUFFER_SIZE];
    ViString pmodel_string = NULL;

    ViChar   AnalogChannels[BUFFER_SIZE];
    ViChar   AnalogExtChannels[BUFFER_SIZE];
    ViChar   AnalogExtMathChannels[BUFFER_SIZE];

    checkErr (Ivi_GetStringFromTable (gs_agx2k3k_ModelTable, modelType, &pmodel_string));
    /*  IDquery string */
    sprintf (idnBuffer, "AGILENT TECHNOLOGIES,%s,30d309053f,01.30", pmodel_string);

    /*- Initialize instrument attributes --------------------------------*/
    checkErr (Ivi_SetAttrReadCallbackViString (vi, AGX2K3K_ATTR_SPECIFIC_DRIVER_REVISION,
                                               agx2k3kAttrDriverRevision_ReadCallback));
    checkErr (Ivi_SetAttributeViInt32 (vi, "", AGX2K3K_ATTR_SPECIFIC_DRIVER_CLASS_SPEC_MAJOR_VERSION,
                                       0, AGX2K3K_CLASS_SPEC_MAJOR_VERSION));
    checkErr (Ivi_SetAttributeViInt32 (vi, "", AGX2K3K_ATTR_SPECIFIC_DRIVER_CLASS_SPEC_MINOR_VERSION,
                                       0, AGX2K3K_CLASS_SPEC_MINOR_VERSION));
    checkErr (Ivi_SetAttributeViString (vi, "", AGX2K3K_ATTR_SUPPORTED_INSTRUMENT_MODELS,
                                        0, AGX2K3K_SUPPORTED_INSTRUMENT_MODELS));


    checkErr (Ivi_GetAttributeFlags (vi, AGX2K3K_ATTR_INSTRUMENT_FIRMWARE_REVISION, &flags));
    checkErr (Ivi_SetAttributeFlags (vi, AGX2K3K_ATTR_INSTRUMENT_FIRMWARE_REVISION,
                                     flags | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION));
    checkErr (Ivi_SetAttrReadCallbackViString (vi, AGX2K3K_ATTR_INSTRUMENT_FIRMWARE_REVISION,
                                               agx2k3kAttrFirmwareRevision_ReadCallback));

    checkErr (Ivi_GetAttributeFlags (vi, AGX2K3K_ATTR_INSTRUMENT_MANUFACTURER, &flags));
    checkErr (Ivi_SetAttributeFlags (vi, AGX2K3K_ATTR_INSTRUMENT_MANUFACTURER,
                                     flags | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION));
    checkErr (Ivi_SetAttrReadCallbackViString (vi, AGX2K3K_ATTR_INSTRUMENT_MANUFACTURER,
                                               agx2k3kAttrInstrumentManufacturer_ReadCallback));

    checkErr (Ivi_GetAttributeFlags (vi, AGX2K3K_ATTR_INSTRUMENT_MODEL, &flags));
    checkErr (Ivi_SetAttributeFlags (vi, AGX2K3K_ATTR_INSTRUMENT_MODEL,
                                     flags | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION));
    checkErr (Ivi_SetAttrReadCallbackViString (vi, AGX2K3K_ATTR_INSTRUMENT_MODEL,
                                               agx2k3kAttrInstrumentModel_ReadCallback));

    checkErr (Ivi_SetAttributeViString (vi, "", AGX2K3K_ATTR_SPECIFIC_DRIVER_VENDOR,
                                        0, AGX2K3K_DRIVER_VENDOR));
    checkErr (Ivi_SetAttributeViString (vi, "", AGX2K3K_ATTR_SPECIFIC_DRIVER_DESCRIPTION,
                                        0, AGX2K3K_DRIVER_DESCRIPTION));
    checkErr (Ivi_SetAttributeViAddr (vi, VI_NULL, IVI_ATTR_OPC_CALLBACK, 0,
                                      agx2k3k_WaitForOPCCallback));
    checkErr (Ivi_SetAttributeViAddr (vi, VI_NULL, IVI_ATTR_CHECK_STATUS_CALLBACK, 0,
                                      agx2k3k_CheckStatusCallback));


    checkErr (Ivi_SetAttributeViString (vi, "", AGX2K3K_ATTR_GROUP_CAPABILITIES, 0,
                                        "IviScopeBase,"
                                        "IviScopeInterpolation,"
                                        "IviScopeTVTrigger,"
                                        "IviScopeRuntTrigger,"
                                        "IviScopeGlitchTrigger,"
                                        "IviScopeWaveformMeas,"
                                        "IviScopeMinMaxWaveform,"
                                        "IviScopeProbeAutoSense,"
                                        "IviScopeContinuousAcquisition,"
                                        "IviScopeAverageAcquisition,"
                                        "IviScopeSampleMode,"
                                        "IviScopeTriggerModifier,"
                                        "IviScopeAutoSetup"));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_WGEN_ARBITRARY_BYTEORDER,
                                       "AGX2K3K_ATTR_WGEN_ARBITRARY_BYTEORDER",
                                       AGX2K3K_VAL_LSB_FIRST, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &ByteorderRangeTable));

    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_WGEN_ARBITRARY_BYTEORDER_MULTICHANNEL,
                                       "AGX2K3K_ATTR_WGEN_ARBITRARY_BYTEORDER_MULTICHANNEL",
                                       AGX2K3K_VAL_LSB_FIRST, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &ByteorderRangeTable));

    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_WGEN_ARBITRARY_INTERPOLATE,
                                         "AGX2K3K_ATTR_WGEN_ARBITRARY_INTERPOLATE",
                                         VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_WGEN_MODULATION_NOISE,
                                       "AGX2K3K_ATTR_WGEN_MODULATION_NOISE", 0, 0,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &PercentRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_WGEN_MODULATION_NOISE_MULTICHANNEL,
                                       "AGX2K3K_ATTR_WGEN_MODULATION_NOISE_MULTICHANNEL",
                                       0, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &PercentRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_SERIAL_A429_LABEL,
                                       "AGX2K3K_ATTR_SEARCH_SERIAL_A429_LABEL", 0, 0,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &LabelRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_SERIAL_A429_MODE,
                                       "AGX2K3K_ATTR_SEARCH_SERIAL_A429_MODE",
                                       AGX2K3K_VAL_LABEL, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &SearchSerialA429ModeRangeTable));
    checkErr (Ivi_AddAttributeViString (vi,
                                        AGX2K3K_ATTR_SEARCH_SERIAL_A429_PATTERN_DATA,
                                        "AGX2K3K_ATTR_SEARCH_SERIAL_A429_PATTERN_DATA",
                                        "0000000000000000000", 0,
                                        agx2k3kViQuotedString_ReadCallback,
                                        agx2k3kViQuotedString_WriteCallback));
    checkErr (Ivi_AddAttributeViString (vi,
                                        AGX2K3K_ATTR_SEARCH_SERIAL_A429_PATTERN_SDI,
                                        "AGX2K3K_ATTR_SEARCH_SERIAL_A429_PATTERN_SDI",
                                        "00", 0, agx2k3kViQuotedString_ReadCallback,
                                        agx2k3kViQuotedString_WriteCallback));
    checkErr (Ivi_AddAttributeViString (vi,
                                        AGX2K3K_ATTR_SEARCH_SERIAL_A429_PATTERN_SSM,
                                        "AGX2K3K_ATTR_SEARCH_SERIAL_A429_PATTERN_SSM",
                                        "00", 0, agx2k3kViQuotedString_ReadCallback,
                                        agx2k3kViQuotedString_WriteCallback));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_CYCLE,
                                       "AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_CYCLE",
                                       AGX2K3K_VAL_ALL, 0,
                                       agx2k3kAttrSearchSerialFlexrayCycle_ReadCallback,
                                       agx2k3kAttrSearchSerialFlexrayCycle_WriteCallback,
                                       &SearchSerialFlexrayCycleRangeTable));
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_DATA,
                                        "AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_DATA",
                                        "\"0xXX\"", 0,
                                        agx2k3kViQuotedString_ReadCallback,
                                        agx2k3kViQuotedString_WriteCallback));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_DATA_LENGTH,
                                       "AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_DATA_LENGTH",
                                       1, 0, agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &SearchSerialFlexrayDataLengthRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_FRAME,
                                       "AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_FRAME",
                                       AGX2K3K_VAL_ALL, 0,
                                       agx2k3kAttrSearchSerialFlexrayFrame_ReadCallback,
                                       agx2k3kAttrSearchSerialFlexrayFrame_WriteCallback,
                                       &SearchSerialFlexrayFrameRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_MODE,
                                       "AGX2K3K_ATTR_SEARCH_SERIAL_FLEXRAY_MODE",
                                       AGX2K3K_VAL_LABEL, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &SearchSerialFlexrayModeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_SERIAL_M1553_MODE,
                                       "AGX2K3K_ATTR_SEARCH_SERIAL_M1553_MODE",
                                       AGX2K3K_VAL_CSTART, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &M1553ModeRangeTable));
    checkErr (Ivi_AddAttributeViString (vi,
                                        AGX2K3K_ATTR_SEARCH_SERIAL_M1553_PATTERN_DATA,
                                        "AGX2K3K_ATTR_SEARCH_SERIAL_M1553_PATTERN_DATA",
                                        "0000000000000000000", 0,
                                        agx2k3kViQuotedString_ReadCallback,
                                        agx2k3kViQuotedString_WriteCallback));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_SERIAL_M1553_RTA,
                                       "AGX2K3K_ATTR_SEARCH_SERIAL_M1553_RTA", 0, 0,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &SearchSerialM1553RtaRangeTable));
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_SAVE_MAX_WAVE_ENABLED,
                                         "AGX2K3K_ATTR_SAVE_MAX_WAVE_ENABLED",
                                         VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_DEMO_FUNCTION,
                                       "AGX2K3K_ATTR_DEMO_FUNCTION",
                                       AGX2K3K_VAL_FUNC_SINUSOID, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &DemoFunctionRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_PATTERN_FORMAT,
                                       "AGX2K3K_ATTR_TRIGGER_PATTERN_FORMAT",
                                       AGX2K3K_VAL_PATTERN_HEX, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &TriggerPatternFormatRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_TV_UDTV_ENUMBER,
                                       "AGX2K3K_ATTR_TRIGGER_TV_UDTV_ENUMBER", 1, 0,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback, VI_NULL));
    checkErr (Ivi_AddAttributeViBoolean (vi,
                                         AGX2K3K_ATTR_TRIGGER_TV_UDTV_HSYNC_ENABLED,
                                         "AGX2K3K_ATTR_TRIGGER_TV_UDTV_HSYNC_ENABLED",
                                         VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_TRIGGER_TV_UDTV_HTIME,
                                        "AGX2K3K_ATTR_TRIGGER_TV_UDTV_HTIME", 1E-6,
                                        0, agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_TRIGGER_TV_UDTV_PGTHAN,
                                        "AGX2K3K_ATTR_TRIGGER_TV_UDTV_PGTHAN", 26E-6,
                                        0, agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_DELAY_ARM_SLOPE,
                                       "AGX2K3K_ATTR_TRIGGER_DELAY_ARM_SLOPE",
                                       AGX2K3K_VAL_POSITIVE, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback, &SlopeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_DELAY_ARM_SOURCE,
                                       "AGX2K3K_ATTR_TRIGGER_DELAY_ARM_SOURCE",
                                       AGX2K3K_VAL_CHANNEL_1, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback, &ChannelRangeTable));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_TRIGGER_DELAY_TDELAY_TIME,
                                        "AGX2K3K_ATTR_TRIGGER_DELAY_TDELAY_TIME",
                                        4E-9, 0, agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_DELAY_TRIGGER_COUNT,
                                       "AGX2K3K_ATTR_TRIGGER_DELAY_TRIGGER_COUNT", 1,
                                       0, agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback, VI_NULL));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_DELAY_TRIGGER_SLOPE,
                                       "AGX2K3K_ATTR_TRIGGER_DELAY_TRIGGER_SLOPE",
                                       AGX2K3K_VAL_SLOPE_POSITIVE, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback, &SlopeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_DELAY_TRIGGER_SOURCE,
                                       "AGX2K3K_ATTR_TRIGGER_DELAY_TRIGGER_SOURCE",
                                       AGX2K3K_VAL_CHANNEL_1, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback, &ChannelRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_MARKER_XUNIT,
                                       "AGX2K3K_ATTR_MARKER_XUNIT",
                                       AGX2K3K_VAL_SECONDS, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &MarkerXunitRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_MARKER_YUNIT,
                                       "AGX2K3K_ATTR_MARKER_YUNIT", AGX2K3K_VAL_BASE,
                                       0, agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &MarkerYunitRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FUNCTION_BUS_CLOCK,
                                       "AGX2K3K_ATTR_FUNCTION_BUS_CLOCK",
                                       AGX2K3K_VAL_DIGITAL_0, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &DigitalChannelRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_FUNCTION_BUS_CLOCK_MULTICHANNEL,
                                       "AGX2K3K_ATTR_FUNCTION_BUS_CLOCK_MULTICHANNEL",
                                       AGX2K3K_VAL_DIGITAL_0, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &DigitalChannelRangeTable));

    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FUNCTION_BUS_SLOPE,
                                       "AGX2K3K_ATTR_FUNCTION_BUS_SLOPE",
                                       AGX2K3K_VAL_POSITIVE, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &BusSlopeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_FUNCTION_BUS_SLOPE_MULTICHANNEL,
                                       "AGX2K3K_ATTR_FUNCTION_BUS_SLOPE_MULTICHANNEL",
                                       AGX2K3K_VAL_POSITIVE, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &BusSlopeRangeTable));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FUNCTION_BUS_YINCREMENT,
                                        "AGX2K3K_ATTR_FUNCTION_BUS_YINCREMENT", 1E-3,
                                        0, agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_FUNCTION_BUS_YINCREMENT_MULTICHANNEL,
                                        "AGX2K3K_ATTR_FUNCTION_BUS_YINCREMENT_MULTICHANNEL",
                                        1E-3, IVI_VAL_MULTI_CHANNEL,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FUNCTION_BUS_YORIGIN,
                                        "AGX2K3K_ATTR_FUNCTION_BUS_YORIGIN", 0, 0,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_FUNCTION_BUS_YORIGIN_MULTICHANNEL,
                                        "AGX2K3K_ATTR_FUNCTION_BUS_YORIGIN_MULTICHANNEL",
                                        0, IVI_VAL_MULTI_CHANNEL,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FUNCTION_BUS_YUNITS,
                                       "AGX2K3K_ATTR_FUNCTION_BUS_YUNITS",
                                       AGX2K3K_VAL_BUS_VOLT, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FunctionBusYunitsRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_FUNCTION_BUS_YUNITS_MULTICHANNEL,
                                       "AGX2K3K_ATTR_FUNCTION_BUS_YUNITS_MULTICHANNEL",
                                       AGX2K3K_VAL_BUS_VOLT, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FunctionBusYunitsRangeTable));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FUNCTION_FREQ_HIGHPASS,
                                        "AGX2K3K_ATTR_FUNCTION_FREQ_HIGHPASS", 1, 0,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_FUNCTION_FREQ_HIGHPASS_MULTICHANNEL,
                                        "AGX2K3K_ATTR_FUNCTION_FREQ_HIGHPASS_MULTICHANNEL",
                                        1, IVI_VAL_MULTI_CHANNEL,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FUNCTION_FREQ_LOWPASS,
                                        "AGX2K3K_ATTR_FUNCTION_FREQ_LOWPASS", 1E9, 0,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_FUNCTION_FREQ_LOWPASS_MULTICHANNEL,
                                        "AGX2K3K_ATTR_FUNCTION_FREQ_LOWPASS_MULTICHANNEL",
                                        1E9, IVI_VAL_MULTI_CHANNEL,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FUNCTION_LINEAR_GAIN,
                                        "AGX2K3K_ATTR_FUNCTION_LINEAR_GAIN", 1, 0,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_FUNCTION_LINEAR_GAIN_MULTICHANNEL,
                                        "AGX2K3K_ATTR_FUNCTION_LINEAR_GAIN_MULTICHANNEL",
                                        1, IVI_VAL_MULTI_CHANNEL,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FUNCTION_LINEAR_OFFSET,
                                        "AGX2K3K_ATTR_FUNCTION_LINEAR_OFFSET", 0, 0,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_FUNCTION_LINEAR_OFFSET_MULTICHANNEL,
                                        "AGX2K3K_ATTR_FUNCTION_LINEAR_OFFSET_MULTICHANNEL",
                                        0, IVI_VAL_MULTI_CHANNEL,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FUNCTION_TREND_MEASUREMENT,
                                       "AGX2K3K_ATTR_FUNCTION_TREND_MEASUREMENT",
                                       AGX2K3K_VAL_FREQUENCY, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FunctionTypeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_FUNCTION_TREND_MEASUREMENT_MULTICHANNEL,
                                       "AGX2K3K_ATTR_FUNCTION_TREND_MEASUREMENT_MULTICHANNEL",
                                       AGX2K3K_VAL_FREQUENCY, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FunctionTypeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FUNCTION_VTYPE,
                                       "AGX2K3K_ATTR_FUNCTION_VTYPE",
                                       AGX2K3K_VAL_VTYPE_DECIBEL, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FunctionVtypeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FUNCTION_VTYPE_MULTICHANNEL,
                                       "AGX2K3K_ATTR_FUNCTION_VTYPE_MULTICHANNEL",
                                       AGX2K3K_VAL_VTYPE_DECIBEL,
                                       IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FunctionVtypeRangeTable));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FUNCTION_INTEGRATE_IOFFSET,
                                        "AGX2K3K_ATTR_FUNCTION_INTEGRATE_IOFFSET", 0,
                                        0, agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_FUNCTION_INTEGRATE_IOFFSET_MULTICHANNEL,
                                        "AGX2K3K_ATTR_FUNCTION_INTEGRATE_IOFFSET_MULTICHANNEL",
                                        0, IVI_VAL_MULTI_CHANNEL,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_MEAS_STAT_RESD_ENABLED,
                                         "AGX2K3K_ATTR_MEAS_STAT_RESD_ENABLED",
                                         VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_MEAS_STAT_MCOUNT,
                                       "AGX2K3K_ATTR_MEAS_STAT_MCOUNT",
                                       AGX2K3K_VAL_INFINITE, 0,
                                       agx2k3kAttrMeasStatMcount_ReadCallback,
                                       agx2k3kAttrMeasStatMcount_WriteCallback,
                                       VI_NULL));
    checkErr (Ivi_SetAttrCheckCallbackViInt32 (vi, AGX2K3K_ATTR_MEAS_STAT_MCOUNT,
                                               agx2k3kAttrMeasStatMcount_CheckCallback));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_SIGNALS_AUTOSETUP_TYPE,
                                       "AGX2K3K_ATTR_POWER_SIGNALS_AUTOSETUP_TYPE",
                                       AGX2K3K_VAL_HARMONICS, 0, VI_NULL,
                                       agx2k3kEnum_WriteCallback,
                                       &PowerSignalsAutosetupTypeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_POWER_SIGNALS_VOLT_FIRST_SOURCE,
                                       "AGX2K3K_ATTR_POWER_SIGNALS_VOLT_FIRST_SOURCE",
                                       AGX2K3K_VAL_CHANNEL_1, 0,
                                       agx2k3kFirstVoltSource_ReadCallback,
                                       agx2k3kFirstVoltSource_WriteCallback,
                                       &AnalogChannelRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_POWER_SIGNALS_VOLT_SECOND_SOURCE,
                                       "AGX2K3K_ATTR_POWER_SIGNALS_VOLT_SECOND_SOURCE",
                                       AGX2K3K_VAL_CHANNEL_1, 0,
                                       agx2k3kSecondVoltSource_ReadCallback,
                                       agx2k3kSecondVoltSource_WriteCallback,
                                       &AnalogChannelRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_POWER_SIGNALS_CURRENT_FIRST_SOURCE,
                                       "AGX2K3K_ATTR_POWER_SIGNALS_CURRENT_FIRST_SOURCE",
                                       AGX2K3K_VAL_CHANNEL_1, 0,
                                       agx2k3kFirstCurrentSource_ReadCallback,
                                       agx2k3kFirstCurrentSource_WriteCallback,
                                       &AnalogChannelRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_POWER_SIGNALS_CURRENT_SECOND_SOURCE,
                                       "AGX2K3K_ATTR_POWER_SIGNALS_CURRENT_SECOND_SOURCE",
                                       AGX2K3K_VAL_CHANNEL_1, 0,
                                       agx2k3kSecondCurrentSource_ReadCallback,
                                       agx2k3kSecondCurrentSource_WriteCallback,
                                       &AnalogChannelRangeTable));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_SIGNALS_VMAXIMUM,
                                        "AGX2K3K_ATTR_POWER_SIGNALS_VMAXIMUM", 20, 0,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_SIGNALS_VSTEADY,
                                        "AGX2K3K_ATTR_POWER_SIGNALS_VSTEADY", 20, 0,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_SIGNALS_OVERSHOOT,
                                       "AGX2K3K_ATTR_POWER_SIGNALS_OVERSHOOT", 5, 0,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &PercentRangeTable));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_SIGNALS_IEXPECTED,
                                        "AGX2K3K_ATTR_POWER_SIGNALS_IEXPECTED", 2, 0,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_SIGNALS_DURATION,
                                        "AGX2K3K_ATTR_POWER_SIGNALS_DURATION", 1E-6,
                                        0, agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_SIGNALS_CYCLES,
                                       "AGX2K3K_ATTR_POWER_SIGNALS_CYCLES", 1, 0,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &PowerSignalsCyclesRangeTable));
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_POWER_ENABLED,
                                         "AGX2K3K_ATTR_POWER_ENABLED", VI_FALSE, 0,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_POWER_HARMONICS_DISPLAY_STYLE,
                                       "AGX2K3K_ATTR_POWER_HARMONICS_DISPLAY_STYLE",
                                       AGX2K3K_VAL_TABLE, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &PowerHarmonicsDisplayStyleRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_HARMONICS_LINE,
                                       "AGX2K3K_ATTR_POWER_HARMONICS_LINE",
                                       AGX2K3K_VAL_F50, 0, agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &PowerHarmonicsLineRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_HARMONICS_STANDARD,
                                       "AGX2K3K_ATTR_POWER_HARMONICS_STANDARD",
                                       AGX2K3K_VAL_STANDARD_A, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &PowerHarmonicsStandardRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_MODULATION_SOURCE,
                                       "AGX2K3K_ATTR_POWER_MODULATION_SOURCE",
                                       AGX2K3K_VAL_V, 0, agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &VISourceRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_MODULATION_TYPE,
                                       "AGX2K3K_ATTR_POWER_MODULATION_TYPE",
                                       AGX2K3K_VAL_FREQUENCY, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FunctionTypeRangeTable));
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_POWER_ANALYSIS_ENABLED,
                                         "AGX2K3K_ATTR_POWER_ANALYSIS_ENABLED",
                                         VI_TRUE, 0, agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_PSRR_FREQUENCY_MAX,
                                       "AGX2K3K_ATTR_POWER_PSRR_FREQUENCY_MAX",
                                       AGX2K3K_VAL_100_KHZ, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &PowerFrequencyMaxRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_PSRR_FREQUENCY_MIN,
                                       "AGX2K3K_ATTR_POWER_PSRR_FREQUENCY_MIN",
                                       AGX2K3K_VAL_100_HZ, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &PowerFrequencyMinRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_PSRR_RMAX,
                                       "AGX2K3K_ATTR_POWER_PSRR_RMAX", 100, 0,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback, VI_NULL));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_QUALITY_TYPE,
                                       "AGX2K3K_ATTR_POWER_QUALITY_TYPE",
                                       AGX2K3K_VAL_FACTOR, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &PowerQualityTypeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_SLEW_SOURCE,
                                       "AGX2K3K_ATTR_POWER_SLEW_SOURCE",
                                       AGX2K3K_VAL_I, 0, agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &VISourceRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_SWITCH_CONDUCTION,
                                       "AGX2K3K_ATTR_POWER_SWITCH_CONDUCTION",
                                       AGX2K3K_VAL_WAVEFORM, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &PowerSwitchConductionRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_SWITCH_IREFERENCE,
                                       "AGX2K3K_ATTR_POWER_SWITCH_IREFERENCE", 5, 0,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &PercentRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_SWITCH_VREFERENCE,
                                       "AGX2K3K_ATTR_POWER_SWITCH_VREFERENCE", 5, 0,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &PercentRangeTable));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_SWITCH_RDS,
                                        "AGX2K3K_ATTR_POWER_SWITCH_RDS", 0.02, 0,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_SWITCH_VCE,
                                        "AGX2K3K_ATTR_POWER_SWITCH_VCE", 2, 0,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_TRANSIENT_IINITIAL,
                                        "AGX2K3K_ATTR_POWER_TRANSIENT_IINITIAL",
                                        65E-3, 0, agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_TRANSIENT_INEW,
                                        "AGX2K3K_ATTR_POWER_TRANSIENT_INEW", 225E-3,
                                        0, agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_MODE,
                                       "AGX2K3K_ATTR_SBUS_MODE", VI_NULL,
                                       IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &SbusModeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_A429_TRIGGER_TYPE,
                                       "AGX2K3K_ATTR_A429_TRIGGER_TYPE",
                                       AGX2K3K_VAL_WSTART, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &A429TriggerTypeRangeTable));
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_A429_TRIGGER_PATTERN_DATA,
                                        "AGX2K3K_ATTR_A429_TRIGGER_PATTERN_DATA",
                                        "\"XXXXXXXXXXXXXXXXXXX\"",
                                        IVI_VAL_MULTI_CHANNEL,
                                        agx2k3kViQuotedString_ReadCallback,
                                        agx2k3kViQuotedString_WriteCallback));
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_M1553_TRIGGER_PATTERN_DATA,
                                        "AGX2K3K_ATTR_M1553_TRIGGER_PATTERN_DATA",
                                        "\"XXXXXXXXXXXXXXXXXXX\"",
                                        IVI_VAL_MULTI_CHANNEL,
                                        agx2k3kViQuotedString_ReadCallback,
                                        agx2k3kViQuotedString_WriteCallback));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_M1553_TRIGGER_RTA,
                                       "AGX2K3K_ATTR_M1553_TRIGGER_RTA", -1,
                                       IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &M1553TriggerRtaRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_M1553_TRIGGER_TYPE,
                                       "AGX2K3K_ATTR_M1553_TRIGGER_TYPE",
                                       AGX2K3K_VAL_CSTART, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &M1553TriggerTypeRangeTable));
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_A429_TRIGGER_PATTERN_SDI,
                                        "AGX2K3K_ATTR_A429_TRIGGER_PATTERN_SDI",
                                        "00", IVI_VAL_MULTI_CHANNEL,
                                        agx2k3kViQuotedString_ReadCallback,
                                        agx2k3kViQuotedString_WriteCallback));
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_A429_TRIGGER_PATTERN_SSM,
                                        "AGX2K3K_ATTR_A429_TRIGGER_PATTERN_SSM",
                                        "00", IVI_VAL_MULTI_CHANNEL,
                                        agx2k3kViQuotedString_ReadCallback,
                                        agx2k3kViQuotedString_WriteCallback));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_A429_TRIGGER_LABEL,
                                        "AGX2K3K_ATTR_A429_TRIGGER_LABEL", -1,
                                        IVI_VAL_MULTI_CHANNEL,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &A429TriggerLabelRangeTable, 0));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_A429_BASE,
                                       "AGX2K3K_ATTR_A429_BASE",
                                       AGX2K3K_VAL_BASE_HEX, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &SBusBaseRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_M1553_BASE,
                                       "AGX2K3K_ATTR_M1553_BASE",
                                       AGX2K3K_VAL_BASE_HEX, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &SBusBaseRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_M1553_SOURCE,
                                       "AGX2K3K_ATTR_M1553_SOURCE",
                                       AGX2K3K_VAL_CHANNEL_1, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &AnalogChannelRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_A429_FORMAT,
                                       "AGX2K3K_ATTR_A429_FORMAT",
                                       AGX2K3K_VAL_FORMAT_LDSDI,
                                       IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &A429FormatRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_A429_SIGNAL,
                                       "AGX2K3K_ATTR_A429_SIGNAL",
                                       AGX2K3K_VAL_SIGNAL_DIFFERENTIAL,
                                       IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &A429SignalRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_A429_SOURCE,
                                       "AGX2K3K_ATTR_A429_SOURCE",
                                       AGX2K3K_VAL_CHANNEL_1, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &AnalogChannelRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_A429_SPEED,
                                       "AGX2K3K_ATTR_A429_SPEED",
                                       AGX2K3K_VAL_CHANNEL_1, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &A429SpeedRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FLEXRAY_BAUDRATE,
                                       "AGX2K3K_ATTR_FLEXRAY_BAUDRATE",
                                       AGX2K3K_VAL_10_MB, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FlexrayBaudrateRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FLEXRAY_CHANNEL,
                                       "AGX2K3K_ATTR_FLEXRAY_CHANNEL",
                                       AGX2K3K_VAL_CHANNEL_A, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FlexrayChannelRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FLEXRAY_NULL_COUNT,
                                       "AGX2K3K_ATTR_FLEXRAY_NULL_COUNT", 0,
                                       IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback, VI_NULL));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FLEXRAY_SOURCE,
                                       "AGX2K3K_ATTR_FLEXRAY_SOURCE",
                                       AGX2K3K_VAL_CHANNEL_1, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &AnalogChannelRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FLEXRAY_TRIGGER,
                                       "AGX2K3K_ATTR_FLEXRAY_TRIGGER",
                                       AGX2K3K_VAL_FRAME, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FlexrayTriggerRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FLEXRAY_TRIGGER_ERROR_TYPE,
                                       "AGX2K3K_ATTR_FLEXRAY_TRIGGER_ERROR_TYPE",
                                       AGX2K3K_VAL_ALL, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FlexrayTriggerErrorTypeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_FLEXRAY_TRIGGER_EVENT_BASS_ID,
                                       "AGX2K3K_ATTR_FLEXRAY_TRIGGER_EVENT_BASS_ID",
                                       AGX2K3K_VAL_ALL, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kAttrFlexrayTriggerEventBassId_ReadCallback,
                                       agx2k3kAttrFlexrayTriggerEventBassId_WriteCallback,
                                       &IDRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FLEXRAY_TRIGGER_EVENT_TYPE,
                                       "AGX2K3K_ATTR_FLEXRAY_TRIGGER_EVENT_TYPE",
                                       AGX2K3K_VAL_WAKEUP, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FlexrayTriggerEventTypeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_CCREPETITION,
                                       "AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_CCREPETITION",
                                       AGX2K3K_VAL_REP_ALL, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FlexrayTriggerCcrepetitionRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_ID,
                                       "AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_ID",
                                       AGX2K3K_VAL_ALL, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kAttrFlexrayTriggerFrameId_ReadCallback,
                                       agx2k3kAttrFlexrayTriggerFrameId_WriteCallback,
                                       &IDRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_TYPE,
                                       "AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_TYPE",
                                       AGX2K3K_VAL_ALL_FRAME, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &FlexrayTriggerFrameTypeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_CC_BASE,
                                       "AGX2K3K_ATTR_FLEXRAY_TRIGGER_FRAME_CC_BASE",
                                       -1, IVI_VAL_MULTI_CHANNEL,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &FlexrayTriggerFrameCcBaseRangeTable));

    /*- AGX2K3K_ATTR_CHANNEL_ENABLED -*/
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_CHANNEL_ENABLED,
                                         "AGX2K3K_ATTR_CHANNEL_ENABLED", VI_FALSE,
                                         IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));

    /* AGX2K3K_ATTR_DIG_SIZE */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_DIG_SIZE,
                                       "AGX2K3K_ATTR_DIG_SIZE",
                                       AGX2K3K_VAL_DIGITAL_SIZE_MEDIUM,
                                       IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrDigitalChannelSizeRangeTable));

    /* AGX2K3K_ATTR_DIG_THRESHOLD */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_DIG_THRESHOLD,
                                        "AGX2K3K_ATTR_DIG_THRESHOLD", 1.4,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrDigitalThresholdRangeTable, 0));

    /* AGX2K3K_ATTR_DIG_CHANNEL_ENABLED */
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_DIG_CHANNEL_ENABLED,
                                         "AGX2K3K_ATTR_DIG_CHANNEL_ENABLED", VI_TRUE,
                                         IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));

    /* AGX2K3K_ATTR_PROBE_ATTENUATION */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_PROBE_ATTENUATION,
                                        "AGX2K3K_ATTR_PROBE_ATTENUATION", 1.0,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrProbeAttenuation_ReadCallback,
                                        agx2k3kAttrProbeAttenuation_WriteCallback,
                                        &attrProbeAttenuationRangeTable, 0));

    /* AGX2K3K_ATTR_VERTICAL_RANGE */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_VERTICAL_RANGE,
                                        "AGX2K3K_ATTR_VERTICAL_RANGE", 0.1,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrVerticalRangeRangeTable, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_VERTICAL_RANGE,
                                                agx2k3kAttrVerticalRange_CheckCallback));

    /* AGX2K3K_ATTR_VERTICAL_OFFSET */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_VERTICAL_OFFSET,
                                        "AGX2K3K_ATTR_VERTICAL_OFFSET", 0.0,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_VERTICAL_OFFSET,
                                                agx2k3kAttrVerticalOffset_CheckCallback));

    /* AGX2K3K_ATTR_VERTICAL_COUPLING */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_VERTICAL_COUPLING,
                                       "AGX2K3K_ATTR_VERTICAL_COUPLING",
                                       AGX2K3K_VAL_DC,
                                       IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrVerticalCouplingRangeTable));

    /* AGX2K3K_ATTR_MAX_INPUT_FREQUENCY */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MAX_INPUT_FREQUENCY,
                                        "AGX2K3K_ATTR_MAX_INPUT_FREQUENCY", 26.0e6,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrMaxInputFrequency_ReadCallback,
                                        agx2k3kAttrMaxInputFrequency_WriteCallback,
                                        VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_MAX_INPUT_FREQUENCY,
                                                agx2k3kAttrMaxInputFrequency_CheckCallback));

    /* AGX2K3K_ATTR_VERNIER */
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_VERNIER,
                                         "AGX2K3K_ATTR_VERNIER", VI_FALSE,
                                         IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));

    /* AGX2K3K_ATTR_INVERT */
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_INVERT,
                                         "AGX2K3K_ATTR_INVERT", VI_FALSE,
                                         IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));

    /* AGX2K3K_ATTR_INPUT_IMPEDANCE */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_INPUT_IMPEDANCE,
                                        "AGX2K3K_ATTR_INPUT_IMPEDANCE", 1.0e+06,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrInputImpedance_ReadCallback,
                                        agx2k3kAttrInputImpedance_WriteCallback,
                                        &attrInputImpedanceRangeTable, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_INPUT_IMPEDANCE,
                                                agx2k3kAttrInputImpedance_CheckCallback));

    /* AGX2K3K_ATTR_HORZ_TIME_PER_RECORD */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_HORZ_TIME_PER_RECORD,
                                        "AGX2K3K_ATTR_HORZ_TIME_PER_RECORD", 20.0e-9,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrHorzTimePerRecordRangeTable, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_HORZ_TIME_PER_RECORD,
                                                agx2k3kAttrHorzTimePerRecord_CheckCallback));

    /* AGX2K3K_ATTR_HORZ_MIN_NUM_PTS */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_HORZ_MIN_NUM_PTS,
                                       "AGX2K3K_ATTR_HORZ_MIN_NUM_PTS", 1000,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION, VI_NULL,
                                       agx2k3kAttrMinNumPts_WriteCallback,
                                       &attrMinNumPtsRangeTable));
    checkErr (Ivi_SetAttrCheckCallbackViInt32 (vi, AGX2K3K_ATTR_HORZ_MIN_NUM_PTS,
                                               agx2k3kAttrMinNumPts_CheckCallback));

    /* AGX2K3K_ATTR_HORZ_RECORD_LENGTH */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_HORZ_RECORD_LENGTH,
                                       "AGX2K3K_ATTR_HORZ_RECORD_LENGTH", 1000,
                                       IVI_VAL_NOT_USER_WRITABLE | IVI_VAL_NEVER_CACHE,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kAttrHorzRecordLength_WriteCallback,
                                       &attrMinNumPtsRangeTable));

    /* AGX2K3K_ATTR_HORZ_RECORD_MODE */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_HORZ_RECORD_MODE,
                                       "AGX2K3K_ATTR_HORZ_RECORD_MODE",
                                       AGX2K3K_VAL_RECORD_NORMAL, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kAttrHorzRecordMode_WriteCallback,
                                       &attrHorzRecordModeRangeTable));


    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_ACQUISITION_START_TIME,
                                        "AGX2K3K_ATTR_ACQUISITION_START_TIME", 0.0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrAcquisitionStartTime_ReadCallback,
                                        agx2k3kAttrAcquisitionStartTime_WriteCallback,
                                        &attrAcqStartTimeRangeTable, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_ACQUISITION_START_TIME,
                                                agx2k3kAttrAcquisitionStartTime_CheckCallback));

    /* AGX2K3K_ATTR_HORZ_SAMPLE_RATE */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_HORZ_SAMPLE_RATE,
                                        "AGX2K3K_ATTR_HORZ_SAMPLE_RATE", 0.001,
                                        IVI_VAL_NOT_USER_WRITABLE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback, VI_NULL,
                                        VI_NULL, 0));

    /*- Trigger Sub-system Attributes ------------------------------------*/
    /* AGX2K3K_ATTR_TRIGGER_TYPE */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_TYPE,
                                       "AGX2K3K_ATTR_TRIGGER_TYPE",
                                       AGX2K3K_VAL_EDGE_TRIGGER,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback, VI_NULL));
    checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_TRIGGER_TYPE,
                                             agx2k3kAttrTriggerType_RangeTableCallback));

    /* AGX2K3K_ATTR_TRIGGER_SOURCE */
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_TRIGGER_SOURCE,
                                        "AGX2K3K_ATTR_TRIGGER_SOURCE", "CHAN1",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrTriggerSource_ReadCallback,
                                        agx2k3kAttrTriggerSource_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_TRIGGER_SOURCE,
                                                agx2k3kAttrTriggerSource_CheckCallback));

    /* AGX2K3K_ATTR_TRIGGER_LEVEL */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_TRIGGER_LEVEL,
                                        "AGX2K3K_ATTR_TRIGGER_LEVEL", 0.0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrTriggerLevel_ReadCallback,
                                        agx2k3kAttrTriggerLevel_WriteCallback,
                                        VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_TRIGGER_LEVEL,
                                                agx2k3kAttrTriggerLevel_CheckCallback));

    /* AGX2K3K_ATTR_TRIGGER_LEVEL_HIGH */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_TRIGGER_LEVEL_HIGH,
                                        "AGX2K3K_ATTR_TRIGGER_LEVEL_HIGH", 1.0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /* AGX2K3K_ATTR_TRIGGER_LEVEL_LOW */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_TRIGGER_LEVEL_LOW,
                                        "AGX2K3K_ATTR_TRIGGER_LEVEL_LOW", 0.0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /* AGX2K3K_ATTR_TRIGGER_HOLDOFF */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_TRIGGER_HOLDOFF,
                                        "AGX2K3K_ATTR_TRIGGER_HOLDOFF", 60.0e-9,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrTriggerHoldoffRangeTable, 0));
    checkErr (Ivi_SetAttrCoerceCallbackViReal64 (vi, AGX2K3K_ATTR_TRIGGER_HOLDOFF,
                                                 agx2k3kAttrTriggerHoldoff_CoerceCallback));

    /* AGX2K3K_ATTR_TRIGGER_MODIFIER */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_MODIFIER,
                                       "AGX2K3K_ATTR_TRIGGER_MODIFIER",
                                       AGX2K3K_VAL_AUTO,
                                       IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrTriggerModifierRangeTable));

    /* AGX2K3K_ATTR_TRIGGER_COUPLING */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_COUPLING,
                                       "AGX2K3K_ATTR_TRIGGER_COUPLING",
                                       AGX2K3K_VAL_DC,
                                       IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrTriggerCouplingRangeTable));
    checkErr (Ivi_SetAttrCheckCallbackViInt32 (vi, AGX2K3K_ATTR_TRIGGER_COUPLING,
                                               agx2k3kAttrTriggerCoupling_CheckCallback));

    /* AGX2K3K_ATTR_TRIGGER_NOISE_REJECT */
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_TRIGGER_NOISE_REJECT,
                                         "AGX2K3K_ATTR_TRIGGER_NOISE_REJECT",
                                         VI_FALSE,
                                         IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));

    /* AGX2K3K_ATTR_TRIGGER_HF_REJECT */
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_TRIGGER_HF_REJECT,
                                         "AGX2K3K_ATTR_TRIGGER_HF_REJECT", VI_FALSE,
                                         IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViBoolean (vi, AGX2K3K_ATTR_TRIGGER_HF_REJECT,
                                                 agx2k3kAttrTriggerHFReject_CheckCallback));

    /* AGX2K3K_ATTR_TRIGGER_REJECT_FILTER */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_REJECT_FILTER,
                                       "AGX2K3K_ATTR_TRIGGER_REJECT_FILTER",
                                       AGX2K3K_VAL_REJ_FILTER_OFF,
                                       IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrTriggerRejectFilterRangeTable));

    /* AGX2K3K_ATTR_TRIGGER_SLOPE */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_SLOPE,
                                       "AGX2K3K_ATTR_TRIGGER_SLOPE",
                                       AGX2K3K_VAL_POSITIVE,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrTriggerSlopeRangeTable));

    /* AGX2K3K_ATTR_TV_TRIGGER_SIGNAL_FORMAT */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TV_TRIGGER_SIGNAL_FORMAT,
                                       "AGX2K3K_ATTR_TV_TRIGGER_SIGNAL_FORMAT",
                                       AGX2K3K_VAL_NTSC,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrTvTriggerSignalFormatRangeTable));

    /* AGX2K3K_ATTR_TV_TRIGGER_EVENT */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TV_TRIGGER_EVENT,
                                       "AGX2K3K_ATTR_TV_TRIGGER_EVENT",
                                       AGX2K3K_VAL_TV_EVENT_FIELD1,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrTvTriggerEventRangeTable));

    /* AGX2K3K_ATTR_TV_TRIGGER_LINE_NUMBER */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TV_TRIGGER_LINE_NUMBER,
                                       "AGX2K3K_ATTR_TV_TRIGGER_LINE_NUMBER", 1,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &attrTvTriggerLineNumberRangeTable));
    checkErr (Ivi_SetAttrCheckCallbackViInt32 (vi, AGX2K3K_ATTR_TV_TRIGGER_LINE_NUMBER,
                                               agx2k3kAttrTvTriggerLineNumber_CheckCallback));

    /* AGX2K3K_ATTR_TV_RIGGER_POLARITY */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TV_TRIGGER_POLARITY,
                                       "AGX2K3K_ATTR_TV_TRIGGER_POLARITY",
                                       AGX2K3K_VAL_TV_POSITIVE,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrTvTriggerPolarityRangeTable));

    /* AGX2K3K_ATTR_GLITCH_POLARITY */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_GLITCH_POLARITY,
                                       "AGX2K3K_ATTR_GLITCH_POLARITY",
                                       AGX2K3K_VAL_GLITCH_POSITIVE,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrGlitchPolarityRangeTable));

    /* AGX2K3K_ATTR_GLITCH_CONDITION */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_GLITCH_CONDITION,
                                       "AGX2K3K_ATTR_GLITCH_CONDITION",
                                       AGX2K3K_VAL_GLITCH_LESS_THAN,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrGlitchConditionRangeTable));

    /* AGX2K3K_ATTR_GLITCH_MIN_WIDTH */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_GLITCH_MIN_WIDTH,
                                        "AGX2K3K_ATTR_GLITCH_MIN_WIDTH", 20.0e-9,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrMinimumPulseWidthRangeTable, 0));

    /* AGX2K3K_ATTR_GLITCH_WIDTH */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_GLITCH_WIDTH,
                                        "AGX2K3K_ATTR_GLITCH_WIDTH", 30.0e-9,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrMaximumPulseWidthRangeTable, 0));

    /* AGX2K3K_ATTR_GLITCH_RANGE */
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_GLITCH_RANGE,
                                        "AGX2K3K_ATTR_GLITCH_RANGE", "",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_GLITCH_RANGE,
                                                agx2k3kAttrGlitchRange_CheckCallback));

    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_PATTERN,
                                        "AGX2K3K_ATTR_PATTERN", "",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrPattern_ReadCallback,
                                        agx2k3kAttrPattern_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_PATTERN,
                                                agx2k3kAttrPattern_CheckCallback));

    /* AGX2K3K_ATTR_PATTERN_RANGE */
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_PATTERN_RANGE,
                                        "AGX2K3K_ATTR_PATTERN_RANGE", "",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_PATTERN_RANGE,
                                                agx2k3kAttrPatternRange_CheckCallback));

    /* AGX2K3K_ATTR_PATTERN_QUALIFIER */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_PATTERN_QUALIFIER,
                                       "AGX2K3K_ATTR_PATTERN_QUALIFIER",
                                       AGX2K3K_VAL_PATTERN_LESSTHAN,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrPatternQualifierRangeTable));

    /* AGX2K3K_ATTR_PATTERN_MIN */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_PATTERN_MIN,
                                        "AGX2K3K_ATTR_PATTERN_MIN", 15.0e-9,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrMinimumPatternRangeTable, 0));

    /* AGX2K3K_ATTR_PATTERN_MAX */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_PATTERN_MAX,
                                        "AGX2K3K_ATTR_PATTERN_MAX", 10.0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrMaximumPatternRangeTable, 0));

    /*- 3000 series specific trigger attributes -------------*/

    /* AGX2K3K_ATTR_EBURST_COUNT */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_EBURST_COUNT,
                                       "AGX2K3K_ATTR_EBURST_COUNT", 1,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &attrEburstCountRangeTable));

    /* AGX2K3K_ATTR_EBURST_IDLE */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_EBURST_IDLE,
                                        "AGX2K3K_ATTR_EBURST_IDLE", 500E-9,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrEburstIdleRangeTable, 0));

    /* AGX2K3K_ATTR_EBURST_SLOPE */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_EBURST_SLOPE,
                                       "AGX2K3K_ATTR_EBURST_SLOPE",
                                       AGX2K3K_VAL_POSITIVE,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrEburstSlopeRangeTable));

    /* AGX2K3K_ATTR_RUNT_POLARITY */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_RUNT_POLARITY,
                                       "AGX2K3K_ATTR_RUNT_POLARITY",
                                       AGX2K3K_VAL_POSITIVE,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrRuntPolarityRangeTable));

    /* AGX2K3K_ATTR_RUNT_QUALIFIER */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_RUNT_QUALIFIER,
                                       "AGX2K3K_ATTR_RUNT_QUALIFIER",
                                       AGX2K3K_VAL_RUNT_QUALIFIER_NONE,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrRuntQualifierRangeTable));

    /* AGX2K3K_ATTR_RUNT_TIME */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_RUNT_TIME,
                                        "AGX2K3K_ATTR_RUNT_TIME", 20E-9,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrRuntTimeRangeTable, 0));

    /* AGX2K3K_ATTR_RUNT_HIGH_THRESHOLD */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_RUNT_HIGH_THRESHOLD,
                                        "AGX2K3K_ATTR_RUNT_HIGH_THRESHOLD", 0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrRuntHighThreshold_ReadCallback,
                                        agx2k3kAttrRuntHighThreshold_WriteCallback, VI_NULL, 0));


    /* AGX2K3K_ATTR_RUNT_LOW_THRESHOLD */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_RUNT_LOW_THRESHOLD,
                                        "AGX2K3K_ATTR_RUNT_LOW_THRESHOLD", 0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrRuntLowThreshold_ReadCallback,
                                        agx2k3kAttrRuntLowThreshold_WriteCallback, VI_NULL, 0));

    /* AGX2K3K_ATTR_SETUPHOLD_SLOPE */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SETUPHOLD_SLOPE,
                                       "AGX2K3K_ATTR_SETUPHOLD_SLOPE",
                                       AGX2K3K_VAL_POSITIVE,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrSetupHoldSlopeRangeTable));

    /* AGX2K3K_ATTR_SETUPHOLD_CLKSRC */
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SETUPHOLD_CLKSRC,
                                        "AGX2K3K_ATTR_SETUPHOLD_CLKSRC", "CHAN1",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SETUPHOLD_CLKSRC,
                                                agx2k3kAttrSerialBusSource_CheckCallback));

    /* AGX2K3K_ATTR_SETUPHOLD_DATASRC */
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SETUPHOLD_DATASRC,
                                        "AGX2K3K_ATTR_SETUPHOLD_DATASRC", "CHAN2",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SETUPHOLD_DATASRC,
                                                agx2k3kAttrSetupHoldDataSource_CheckCallback));

    /* AGX2K3K_ATTR_SETUPHOLD_HOLD_TIME */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_SETUPHOLD_HOLD_TIME,
                                        "AGX2K3K_ATTR_SETUPHOLD_HOLD_TIME", 2.0E-9,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrHoldRangeTable, 0));

    /* AGX2K3K_ATTR_SETUPHOLD_SETUP_TIME */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_SETUPHOLD_SETUP_TIME,
                                        "AGX2K3K_ATTR_SETUPHOLD_SETUP_TIME", 2.0E-9,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrSetupRangeTable, 0));

    /* AGX2K3K_ATTR_TRANSITION_QUALIFIER */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRANSITION_QUALIFIER,
                                       "AGX2K3K_ATTR_TRANSITION_QUALIFIER",
                                       AGX2K3K_VAL_TRANSITION_QUALIFIER_GREATER,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrTransitionQualifierRangeTable));

    /* AGX2K3K_ATTR_TRANSITION_SLOPE */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRANSITION_SLOPE,
                                       "AGX2K3K_ATTR_TRANSITION_SLOPE",
                                       AGX2K3K_VAL_POSITIVE,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrTransitionSlopeRangeTable));

    /* AGX2K3K_ATTR_TRANSITION_TIME */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_TRANSITION_TIME,
                                        "AGX2K3K_ATTR_TRANSITION_TIME", 20.0E-9,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrTransitionTimeRangeTable, 0));

    /* AGX2K3K_ATTR_USB_TRIGGER */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_USB_TRIGGER,
                                       "AGX2K3K_ATTR_USB_TRIGGER",
                                       AGX2K3K_VAL_USB_TRIGGER_SOP,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrUSBTriggerRangeTable));

    /* AGX2K3K_ATTR_USB_SPEED */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_USB_SPEED,
                                       "AGX2K3K_ATTR_USB_SPEED",
                                       AGX2K3K_VAL_USB_SPEED_FULL,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrUSBSpeedRangeTable));

    /* AGX2K3K_ATTR_USB_DPLUS */
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_USB_DPLUS,
                                        "AGX2K3K_ATTR_USB_DPLUS", "CHAN1",
                                        IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_USB_DPLUS,
                                                agx2k3kAttrDPlus_CheckCallback));

    /* AGX2K3K_ATTR_USB_DMINUS */
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_USB_DMINUS,
                                        "AGX2K3K_ATTR_USB_DMINUS", "CHAN2",
                                        IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_USB_DMINUS,
                                                agx2k3kAttrUSBDMinus_CheckCallback));


    /*- Serial Bus Sub-system ---------------------------------------------*/
    if (IS_3000_SERIES (modelType) || IS_4000_SERIES (modelType) || IS_6000_SERIES (modelType))
    {
        /* AGX2K3K_ATTR_SBUS_CAN_BAUDRATE */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_CAN_BAUDRATE,
                                           "AGX2K3K_ATTR_SBUS_CAN_BAUDRATE", 1000000,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrCANBaudrateRangeTable));
        checkErr (Ivi_SetAttrCoerceCallbackViInt32 (vi, AGX2K3K_ATTR_SBUS_CAN_BAUDRATE,
                                                    agx2k3kAttrLINBandrate_CoerceCallback));

        /* AGX2K3K_ATTR_SBUS_CAN_SIGNAL */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_CAN_SIGNAL,
                                           "AGX2K3K_ATTR_SBUS_CAN_SIGNAL",
                                           AGX2K3K_VAL_CAN_SIGNAL_RX,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrCANSignalRangeTable));

        /* AGX2K3K_ATTR_SBUS_CAN_TRIGGER */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_CAN_TRIGGER,
                                           "AGX2K3K_ATTR_SBUS_CAN_TRIGGER",
                                           AGX2K3K_VAL_CAN_TRIGGER_SOF,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrCANTriggerRangeTable));

        /* AGX2K3K_ATTR_SBUS_CAN_SOURCE */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_CAN_SOURCE,
                                            "AGX2K3K_ATTR_SBUS_CAN_SOURCE", "",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SBUS_CAN_SOURCE,
                                                    agx2k3kAttrSerialBusSource_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_CAN_DATA */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_CAN_DATA,
                                            "AGX2K3K_ATTR_SBUS_CAN_DATA", "",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                            agx2k3kViQuotedString_ReadCallback,
                                            agx2k3kViQuotedString_WriteCallback));

        /* AGX2K3K_ATTR_SBUS_CAN_DATA_LENGTH */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_CAN_DATA_LENGTH,
                                           "AGX2K3K_ATTR_SBUS_CAN_DATA_LENGTH", 4,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrCANDataLengthRangeTable));

        /* AGX2K3K_ATTR_SBUS_CAN_ID_MODE */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_CAN_ID_MODE,
                                           "AGX2K3K_ATTR_SBUS_CAN_ID_MODE", 4,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrCANIdModeRangeTable));

        /* AGX2K3K_ATTR_SBUS_CAN_ID */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_CAN_ID,
                                            "AGX2K3K_ATTR_SBUS_CAN_ID", "",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                            agx2k3kViQuotedString_ReadCallback,
                                            agx2k3kViQuotedString_WriteCallback));

        /* AGX2K3K_ATTR_SBUS_IIC_SCL */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_IIC_SCL,
                                            "AGX2K3K_ATTR_SBUS_IIC_SCL", "CHAN1",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SBUS_IIC_SCL,
                                                    agx2k3kAttrSerialBusSource_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_IIC_SDA */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_IIC_SDA,
                                            "AGX2K3K_ATTR_SBUS_IIC_SDA", "CHAN2",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SBUS_IIC_SDA,
                                                    agx2k3kAttrIICSda_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_IIC_TYPE */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_IIC_TYPE,
                                           "AGX2K3K_ATTR_SBUS_IIC_TYPE",
                                           AGX2K3K_VAL_IIC_TYPE_START,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrIICTypeRangeTable));

        /* AGX2K3K_ATTR_SBUS_IIC_QUALIFIER */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_IIC_QUALIFIER,
                                           "AGX2K3K_ATTR_SBUS_IIC_QUALIFIER",
                                           AGX2K3K_VAL_IIC_QUALIFIER_EQUAL,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrIICQualifierRangeTable));
        checkErr (Ivi_SetAttrCheckCallbackViInt32 (vi, AGX2K3K_ATTR_SBUS_IIC_QUALIFIER,
                                                   agx2k3kAttrIICQualifier_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_IIC_ADDRESS */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_IIC_ADDRESS,
                                           "AGX2K3K_ATTR_SBUS_IIC_ADDRESS", -1,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback, VI_NULL));
        checkErr (Ivi_SetAttrCheckCallbackViInt32 (vi, AGX2K3K_ATTR_SBUS_IIC_ADDRESS,
                                                   agx2k3kAttrIICAddress_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_IIC_DATA */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_IIC_DATA,
                                           "AGX2K3K_ATTR_SBUS_IIC_DATA", -1,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrIICDataRangeTable));

        /* AGX2K3K_ATTR_SBUS_IIC_DATA2 */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_IIC_DATA2,
                                           "AGX2K3K_ATTR_SBUS_IIC_DATA2", -1,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrIICDataRangeTable));

        /* AGX2K3K_ATTR_SBUS_I2S_ALIGNMENT */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_I2S_ALIGNMENT,
                                           "AGX2K3K_ATTR_SBUS_I2S_ALIGNMENT",
                                           AGX2K3K_VAL_I2S_ALIGNMENT_I2S,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrI2SAlignmentRangeTable));

        /* AGX2K3K_ATTR_SBUS_I2S_CLOCK_SLOPE */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_I2S_CLOCK_SLOPE,
                                           "AGX2K3K_ATTR_SBUS_I2S_CLOCK_SLOPE",
                                           AGX2K3K_VAL_I2S_CLOCK_SLOPE_NEGATIVE,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrI2SClockSlopeRangeTable));

        /* AGX2K3K_ATTR_SBUS_I2S_RECEIVER_WIDTH */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_I2S_RECEIVER_WIDTH,
                                           "AGX2K3K_ATTR_SBUS_I2S_RECEIVER_WIDTH", 8,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrI2SRxTxWidthRangeTable));

        /* AGX2K3K_ATTR_SBUS_I2S_TRANSMIT_WIDTH */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_I2S_TRANSMIT_WIDTH,
                                           "AGX2K3K_ATTR_SBUS_I2S_TRANSMIT_WIDTH", 8,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrI2SRxTxWidthRangeTable));

        /* AGX2K3K_ATTR_SBUS_I2S_SOURCE_CLOCK */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_I2S_SOURCE_CLOCK,
                                            "AGX2K3K_ATTR_SBUS_I2S_SOURCE_CLOCK",
                                            "CHAN1",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SBUS_I2S_SOURCE_CLOCK,
                                                    agx2k3kAttrSerialBusSource_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_I2S_SOURCE_DATA */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_I2S_SOURCE_DATA,
                                            "AGX2K3K_ATTR_SBUS_I2S_SOURCE_DATA", "CHAN3",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SBUS_I2S_SOURCE_DATA,
                                                    agx2k3kAttrI2SDataSource_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_I2S_SOURCE_WS */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_I2S_SOURCE_WS,
                                            "AGX2K3K_ATTR_SBUS_I2S_SOURCE_WS", "CHAN2",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SBUS_I2S_SOURCE_WS,
                                                    agx2k3kAttrI2SWSSource_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_I2S_TRIGGER */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_I2S_TRIGGER,
                                           "AGX2K3K_ATTR_SBUS_I2S_TRIGGER",
                                           AGX2K3K_VAL_I2S_TRIGGER_EQUAL,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrI2STriggerRangeTable));

        /* AGX2K3K_ATTR_SBUS_I2S_TRIGGER_AUDIO */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_I2S_TRIGGER_AUDIO,
                                           "AGX2K3K_ATTR_SBUS_I2S_TRIGGER_AUDIO",
                                           AGX2K3K_VAL_IIC_SIZE_BIT7,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrI2STriggerAudioRangeTable));

        /* AGX2K3K_ATTR_SBUS_I2S_TRIGGER_DATA */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_I2S_TRIGGER_DATA,
                                            "AGX2K3K_ATTR_SBUS_I2S_TRIGGER_DATA",
                                            "\"0\"",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kAttrI2STriggerData_WriteCallback));

        /* AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW,
                                           "AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW",
                                           -10,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kAttrI2STriggerRange_ReadCallback,
                                           agx2k3kAttrI2STriggerRange_WriteCallback,
                                           VI_NULL));
        checkErr (Ivi_SetAttrCheckCallbackViInt32 (vi, AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW,
                                                   agx2k3kAttrI2STriggerRange_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH,
                                           "AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH",
                                           10,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kAttrI2STriggerRange_ReadCallback,
                                           agx2k3kAttrI2STriggerRange_WriteCallback,
                                           VI_NULL));
        checkErr (Ivi_SetAttrCheckCallbackViInt32 (vi, AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH,
                                                   agx2k3kAttrI2STriggerRange_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_I2S_WS_LOW */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_I2S_WS_LOW,
                                           "AGX2K3K_ATTR_SBUS_I2S_WS_LOW",
                                           AGX2K3K_VAL_I2S_WS_LOW_LEFT,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrI2SWSLowRangeTable));

        /* AGX2K3K_ATTR_SBUS_UART_BAUDRATE */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_BAUDRATE,
                                           "AGX2K3K_ATTR_SBUS_UART_BAUDRATE", 19200,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrUARTBaudrateRangeTable));
        checkErr (Ivi_SetAttrCoerceCallbackViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_BAUDRATE,
                                                    agx2k3kAttrLINBandrate_CoerceCallback));

        /* AGX2K3K_ATTR_SBUS_UART_BIT_ORDER */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_BIT_ORDER,
                                           "AGX2K3K_ATTR_SBUS_UART_BIT_ORDER",
                                           AGX2K3K_VAL_UART_BIT_ORDER_LSB_FIRST,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrUARTBitOrderRangeTable));

        /* AGX2K3K_ATTR_SBUS_UART_COUNT_RESET */
        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_SBUS_UART_COUNT_RESET,
                                             "AGX2K3K_ATTR_SBUS_UART_COUNT_RESET",
                                             VI_FALSE,
                                             IVI_VAL_NOT_USER_READABLE | IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                             VI_NULL,
                                             agx2k3kAttrUARTCountReset_WriteCallback));

        /* AGX2K3K_ATTR_SBUS_UART_COUNT_ERROR */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_COUNT_ERROR,
                                           "AGX2K3K_ATTR_SBUS_UART_COUNT_ERROR", 0,
                                           IVI_VAL_NOT_USER_WRITABLE | IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback, VI_NULL, VI_NULL));

        /* AGX2K3K_ATTR_SBUS_UART_COUNT_TX */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_COUNT_TX,
                                           "AGX2K3K_ATTR_SBUS_UART_COUNT_TX", 0,
                                           IVI_VAL_NOT_USER_WRITABLE | IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback, VI_NULL, VI_NULL));

        /* AGX2K3K_ATTR_SBUS_UART_COUNT_RX */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_COUNT_RX,
                                           "AGX2K3K_ATTR_SBUS_UART_COUNT_RX", 0,
                                           IVI_VAL_NOT_USER_WRITABLE | IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback, VI_NULL, VI_NULL));

        /* AGX2K3K_ATTR_SBUS_UART_FRAMING */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_FRAMING,
                                           "AGX2K3K_ATTR_SBUS_UART_FRAMING", -1,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kAttrUARTFraming_ReadCallback,
                                           agx2k3kAttrUARTFraming_WriteCallback,
                                           &attrUARTFramingRangeTable));

        /* AGX2K3K_ATTR_SBUS_UART_PARITY */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_PARITY,
                                           "AGX2K3K_ATTR_SBUS_UART_PARITY",
                                           AGX2K3K_VAL_UART_PARITY_EVEN,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrUARTParityRangeTable));

        /* AGX2K3K_ATTR_SBUS_UART_POLARITY */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_POLARITY,
                                           "AGX2K3K_ATTR_SBUS_UART_POLARITY",
                                           AGX2K3K_VAL_UART_POLARITY_HIGH,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrUARTPolarityRangeTable));

        /* AGX2K3K_ATTR_SBUS_UART_SOURCE_RX */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_UART_SOURCE_RX,
                                            "AGX2K3K_ATTR_SBUS_UART_SOURCE_RX", "CHAN1",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SBUS_UART_SOURCE_RX,
                                                    agx2k3kAttrSerialBusSource_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_UART_SOURCE_TX */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_UART_SOURCE_TX,
                                            "AGX2K3K_ATTR_SBUS_UART_SOURCE_TX", "CHAN2",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SBUS_UART_SOURCE_TX,
                                                    agx2k3kAttrUARTSourceTx_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_UART_TRIGGER_BURST */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_TRIGGER_BURST,
                                           "AGX2K3K_ATTR_SBUS_UART_TRIGGER_BURST", -1,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kAttrUARTTriggerBurst_ReadCallback,
                                           agx2k3kAttrUARTTriggerBurst_WriteCallback,
                                           &attrUARTTriggerBurstRangeTable));
        checkErr (Ivi_SetAttrCheckCallbackViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_TRIGGER_BURST,
                                                   agx2k3kAttrUARTTriggerBurst_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_UART_TRIGGER_DATA */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_TRIGGER_DATA,
                                           "AGX2K3K_ATTR_SBUS_UART_TRIGGER_DATA", 0,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrUARTTriggerDataRangeTable));

        /* AGX2K3K_ATTR_SBUS_UART_TRIGGER_IDLE */
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_SBUS_UART_TRIGGER_IDLE,
                                            "AGX2K3K_ATTR_SBUS_UART_TRIGGER_IDLE", 5E-3,
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback,
                                            &attrUARTTriggerIdleRangeTable, 0));

        /* AGX2K3K_ATTR_SBUS_UART_TRIGGER_QUALIFIER */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_TRIGGER_QUALIFIER,
                                           "AGX2K3K_ATTR_SBUS_UART_TRIGGER_QUALIFIER",
                                           AGX2K3K_VAL_UART_TRIGGER_QUALIFIER_EQUAL,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrUARTQualifierRangeTable));

        /* AGX2K3K_ATTR_SBUS_UART_TRIGGER_TYPE */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_TRIGGER_TYPE,
                                           "AGX2K3K_ATTR_SBUS_UART_TRIGGER_TYPE",
                                           AGX2K3K_VAL_UART_TRIGGER_RSTART,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrUARTTriggerTypeRangeTable));

        /* AGX2K3K_ATTR_SBUS_UART_WIDTH */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_UART_WIDTH,
                                           "AGX2K3K_ATTR_SBUS_UART_WIDTH", 8,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrUARTWidthRangeTable));

        /* AGX2K3K_ATTR_SBUS_IIC_SIZE */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_IIC_SIZE,
                                           "AGX2K3K_ATTR_SBUS_IIC_SIZE",
                                           AGX2K3K_VAL_IIC_SIZE_BIT7,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrIICSizeRangeTable));

        /* AGX2K3K_ATTR_SBUS_LIN_BAUDRATE */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_LIN_BAUDRATE,
                                           "AGX2K3K_ATTR_SBUS_LIN_BAUDRATE", 2400,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrLINBaudrateRangeTable));
        checkErr (Ivi_SetAttrCoerceCallbackViInt32 (vi, AGX2K3K_ATTR_SBUS_LIN_BAUDRATE,
                                                    agx2k3kAttrLINBandrate_CoerceCallback));

        /* AGX2K3K_ATTR_SBUS_LIN_TRIGGER */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_LIN_TRIGGER,
                                           "AGX2K3K_ATTR_SBUS_LIN_TRIGGER",
                                           AGX2K3K_VAL_LIN_TRIGGER_SYNCBREAK,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrLINTriggerRangeTable));

        /* AGX2K3K_ATTR_SBUS_LIN_SOURCE */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_LIN_SOURCE,
                                            "AGX2K3K_ATTR_SBUS_LIN_SOURCE", "CHAN1",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SBUS_LIN_SOURCE,
                                                    agx2k3kAttrSerialBusSource_CheckCallback));

        /* AGX2K3K_ATTR_SBUS_LIN_PARITY */
        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_SBUS_LIN_PARITY,
                                             "AGX2K3K_ATTR_SBUS_LIN_PARITY", VI_FALSE,
                                             IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                             agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));

        /* AGX2K3K_ATTR_SBUS_LIN_STANDARD */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_LIN_STANDARD,
                                           "AGX2K3K_ATTR_SBUS_LIN_STANDARD",
                                           AGX2K3K_VAL_LIN_STANDARD_LIN13,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrLINStandardRangeTable));

        /* AGX2K3K_ATTR_SBUS_LIN_SYNC_BREAK */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_LIN_SYNC_BREAK,
                                           "AGX2K3K_ATTR_SBUS_LIN_SYNC_BREAK",
                                           AGX2K3K_VAL_LIN_SYNC_BREAK_11_CLOCK,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrLINSyncBreakRangeTable));

        /* AGX2K3K_ATTR_SBUS_LIN_TRIGGER_ID */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_LIN_TRIGGER_ID,
                                           "AGX2K3K_ATTR_SBUS_LIN_TRIGGER_ID", 0,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrLINTriggerIdRangeTable));

        /* AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA,
                                            "AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA", "$",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                            agx2k3kAttrLINTriggerData_ReadCallback,
                                            agx2k3kAttrLINTriggerData_WriteCallback));

        /* AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA_LENGTH */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA_LENGTH,
                                           "AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA_LENGTH",
                                           4,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrLINDataLengthRangeTable));

        /* AGX2K3K_ATTR_SBUS_SPI_MISO_WIDTH */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SPI_MISO_WIDTH,
                                           "AGX2K3K_ATTR_SBUS_SPI_MISO_WIDTH", 4,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSPIMxsxWidthRangeTable));

        /* AGX2K3K_ATTR_SBUS_SPI_MOSI_WIDTH */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SPI_MOSI_WIDTH,
                                           "AGX2K3K_ATTR_SBUS_SPI_MOSI_WIDTH", 4,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSPIMxsxWidthRangeTable));

        /* AGX2K3K_ATTR_SBUS_SPI_WORD_WIDTH */
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SPI_WORD_WIDTH,
                                           "AGX2K3K_ATTR_SBUS_SPI_WORD_WIDTH", 4,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSPIWordWidthRangeTable));

        /* AGX2K3K_ATTR_SBUS_SPI_MISO_DATA */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_SPI_MISO_DATA,
                                            "AGX2K3K_ATTR_SBUS_SPI_MISO_DATA",
                                            "\"XXXXXXXX\"",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));

        /* AGX2K3K_ATTR_SBUS_SPI_MOSI_DATA */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_SPI_MOSI_DATA,
                                            "AGX2K3K_ATTR_SBUS_SPI_MOSI_DATA",
                                            "\"XXXXXXXX\"",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));

        /* AGX2K3K_ATTR_SBUS_SPI_CLKSOURCE */
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_SPI_CLKSOURCE,
                                            "AGX2K3K_ATTR_SBUS_SPI_CLKSOURCE", "CHAN3",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SBUS_SPI_CLKSOURCE,
                                                    agx2k3kAttrSerialBusSource_CheckCallback));

        /*- AGX2K3K_ATTR_SBUS_SPI_DSOURCE -*/
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_SPI_DSOURCE,
                                            "AGX2K3K_ATTR_SBUS_SPI_DSOURCE", "CHAN2",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SBUS_SPI_DSOURCE,
                                                    agx2k3kAttrSPIDataSource_CheckCallback));

        /*- AGX2K3K_ATTR_SBUS_SPI_FSOURCE -*/
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_SPI_FSOURCE,
                                            "AGX2K3K_ATTR_SBUS_SPI_FSOURCE", "CHAN1",
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SBUS_SPI_FSOURCE,
                                                    agx2k3kAttrSPIFrameSource_CheckCallback));

        /*- AGX2K3K_ATTR_SBUS_SPI_TRIGGER_TYPE -*/
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SPI_TRIGGER_TYPE,
                                           "AGX2K3K_ATTR_SBUS_SPI_TRIGGER_TYPE",
                                           AGX2K3K_VAL_SPI_SLOPE_POSITIVE,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSPITriggerTypeRangeTable));

        /*- AGX2K3K_ATTR_SBUS_SPI_FRAME -*/
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SPI_FRAME,
                                           "AGX2K3K_ATTR_SBUS_SPI_FRAME",
                                           AGX2K3K_VAL_SPI_FRAME_NCHIP,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSPIFrameRangeTable));

        /*- AGX2K3K_ATTR_SBUS_SPI_SLOPE -*/
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SPI_SLOPE,
                                           "AGX2K3K_ATTR_SBUS_SPI_SLOPE",
                                           AGX2K3K_VAL_SPI_SLOPE_POSITIVE,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSPISlopeRangeTable));

        /*- AGX2K3K_ATTR_SBUS_SPI_TIMEOUT -*/
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_SBUS_SPI_TIMEOUT,
                                            "AGX2K3K_ATTR_SBUS_SPI_TIMEOUT", 10.0e-6,
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback,
                                            &attrSPITimeoutRangeTable, 0));

        /*- AGX2K3K_ATTR_SBUS_SPI_BIT_ORDER -*/
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SPI_BIT_ORDER,
                                           "AGX2K3K_ATTR_SBUS_SPI_BIT_ORDER",
                                           AGX2K3K_VAL_SPI_BITORDER_MSB_FIRST,
                                           IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSPIBitOrderRangeTable));

        /*- 3KT X-Series and  4K X-Series -*/

        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_CHANNEL_PROBE_TEK_MODEL,
                                           "AGX2K3K_ATTR_CHANNEL_PROBE_TEK_MODEL",
                                           AGX2K3K_VAL_CHANNEL_PROBE_TEK_MODEL_P5205,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrChannelProbeTekModelRangeTable));
        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_COUNTER_ENABLE,
                                             "AGX2K3K_ATTR_COUNTER_ENABLE", VI_FALSE, 0,
                                             agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_COUNTER_MODE,
                                           "AGX2K3K_ATTR_COUNTER_MODE",
                                           AGX2K3K_VAL_COUNTER_MODE_FREQUENCY, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrCounterModeRangeTable_3KT));
        checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_COUNTER_MODE,
                                                 agx2k3kAttrCounterMode_RangeTableCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_COUNTER_NUMBER_OF_DIGITS,
                                           "AGX2K3K_ATTR_COUNTER_NUMBER_OF_DIGITS", 5, 0,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrCounterNumberOfDigitsRangeTable));

        checkErr (Ivi_AddAttributeViBoolean (vi,
                                             AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_ENABLED,
                                             "AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_ENABLED",
                                             VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_POLARITY,
                                           "AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_POLARITY",
                                           AGX2K3K_VAL_COUNTER_TOTALIZER_EDGES_POSITIVE,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrCounterTotalizerEdgesRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_COUNTER_TOTALIZE_SLOPE,
                                           "AGX2K3K_ATTR_COUNTER_TOTALIZE_SLOPE",
                                           AGX2K3K_VAL_COUNTER_TOTALIZER_EDGES_POSITIVE,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrCounterTotalizerEdgesRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FFT_AVERAGE_COUNT,
                                           "AGX2K3K_ATTR_FFT_AVERAGE_COUNT", 8, 0,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrFFTAverageCountRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FFT_FREQUENCY_CENTER,
                                            "AGX2K3K_ATTR_FFT_FREQUENCY_CENTER", 50E+3,
                                            0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback,
                                            &attrFFTFrequencyCenterRangeTable, 0));
        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_FFT_DISPLAY_ENABLED,
                                             "AGX2K3K_ATTR_FFT_DISPLAY_ENABLED",
                                             VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FFT_DISPLAY_MODE,
                                           "AGX2K3K_ATTR_FFT_DISPLAY_MODE",
                                           AGX2K3K_VAL_FFT_DISPLAY_MODE_NORMAL, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrFFTDisplayModeRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FFT_FREQUENCY_START,
                                            "AGX2K3K_ATTR_FFT_FREQUENCY_START", 0.0E+00,
                                            0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FFT_FREQUENCY_STOP,
                                            "AGX2K3K_ATTR_FFT_FREQUENCY_STOP",
                                            100.0000E+03, 0,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FFT_VERTICAL_OFFSET,
                                            "AGX2K3K_ATTR_FFT_VERTICAL_OFFSET",
                                            -60.0000E+00, 0,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FFT_VERTICAL_RANGE,
                                            "AGX2K3K_ATTR_FFT_VERTICAL_RANGE", 160E+00,
                                            0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FFT_VERTICAL_REFERENCE,
                                            "AGX2K3K_ATTR_FFT_VERTICAL_REFERENCE",
                                            -60.0000E+00, 0,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FFT_VERTICAL_SCALE,
                                            "AGX2K3K_ATTR_FFT_VERTICAL_SCALE", 20.0E+00,
                                            0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FFT_SOURCE1,
                                           "AGX2K3K_ATTR_FFT_SOURCE1",
                                           AGX2K3K_VAL_FFT_SOURCE_CHANNEL1, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrFFTSourceRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FFT_FREQUENCY_SPAN,
                                            "AGX2K3K_ATTR_FFT_FREQUENCY_SPAN",
                                            100.0000E+03, 0,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback,
                                            &attrFFTFrequencySpanRangeTable, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FFT_VERTICAL_UNIT,
                                           "AGX2K3K_ATTR_FFT_VERTICAL_UNIT",
                                           AGX2K3K_VAL_FFT_VERTICAL_UNIT_DECIBEL, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrFFTVerticalUnitRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FFT_WINDOW,
                                           "AGX2K3K_ATTR_FFT_WINDOW",
                                           AGX2K3K_VAL_FFT_WINDOW_RECTANGULAR, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrFFTWindowRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_MATH_SMOOTH_POINTS,
                                           "AGX2K3K_ATTR_MATH_SMOOTH_POINTS", 5,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback, VI_NULL));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MATH_FFT_FREQUENCY_START,
                                            "AGX2K3K_ATTR_MATH_FFT_FREQUENCY_START",
                                            0.0E+00, IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MATH_FFT_FREQUENCY_STOP,
                                            "AGX2K3K_ATTR_MATH_FFT_FREQUENCY_STOP",
                                            100.0000E+03, IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_POWER_CLRESPONSE_FREQUENCY_START,
                                           "AGX2K3K_ATTR_POWER_CLRESPONSE_FREQUENCY_START",
                                           1.000E+03, 0, agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrPowerCLResponseFrequencyStartRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_POWER_CLRESPONSE_FREQUENCY_STOP,
                                           "AGX2K3K_ATTR_POWER_CLRESPONSE_FREQUENCY_STOP",
                                           20.000000E+06, 0, agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrPowerCLResponseFrequencyStopRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_CLRESPONSE_YMAXIMUM,
                                           "AGX2K3K_ATTR_POWER_CLRESPONSE_YMAXIMUM",
                                           60E+00, 0, agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrPowerCLResponseYMaximumRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_CLRESPONSE_YMINIMUM,
                                           "AGX2K3K_ATTR_POWER_CLRESPONSE_YMINIMUM",
                                           -60E+00, 0, agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrPowerCLResponseYMinmumRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_EFFICIENCY_TYPE,
                                           "AGX2K3K_ATTR_POWER_EFFICIENCY_TYPE",
                                           AGX2K3K_VAL_POWER_EFFICIENCY_TYPE_ACDC, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrPowerEfficiencyTypeRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_POWER_HARMONICS_REAL_POWER_TYPE,
                                           "AGX2K3K_ATTR_POWER_HARMONICS_REAL_POWER_TYPE",
                                           AGX2K3K_VAL_POWER_HARMONICS_REAL_POWER_SOURCE_MEASURED,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrPowerHarmonicsRealPowerTypeRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_POWER_HARMONICS_REAL_POWER_VALUE,
                                            "AGX2K3K_ATTR_POWER_HARMONICS_REAL_POWER_VALUE",
                                            70.0E+00, 0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback,
                                            &attrPowerHarmonicsRealPowerValueRangeTable,
                                            0));
        checkErr (Ivi_AddAttributeViBoolean (vi,
                                             AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_CURSOR_ENABLED,
                                             "AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_CURSOR_ENABLED",
                                             VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViBoolean (vi,
                                             AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_MASK_ENABLED,
                                             "AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_MASK_ENABLED",
                                             VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViBoolean (vi,
                                             AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_MEASUREMENT_ENABLED,
                                             "AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_MEASUREMENT_ENABLED",
                                             VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViBoolean (vi,
                                             AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_SEARCH_ENABLED,
                                             "AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_SEARCH_ENABLED",
                                             VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViBoolean (vi,
                                             AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_SEGMENTED_ENABLED,
                                             "AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_SEGMENTED_ENABLED",
                                             VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_CAN_DISPLAY,
                                           "AGX2K3K_ATTR_SBUS_CAN_DISPLAY",
                                           AGX2K3K_VAL_SBUS_CAN_DISPLAY_TYPE_HEXADECIMAL,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSBusCANDisplayTypeRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_SBUS_CAN_FD_SAMPLE_POINT,
                                            "AGX2K3K_ATTR_SBUS_CAN_FD_SAMPLE_POINT",
                                            50.0E+00, IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback,
                                            &attrSBusCANFDSamplePointRangeTable, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_CAN_SIGNAL_FD_BAUDRATE,
                                           "AGX2K3K_ATTR_SBUS_CAN_SIGNAL_FD_BAUDRATE",
                                           5000000, IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSBusCANSignalFDBaudrateRangeTable));
        checkErr (Ivi_AddAttributeViBoolean (vi,
                                             AGX2K3K_ATTR_SBUS_CAN_TRIGGER_IDFILTER_ENABLED,
                                             "AGX2K3K_ATTR_SBUS_CAN_TRIGGER_IDFILTER_ENABLED",
                                             VI_FALSE, IVI_VAL_MULTI_CHANNEL,
                                             agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_SBUS_CAN_TRIGGER_PATTERN_DATA_DLC,
                                           "AGX2K3K_ATTR_SBUS_CAN_TRIGGER_PATTERN_DATA_DLC",
                                           -1, IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSBusCANTriggerPatternDataDlcRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_SBUS_CAN_TRIGGER_PATTERN_DATA_START,
                                           "AGX2K3K_ATTR_SBUS_CAN_TRIGGER_PATTERN_DATA_START",
                                           0, IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSBusCANTriggerPatternDataStartRangeTable));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_MESSAGE,
                                            "AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_MESSAGE",
                                            "", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViQuotedString_ReadCallback,
                                            agx2k3kViQuotedString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_SIGNAL,
                                            "AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_SIGNAL",
                                            "", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViQuotedString_ReadCallback,
                                            agx2k3kViQuotedString_WriteCallback));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_VALUE,
                                            "AGX2K3K_ATTR_SBUS_CAN_TRIGGER_SYMBOLIC_VALUE",
                                            0, IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_LIN_DISPLAY,
                                           "AGX2K3K_ATTR_SBUS_LIN_DISPLAY",
                                           AGX2K3K_VAL_SBUS_LIN_DISPLAY_TYPE_HEXADECIMAL,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSBusLINDisplayTypeRangeTable));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_FRAME,
                                            "AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_FRAME",
                                            "", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViQuotedString_ReadCallback,
                                            agx2k3kViQuotedString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_SIGNAL,
                                            "AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_SIGNAL",
                                            "", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViQuotedString_ReadCallback,
                                            agx2k3kViQuotedString_WriteCallback));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_VALUE,
                                            "AGX2K3K_ATTR_SBUS_LIN_TRIGGER_SYMBOLIC_VALUE",
                                            0, IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_SBUS_SENT_CLOCK,
                                            "AGX2K3K_ATTR_SBUS_SENT_CLOCK", 300.00E-06,
                                            IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback,
                                            &attrSBusSENTClockPeriodRangeTable, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_CRC,
                                           "AGX2K3K_ATTR_SBUS_SENT_CRC",
                                           AGX2K3K_VAL_SBUS_SENT_CRC_RECOMMENDED,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSBusSENTCRCFormatRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_DISPLAY,
                                           "AGX2K3K_ATTR_SBUS_SENT_DISPLAY",
                                           AGX2K3K_VAL_SBUS_SENT_DISPLAY_BASE_HEX,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSBusSENTDisplayBaseRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_FORMAT,
                                           "AGX2K3K_ATTR_SBUS_SENT_FORMAT",
                                           AGX2K3K_VAL_SBUS_SENT_MESSAGE_FORMAT_NIBBLES,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSBusSENTMessageFormatRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_IDLE,
                                           "AGX2K3K_ATTR_SBUS_SENT_IDLE",
                                           AGX2K3K_VAL_SBUS_SENT_IDLE_STATE_HIGH,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSBusSENTIdleStateRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_LENGTH,
                                           "AGX2K3K_ATTR_SBUS_SENT_LENGTH", 6,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSBusSENTLengthNibblesRangeTable));
        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_SBUS_SENT_PPULSE_ENABLED,
                                             "AGX2K3K_ATTR_SBUS_SENT_PPULSE_ENABLED",
                                             VI_FALSE, IVI_VAL_MULTI_CHANNEL,
                                             agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                            "AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME",
                                            "SIGN1", 0, VI_NULL, VI_NULL));
        checkErr (Ivi_AddAttributeViBoolean (vi,
                                             AGX2K3K_ATTR_SBUS_SENT_SIGNAL_DISPLAY_ENABLED,
                                             "AGX2K3K_ATTR_SBUS_SENT_SIGNAL_DISPLAY_ENABLED",
                                             VI_FALSE, IVI_VAL_MULTI_CHANNEL,
                                             agx2k3kAttrSbusSentSignalsDisplayEnabled_ReadCallback,
                                             agx2k3kAttrSbusSentSignalsDisplayEnabled_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_LENGTH,
                                           "AGX2K3K_ATTR_SBUS_SENT_SIGNAL_LENGTH", 1,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kAttrSbusSentSignalsLength_ReadCallback,
                                           agx2k3kAttrSbusSentSignalsLength_WriteCallback,
                                           &attrSBusSENTSignalLengthRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_MULTIPLIER,
                                            "AGX2K3K_ATTR_SBUS_SENT_SIGNAL_MULTIPLIER",
                                            1.00000000E+000, IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kAttrSbusSentSignalsMultiplier_ReadCallback,
                                            agx2k3kAttrSbusSentSignalsMultiplier_WriteCallback,
                                            &attrSBusSENTSignalMultiplierRangeTable, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_OFFSET,
                                            "AGX2K3K_ATTR_SBUS_SENT_SIGNAL_OFFSET",
                                            1.0E+000, IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kAttrSbusSentSignalsOffset_ReadCallback,
                                            agx2k3kAttrSbusSentSignalsOffset_WriteCallback,
                                            &attrSBusSENTSignalMultiplierRangeTable, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_ORDER,
                                           "AGX2K3K_ATTR_SBUS_SENT_SIGNAL_ORDER",
                                           AGX2K3K_VAL_SBUS_SENT_SIGNAL_ORDER_MSNFIRST,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kAttrSbusSentSignalsOrder_ReadCallback,
                                           agx2k3kAttrSbusSentSignalsOrder_WriteCallback,
                                           &attrSBusSENTSignalOrderRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_START,
                                           "AGX2K3K_ATTR_SBUS_SENT_SIGNAL_START", 0,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kAttrSbusSentSignalsStart_ReadCallback,
                                           agx2k3kAttrSbusSentSignalsStart_WriteCallback,
                                           &attrSBusSENTSignalStartRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_TOLERANCE,
                                           "AGX2K3K_ATTR_SBUS_SENT_TRIGGER_TOLERANCE",
                                           15, IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSBusSENTTriggerTolerancePercentRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_LENGTH,
                                           "AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_LENGTH",
                                           AGX2K3K_VAL_SBUS_SENT_TRIGGER_SLOW_LENGTH_SHORT,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSBusSENTTriggerSlowLengthRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_TRIGGER,
                                           "AGX2K3K_ATTR_SBUS_SENT_TRIGGER",
                                           AGX2K3K_VAL_SBUS_SENT_TRIGGER_MODE_SFCMESSAGE,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSBusSENTTriggerModeRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_TOLERANCE,
                                           "AGX2K3K_ATTR_SBUS_SENT_TOLERANCE", 20,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSBusSENTTolerancePercentRangeTable));

        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_FAST_DATA,
                                            "AGX2K3K_ATTR_SBUS_SENT_TRIGGER_FAST_DATA",
                                            "XXXXXXXXXXXXXXXXXXXXXXXXXXXX",
                                            IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViQuotedString_ReadCallback,
                                            agx2k3kViQuotedString_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_DATA,
                                           "AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_DATA",
                                           -1, IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSBusSENTTriggerSlowDataShortRangeTable));
        checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_DATA,
                                                 agx2k3kAttrSBusSENTTriggerSLOWData_RangeTableCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_ID,
                                           "AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_ID", -1,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSBusSENTTriggerSlowIDShortRangeTable));
        checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_SBUS_SENT_TRIGGER_SLOW_ID,
                                                 agx2k3kAttrSBusSENTTriggerSLOWID_RangeTableCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_EVENT,
                                           "AGX2K3K_ATTR_SEARCH_EVENT", 0, 0,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback, VI_NULL));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_SEARCH_PEAK_EXCURSION,
                                            "AGX2K3K_ATTR_SEARCH_PEAK_EXCURSION",
                                            20.0E+00, 0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_PEAK_MAXIMUM_PEAKS,
                                           "AGX2K3K_ATTR_SEARCH_PEAK_MAXIMUM_PEAKS", 4,
                                           0, agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSearchPeakNumberOfPeaksRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_SEARCH_PEAK_THRESHOLD,
                                            "AGX2K3K_ATTR_SEARCH_PEAK_THRESHOLD",
                                            -20.0E+00, 0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_MESSAGE,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_MESSAGE",
                                            "", 0, agx2k3kViQuotedString_ReadCallback,
                                            agx2k3kViQuotedString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_SIGNAL,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_SIGNAL",
                                            "", 0, agx2k3kViQuotedString_ReadCallback,
                                            agx2k3kViQuotedString_WriteCallback));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_VALUE,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_CAN_SYMBOLIC_VALUE",
                                            0, 0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_FRAME,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_FRAME",
                                            "", 0, agx2k3kViQuotedString_ReadCallback,
                                            agx2k3kViQuotedString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_SIGNAL,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_SIGNAL",
                                            "", 0, agx2k3kViQuotedString_ReadCallback,
                                            agx2k3kViQuotedString_WriteCallback));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_VALUE,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_LIN_SYMBOLIC_VALUE",
                                            0, 0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_SERIAL_SENT_MODE,
                                           "AGX2K3K_ATTR_SEARCH_SERIAL_SENT_MODE",
                                           AGX2K3K_VAL_SEARCH_SERIAL_SENT_MODE_FCDATA, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSearchSerialSentModeRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_SERIAL_SENT_SLOW_DATA,
                                           "AGX2K3K_ATTR_SEARCH_SERIAL_SENT_SLOW_DATA",
                                           -1, 0, agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSearchSerialSentSlowDataRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_SERIAL_SENT_SLOW_ID,
                                           "AGX2K3K_ATTR_SEARCH_SERIAL_SENT_SLOW_ID", -1,
                                           0, agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSearchSerialSentSlowIDRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_PEAK_SOURCE,
                                           "AGX2K3K_ATTR_SEARCH_PEAK_SOURCE",
                                           AGX2K3K_VAL_SEARCH_PEAK_SOURCE_NONE, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSearchPeakSourceRangeTable));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_SENT_FAST_DATA,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_SENT_FAST_DATA",
                                            "0xXXXXXX", 0,
                                            agx2k3kViQuotedString_ReadCallback,
                                            agx2k3kViQuotedString_WriteCallback));

        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_TRIGGER_ZONE_STATE_ENABLED,
                                             "AGX2K3K_ATTR_TRIGGER_ZONE_STATE_ENABLED",
                                             VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));

        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_ZONE_MODE,
                                           "AGX2K3K_ATTR_TRIGGER_ZONE_MODE",
                                           AGX2K3K_VAL_TRIGGER_ZONE_MODE_INTERSECT,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrTriggerZoneModeRangeTable));

        checkErr (Ivi_AddAttributeViBoolean (vi,
                                             AGX2K3K_ATTR_MULTICHANNEL_TRIGGER_ZONE_STATE_ENABLED,
                                             "AGX2K3K_ATTR_MULTICHANNEL_TRIGGER_ZONE_STATE_ENABLED",
                                             VI_FALSE, IVI_VAL_MULTI_CHANNEL,
                                             agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));

        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_WAVEGEN_OUTPUT_MODE,
                                           "AGX2K3K_ATTR_WAVEGEN_OUTPUT_MODE",
                                           AGX2K3K_VAL_WAVEGEN_OUTPUT_MODE_NORMAL,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrWaveGenOutputModeRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_WAVEGEN_TRACK_PHASE,
                                           "AGX2K3K_ATTR_WAVEGEN_TRACK_PHASE", 0,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrWaveGenTracePhaseRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_COMPLIANCE_USB_HUBS,
                                           "AGX2K3K_ATTR_COMPLIANCE_USB_HUBS", 0, 0,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrComplianceUSBHubsNumberRangeTable));

        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE,
                                           "AGX2K3K_ATTR_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE",
                                           AGX2K3K_VAL_COMPLIANCE_USB_SIGNAL_QUALITY_TYPE_DLSS,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrComplianceUSBSignalQualityTypeRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_COMPLIANCE_USB_TEST_CONNECTION,
                                           "AGX2K3K_ATTR_COMPLIANCE_USB_TEST_CONNECTION",
                                           AGX2K3K_VAL_COMPLIANCE_USB_TEST_CONNECTION_DIFFERENTIAL,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrComplianceUSBTestConnectionRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_COMPLIANCE_USB_TEST_TYPE,
                                           "AGX2K3K_ATTR_COMPLIANCE_USB_TEST_TYPE",
                                           AGX2K3K_VAL_COMPLIANCE_USB_TEST_TYPE_NEAREND,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrComplianceUSBTestTypeRangeTable));
        checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                                AGX2K3K_ATTR_SBUS_SENT_SIGNAL_DISPLAY_ENABLED,
                                                VI_FALSE));
        checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                                AGX2K3K_ATTR_SBUS_SENT_SIGNAL_LENGTH,
                                                VI_FALSE));
        checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                                AGX2K3K_ATTR_SBUS_SENT_SIGNAL_MULTIPLIER,
                                                VI_FALSE));
        checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                                AGX2K3K_ATTR_SBUS_SENT_SIGNAL_OFFSET,
                                                VI_FALSE));
        checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                                AGX2K3K_ATTR_SBUS_SENT_SIGNAL_ORDER,
                                                VI_FALSE));
        checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_SBUS_SENT_SIGNAL_NAME,
                                                AGX2K3K_ATTR_SBUS_SENT_SIGNAL_START,
                                                VI_FALSE));
        checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_SBUS_SENT_DISPLAY,
                                                AGX2K3K_ATTR_SBUS_SENT_SIGNAL_OFFSET,
                                                VI_FALSE));

        /*- AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_SOURCE -*/
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_SOURCE,
                                           "AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_SOURCE",
                                           AGX2K3K_VAL_SOURCE_CHANNEL2, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrChannelsRangeTable_2Channels));
        checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_COUNTER_TOTALIZE_GATE_SOURCE,
                                                 agx2k3kAttrChannels_RangeTableCallback));

        /*- AGX2K3K_ATTR_TRIGGER_ZONE_SOURCE -*/
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TRIGGER_ZONE_SOURCE,
                                           "AGX2K3K_ATTR_TRIGGER_ZONE_SOURCE",
                                           AGX2K3K_VAL_SOURCE_CHANNEL1, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrChannelsRangeTable_2Channels));

        checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_TRIGGER_ZONE_SOURCE,
                                                 agx2k3kAttrChannels_RangeTableCallback));

        /*- AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_ADJACENT -*/
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_ADJACENT,
                                           "AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_ADJACENT",
                                           AGX2K3K_VAL_SOURCE_CHANNEL1, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrChannelsRangeTable_2Channels));
        checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_ADJACENT,
                                                 agx2k3kAttrChannels_RangeTableCallback));

        /*- AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DIFFERENTIAL -*/
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DIFFERENTIAL,
                                           "AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DIFFERENTIAL",
                                           AGX2K3K_VAL_SOURCE_CHANNEL1, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrChannelsRangeTable_2Channels));
        checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DIFFERENTIAL,
                                                 agx2k3kAttrChannels_RangeTableCallback));

        /*- AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DMINUS -*/
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DMINUS,
                                           "AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DMINUS",
                                           AGX2K3K_VAL_SOURCE_CHANNEL3, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrChannelsRangeTable_2Channels));
        checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DMINUS,
                                                 agx2k3kAttrChannels_RangeTableCallback));

        /*- AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DPLUS -*/
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DPLUS,
                                           "AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DPLUS",
                                           AGX2K3K_VAL_SOURCE_CHANNEL2, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrChannelsRangeTable_2Channels));
        checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_COMPLIANCE_USB_SOURCE_DPLUS,
                                                 agx2k3kAttrChannels_RangeTableCallback));

        /*- AGX2K3K_ATTR_SBUS_SENT_SOURCE -*/
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_SENT_SOURCE,
                                           "AGX2K3K_ATTR_SBUS_SENT_SOURCE",
                                           AGX2K3K_VAL_SBUS_SENT_SOURCE_CHANNEL1,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSBusSENTSourceRangeTable_2Channels));
        checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_SBUS_SENT_SOURCE,
                                                 agx2k3kAttrSBusSENTSource_RangeTableCallback));

        /*- AGX2K3K_ATTR_COUNTER_SOURCE -*/
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_COUNTER_SOURCE,
                                           "AGX2K3K_ATTR_COUNTER_SOURCE",
                                           AGX2K3K_VAL_COUNTER_SOURCE_CHANNEL1, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrCounterSourceRangeTable_2Channels));
        checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_COUNTER_SOURCE,
                                                 agx2k3kAttrCounterSource_RangeTableCallback));
    }

    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_DVM_ENABLED,
                                         "AGX2K3K_ATTR_DVM_ENABLED", VI_FALSE, 0,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_DVM_AUTO_RANGE_ENABLED,
                                         "AGX2K3K_ATTR_DVM_AUTO_RANGE_ENABLED",
                                         VI_FALSE, 0, agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_DVM_MODE,
                                       "AGX2K3K_ATTR_DVM_MODE",
                                       AGX2K3K_VAL_DVM_MODE_ACRMS, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrDvmModeRangeTable));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_DVM_ANALOG_SOURCE,
                                       "AGX2K3K_ATTR_DVM_ANALOG_SOURCE",
                                       AGX2K3K_VAL_DVM_ANALOG_CHANNEL_1, 0,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrDvmAnalogSourceRangeTable));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_DVM_CURRENT,
                                        "AGX2K3K_ATTR_DVM_CURRENT", 1.28,
                                        IVI_VAL_NOT_USER_WRITABLE,
                                        agx2k3kViReal64_ReadCallback, VI_NULL,
                                        VI_NULL, 0));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_DVM_FREQUENCY,
                                        "AGX2K3K_ATTR_DVM_FREQUENCY", 0,
                                        IVI_VAL_NOT_USER_WRITABLE,
                                        agx2k3kViReal64_ReadCallback, VI_NULL,
                                        VI_NULL, 0));

    if (IS_4000_SERIES (modelType) || IS_6000_SERIES (modelType))
    {
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_REFERENCE_SIGNAL_MODE,
                                           "AGX2K3K_ATTR_REFERENCE_SIGNAL_MODE",
                                           AGX2K3K_VAL_REFERENCE_SIGNAL_MODE_OFF, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrReferenceSignalModeRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FUNCTION_VERTICAL_AXIS,
                                            "AGX2K3K_ATTR_FUNCTION_VERTICAL_AXIS", 8,
                                            IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_FUNCTION_REFERENCE_LEVEL,
                                            "AGX2K3K_ATTR_FUNCTION_REFERENCE_LEVEL", 0,
                                            IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_FUNCTION_NUM_AVERAGES,
                                           "AGX2K3K_ATTR_FUNCTION_NUM_AVERAGES", 8,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrFunctionNumAveragesRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_POWER_PHASE_ANGLE,
                                            "AGX2K3K_ATTR_MEASURE_POWER_PHASE_ANGLE",
                                            VI_NULL, IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_APPARENT_POWER,
                                            "AGX2K3K_ATTR_MEASURE_APPARENT_POWER",
                                            VI_NULL, IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_AREA,
                                            "AGX2K3K_ATTR_MEASURE_AREA", VI_NULL,
                                            IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_MEASURE_POWER_LOSS_PER_CYCLE,
                                            "AGX2K3K_ATTR_MEASURE_POWER_LOSS_PER_CYCLE",
                                            VI_NULL, IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_CREST_FACOTR,
                                            "AGX2K3K_ATTR_MEASURE_CREST_FACOTR", VI_NULL,
                                            IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_ENERGY_LOSS,
                                            "AGX2K3K_ATTR_MEASURE_ENERGY_LOSS", VI_NULL,
                                            IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_POWER_FACTOR,
                                            "AGX2K3K_ATTR_MEASURE_POWER_FACTOR", VI_NULL,
                                            IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_INPUT_POWER,
                                            "AGX2K3K_ATTR_MEASURE_INPUT_POWER", VI_NULL,
                                            IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_OFF_TIME,
                                            "AGX2K3K_ATTR_MEASURE_OFF_TIME", VI_NULL,
                                            IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_ON_TIME,
                                            "AGX2K3K_ATTR_MEASURE_ON_TIME", VI_NULL,
                                            IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_OUTPUT_POWER,
                                            "AGX2K3K_ATTR_MEASURE_OUTPUT_POWER", VI_NULL,
                                            IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_POWER_LOSS,
                                            "AGX2K3K_ATTR_MEASURE_POWER_LOSS", VI_NULL,
                                            IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_REACTIVE_POWER,
                                            "AGX2K3K_ATTR_MEASURE_REACTIVE_POWER",
                                            VI_NULL, IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEASURE_REAL_POWER,
                                            "AGX2K3K_ATTR_MEASURE_REAL_POWER", VI_NULL,
                                            IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_MEASURE_CONTINUOUSLY_DISPLAYED_RESULTS,
                                            "AGX2K3K_ATTR_MEASURE_CONTINUOUSLY_DISPLAYED_RESULTS",
                                            VI_NULL, IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViString_ReadCallback, VI_NULL));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_MEASURE_INFORMATION_TYPE,
                                           "AGX2K3K_ATTR_MEASURE_INFORMATION_TYPE",
                                           AGX2K3K_VAL_MEASURE_STATISTICS_MODE_ON, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrMeasureInformationTypeRangeTable));
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_POWER_HARMONICS_TABLE,
                                            "AGX2K3K_ATTR_POWER_HARMONICS_TABLE",
                                            VI_NULL, IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViString_ReadCallback, VI_NULL));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_HARMONICS_FAIL_COUNT,
                                           "AGX2K3K_ATTR_POWER_HARMONICS_FAIL_COUNT",
                                           VI_NULL, IVI_VAL_NOT_USER_WRITABLE,
                                           agx2k3kViInt32_ReadCallback, VI_NULL, VI_NULL));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_POWER_HARMONICS_POWER_FACTOR,
                                            "AGX2K3K_ATTR_POWER_HARMONICS_POWER_FACTOR",
                                            VI_NULL, IVI_VAL_NOT_USER_WRITABLE,
                                            agx2k3kViReal64_ReadCallback, VI_NULL,
                                            VI_NULL, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_POWER_HARMONICS_RUN_ITERATION_COUNT,
                                           "AGX2K3K_ATTR_POWER_HARMONICS_RUN_ITERATION_COUNT",
                                           VI_NULL, IVI_VAL_NOT_USER_WRITABLE,
                                           agx2k3kViInt32_ReadCallback, VI_NULL, VI_NULL));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_POWER_HARMONICS_FAIL_PASS_STATUS,
                                           "AGX2K3K_ATTR_POWER_HARMONICS_FAIL_PASS_STATUS",
                                           VI_NULL, IVI_VAL_NOT_USER_WRITABLE,
                                           agx2k3kEnum_ReadCallback, VI_NULL,
                                           &attrPowerHarmonicsFailPassStatusRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_POWER_HARMONICS_TOTAL_DISTORTION,
                                            "AGX2K3K_ATTR_POWER_HARMONICS_TOTAL_DISTORTION",
                                            VI_NULL, 0, agx2k3kViReal64_ReadCallback,
                                            VI_NULL, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_HARMONICS_CYCLE_COUNT,
                                           "AGX2K3K_ATTR_POWER_HARMONICS_CYCLE_COUNT",
                                           20, 0, agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrPowerHarmonicsCycleCountRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_POWER_QUALITY_CYCLE_COUNT,
                                           "AGX2K3K_ATTR_POWER_QUALITY_CYCLE_COUNT", 0,
                                           0, agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrPowerHarmonicsCycleQualityRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_EFFICIENCY_DURATION,
                                            "AGX2K3K_ATTR_POWER_EFFICIENCY_DURATION",
                                            0.1, 0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_MODULATION_DURATION,
                                            "AGX2K3K_ATTR_POWER_MODULATION_DURATION",
                                            0.01, 0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_OFF_DURAQTION,
                                            "AGX2K3K_ATTR_POWER_OFF_DURAQTION", 1, 0,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_ON_DURATION,
                                            "AGX2K3K_ATTR_POWER_ON_DURATION", 0.5, 0,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_RIPPLE_DURATION,
                                            "AGX2K3K_ATTR_POWER_RIPPLE_DURATION", 0.0005,
                                            0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_TRANSIENT_DURATION,
                                            "AGX2K3K_ATTR_POWER_TRANSIENT_DURATION",
                                            0.0000002, 0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_IRUSH_AMPLITUDE,
                                            "AGX2K3K_ATTR_POWER_IRUSH_AMPLITUDE", 35, 0,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_IRUSH_MAX_VOLTAGE,
                                            "AGX2K3K_ATTR_POWER_IRUSH_MAX_VOLTAGE", 40,
                                            0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_OFF_MAX_VOLTAGE,
                                            "AGX2K3K_ATTR_POWER_OFF_MAX_VOLTAGE", 40, 0,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_ON_MAX_VOLTAGE,
                                            "AGX2K3K_ATTR_POWER_ON_MAX_VOLTAGE", 40, 0,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_OFF_DC_VOLTAGE,
                                            "AGX2K3K_ATTR_POWER_OFF_DC_VOLTAGE", 12, 0,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_ON_DC_VOLTAGE,
                                            "AGX2K3K_ATTR_POWER_ON_DC_VOLTAGE", 12, 0,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_POWER_TRANSIENT_DC_VOLTAGE,
                                            "AGX2K3K_ATTR_POWER_TRANSIENT_DC_VOLTAGE",
                                            12, 0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_A429_ERROR_COUNT,
                                           "AGX2K3K_ATTR_SBUS_A429_ERROR_COUNT", 0,
                                           IVI_VAL_NOT_USER_WRITABLE | IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback, VI_NULL, VI_NULL));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_A429_WORD_COUNT,
                                           "AGX2K3K_ATTR_SBUS_A429_WORD_COUNT", 0,
                                           IVI_VAL_NOT_USER_WRITABLE | IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback, VI_NULL, VI_NULL));
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_A429_TRIGGER_RANGE,
                                            "AGX2K3K_ATTR_SBUS_A429_TRIGGER_RANGE",
                                            "0,1", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_FLEX_SYNC_FRAME_COUNT,
                                           "AGX2K3K_ATTR_SBUS_FLEX_SYNC_FRAME_COUNT", 0,
                                           IVI_VAL_NOT_USER_WRITABLE | IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback, VI_NULL, VI_NULL));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_FLEX_TOTAL_FRAME_COUNT,
                                           "AGX2K3K_ATTR_SBUS_FLEX_TOTAL_FRAME_COUNT", 0,
                                           IVI_VAL_NOT_USER_WRITABLE | IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback, VI_NULL, VI_NULL));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_FLEX_EVENT_TRIGGER_MODE,
                                           "AGX2K3K_ATTR_SBUS_FLEX_EVENT_TRIGGER_MODE",
                                           AGX2K3K_VAL_SBUS_FLEX_EVENT_TRIGGER_MODE_WAKEUP,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSbusFlexEventTriggerModeRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_USB_BASE,
                                           "AGX2K3K_ATTR_SBUS_USB_BASE",
                                           AGX2K3K_VAL_SBUS_USB_BASE_HEX,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSbusUsbBaseRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_USB_DIFFERENTIAL_SOURCE,
                                           "AGX2K3K_ATTR_SBUS_USB_DIFFERENTIAL_SOURCE",
                                           AGX2K3K_VAL_SBUS_USB_DIFF_SOURCE_CHANNEL_1,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSbusUsbDifferentialSourceRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_USB_D_MINUS_SOURCE,
                                           "AGX2K3K_ATTR_SBUS_USB_D_MINUS_SOURCE",
                                           AGX2K3K_VAL_SBUS_USB_D_MINUS_SOURCE_CHANNEL_2,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSbusUsbDMinusSourceRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_USB_D_PLUS_SOURCE,
                                           "AGX2K3K_ATTR_SBUS_USB_D_PLUS_SOURCE",
                                           AGX2K3K_VAL_SBUS_USB_D_PLUS_SOURCE_CHANNEL_1,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSbusUsbDPlusSourceRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_USB_SPEED,
                                           "AGX2K3K_ATTR_SBUS_USB_SPEED",
                                           AGX2K3K_VAL_SBUS_USB_SPEED_FULL,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSbusUsbSpeedRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_USB_TRIGGER_MODE,
                                           "AGX2K3K_ATTR_SBUS_USB_TRIGGER_MODE",
                                           AGX2K3K_VAL_SBUS_USB_TRIGGER_SOP,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSbusUsbTriggerModeRangeTable));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_USB_TRIGGER_ADDRESS_PORTION,
                                            "AGX2K3K_ATTR_SBUS_USB_TRIGGER_ADDRESS_PORTION",
                                            "\"XXXXXXX\"", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_USB_TRIGGER_CRC_PORTION,
                                            "AGX2K3K_ATTR_SBUS_USB_TRIGGER_CRC_PORTION",
                                            "\"XXXXX\"", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PORTION,
                                            "AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PORTION",
                                            "\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"",
                                            IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_LENGTH,
                                           "AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_LENGTH",
                                           4, IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSbusUsbTriggerDataLengthRangeTable));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_USB_TRIGGER_ENDPOINT_PORTION,
                                            "AGX2K3K_ATTR_SBUS_USB_TRIGGER_ENDPOINT_PORTION",
                                            "\"XXXX\"", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_USB_TRIGGER_ET_PORTION,
                                            "AGX2K3K_ATTR_SBUS_USB_TRIGGER_ET_PORTION",
                                            "\"XX\"", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_USB_TRIGGER_FRAME_PORTION,
                                            "AGX2K3K_ATTR_SBUS_USB_TRIGGER_FRAME_PORTION",
                                            "\"XXXXXXXXXXX\"", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_USB_TRIGGER_HUB_ADDRESS_PORTION,
                                            "AGX2K3K_ATTR_SBUS_USB_TRIGGER_HUB_ADDRESS_PORTION",
                                            "\"XXXXXXX\"", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_USB_TRIGGER_PID_CHECK_PORTION,
                                            "AGX2K3K_ATTR_SBUS_USB_TRIGGER_PID_CHECK_PORTION",
                                            "\"XXXX\"", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PID,
                                           "AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PID",
                                           AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_DATA0,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSbusUsbTriggerDataPidRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_SBUS_USB_TRIGGER_HANDSHAKE_PID,
                                           "AGX2K3K_ATTR_SBUS_USB_TRIGGER_HANDSHAKE_PID",
                                           AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_HANDSHAKE_ACK,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSbusUsbTriggerHandshakePidRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_USB_TRIGGER_SPECIAL_PID,
                                           "AGX2K3K_ATTR_SBUS_USB_TRIGGER_SPECIAL_PID",
                                           AGX2K3K_VAL_SBUS_USB_TRIGGER_SPECIAL_PID_PRE,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSbusUsbTriggerSpecialPidRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_USB_TRIGGER_TOKEN_PID,
                                           "AGX2K3K_ATTR_SBUS_USB_TRIGGER_TOKEN_PID",
                                           AGX2K3K_VAL_SBUS_USB_TRIGGER_PID_TOKEN_OUT,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSbusUsbTriggerTokenPidRangeTable));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_USB_TRIGGER_PORT_PORTION,
                                            "AGX2K3K_ATTR_SBUS_USB_TRIGGER_PORT_PORTION",
                                            "\"XXXXXXX\"", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SBUS_USB_TRIGGER_SC_PORTION,
                                            "AGX2K3K_ATTR_SBUS_USB_TRIGGER_SC_PORTION",
                                            "\"X\"", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SBUS_USB_TRIGGER_SEU_PORTION,
                                            "AGX2K3K_ATTR_SBUS_USB_TRIGGER_SEU_PORTION",
                                            "\"XX\"", IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_USB_ADDRESS_PORTION,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_USB_ADDRESS_PORTION",
                                            "\"0xXX\"", 0, agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_USB_CRC_PORTION,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_USB_CRC_PORTION",
                                            "\"0xXX\"", 0, agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_PORTION,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_PORTION",
                                            "\"0xXXXXXXXX\"", 0,
                                            agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_LENGTH,
                                           "AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_LENGTH",
                                           4, 0, agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrSearchSerialUsbDataLengthRangeTable));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_USB_ENDPOINT_PORTION,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_USB_ENDPOINT_PORTION",
                                            "\"0xX\"", 0, agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_USB_ET_PORTION,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_USB_ET_PORTION",
                                            "\"0xX\"", 0, agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_USB_FRAME_PORTION,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_USB_FRAME_PORTION",
                                            "\"0xXXX\"", 0, agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_USB_HUB_ADDRESS_PORTION,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_USB_HUB_ADDRESS_PORTION",
                                            "\"0xXX\"", 0, agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_SEARCH_SERIAL_USB_SEARCH_MODE,
                                           "AGX2K3K_ATTR_SEARCH_SERIAL_USB_SEARCH_MODE",
                                           AGX2K3K_VAL_SEARCH_SERIAL_USB_MODE_TOKEN, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSearchSerialUsbSearchModeRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_PID,
                                           "AGX2K3K_ATTR_SEARCH_SERIAL_USB_DATA_PID",
                                           AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_DATA0, 0,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSearchSerialUsbDataPidRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_SEARCH_SERIAL_USB_HANDSHAKE_PID,
                                           "AGX2K3K_ATTR_SEARCH_SERIAL_USB_HANDSHAKE_PID",
                                           AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_HANDSHAKE_ACK,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSearchSerialUsbHandshakePidRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_SEARCH_SERIAL_USB_SPECIAL_PID,
                                           "AGX2K3K_ATTR_SEARCH_SERIAL_USB_SPECIAL_PID",
                                           AGX2K3K_VAL_SEARCH_SERIAL_USB_SPECIAL_PID_PRE,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSearchSerialUsbSpecialPidRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEARCH_SERIAL_USB_TOKEN_PID,
                                           "AGX2K3K_ATTR_SEARCH_SERIAL_USB_TOKEN_PID",
                                           AGX2K3K_VAL_SEARCH_SERIAL_USB_PID_TOKEN_OUT,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSearchSerialUsbTokenPidRangeTable));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_USB_PORT_PORTION,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_USB_PORT_PORTION",
                                            "\"0xXX\"", 0, agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_USB_SC_PORTION,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_USB_SC_PORTION",
                                            "\"0xX\"", 0, agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_SEARCH_SERIAL_USB_SEU_PORTION,
                                            "AGX2K3K_ATTR_SEARCH_SERIAL_USB_SEU_PORTION",
                                            "\"0xX\"", 0, agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));

        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_FLOAT_ARB_WAVEFORM,
                                            "AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_FLOAT_ARB_WAVEFORM",
                                            VI_NULL,
                                            IVI_VAL_NOT_USER_READABLE | IVI_VAL_MULTI_CHANNEL,
                                            VI_NULL, agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_WAVEGEN_ARB_WAVEFORM_POINT_COUNT,
                                           "AGX2K3K_ATTR_WAVEGEN_ARB_WAVEFORM_POINT_COUNT",
                                           2,
                                           IVI_VAL_NOT_USER_WRITABLE | IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback, VI_NULL, VI_NULL));
        checkErr (Ivi_AddAttributeViString (vi,
                                            AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_DAC_ARB_WAVEFORM,
                                            "AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_DAC_ARB_WAVEFORM",
                                            VI_NULL,
                                            IVI_VAL_NOT_USER_READABLE | IVI_VAL_MULTI_CHANNEL,
                                            VI_NULL, agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_WAVEGEN_STORE_ARB_WAVEFORM,
                                           "AGX2K3K_ATTR_WAVEGEN_STORE_ARB_WAVEFORM",
                                           AGX2K3K_VAL_STORE_ARB_WAVEFORM_CHANNEL_1,
                                           IVI_VAL_NOT_USER_READABLE | IVI_VAL_MULTI_CHANNEL,
                                           VI_NULL, agx2k3kEnum_WriteCallback,
                                           &attrWavegenStoreArbWaveformRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_COUNT,
                                           "AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_COUNT",
                                           100, IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrWavegenAmModulationCountRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_FREQUENCY,
                                            "AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_FREQUENCY",
                                            1000, IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_DEVIATION,
                                            "AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_DEVIATION",
                                            1000, IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_FREQUENCY,
                                            "AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_FREQUENCY",
                                            1000, IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_HOP_FREQUENCY,
                                            "AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_HOP_FREQUENCY",
                                            2000, IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi,
                                            AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_RATE,
                                            "AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_RATE",
                                            1000, IVI_VAL_MULTI_CHANNEL,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback, VI_NULL, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_WAVEGEN_MODULATION_SIGNAL_SHAPE,
                                           "AGX2K3K_ATTR_WAVEGEN_MODULATION_SIGNAL_SHAPE",
                                           AGX2K3K_VAL_WAVEGEN_MODULATION_SINEUSOID,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrWavegenModulationSignalShapeRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_WAVEGEN_MODULATION_RAMP_SYMMETRY,
                                           "AGX2K3K_ATTR_WAVEGEN_MODULATION_RAMP_SYMMETRY",
                                           50, IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrWavegenModulationRampSymmetryRangeTable));

        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_WAVEGEN_MODULATION_ENABLED,
                                             "AGX2K3K_ATTR_WAVEGEN_MODULATION_ENABLED",
                                             VI_FALSE, IVI_VAL_MULTI_CHANNEL,
                                             agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_WAVEGEN_MODULATION_TYPE,
                                           "AGX2K3K_ATTR_WAVEGEN_MODULATION_TYPE",
                                           AGX2K3K_VAL_WAVEGEN_MODULATION_TYPE_AM,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrWavegenModulationTypeRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi,
                                           AGX2K3K_ATTR_WAVEGEN_OUTPUT_POLARITY_INVERTED,
                                           "AGX2K3K_ATTR_WAVEGEN_OUTPUT_POLARITY_INVERTED",
                                           VI_FALSE, IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrWavegenOutputPolarityInvertedRangeTable));
        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_WAVEGEN_TRACKING_ENABLED,
                                             "AGX2K3K_ATTR_WAVEGEN_TRACKING_ENABLED",
                                             VI_FALSE, IVI_VAL_MULTI_CHANNEL,
                                             agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViBoolean (vi,
                                             AGX2K3K_ATTR_WAVEGEN_AMPLITUDE_TRACKING_ENABLED,
                                             "AGX2K3K_ATTR_WAVEGEN_AMPLITUDE_TRACKING_ENABLED",
                                             VI_FALSE, IVI_VAL_MULTI_CHANNEL,
                                             agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViBoolean (vi,
                                             AGX2K3K_ATTR_WAVEGEN_FREQUENCY_TRACKING_ENABLED,
                                             "AGX2K3K_ATTR_WAVEGEN_FREQUENCY_TRACKING_ENABLED",
                                             VI_FALSE, IVI_VAL_MULTI_CHANNEL,
                                             agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_INTERPOLATION,
                                           "AGX2K3K_ATTR_INTERPOLATION",
                                           AGX2K3K_VAL_NO_INTERPOLATION,
                                           IVI_VAL_MULTI_CHANNEL,
                                           agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrInterpolationRangeTable));
    }

    if (IS_6000_SERIES (modelType))
    {
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_CHANNEL_BANDWIDTH,
                                            "AGX2K3K_ATTR_CHANNEL_BANDWIDTH", 6e9,
                                            IVI_VAL_MULTI_CHANNEL | IVI_VAL_COERCEABLE_ONLY_BY_INSTR,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback,
                                            &attrChannelBandwidthRangeTable, 0));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_HISTOGRAM_MEASUREMENT,
                                           "AGX2K3K_ATTR_HISTOGRAM_MEASUREMENT", AGX2K3K_VAL_MEAS1,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrMeasurementRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_HISTOGRAM_MODE,
                                           "AGX2K3K_ATTR_HISTOGRAM_MODE", AGX2K3K_VAL_OFF,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrHistogramRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_HISTOGRAM_AXIS,
                                           "AGX2K3K_ATTR_HISTOGRAM_AXIS", AGX2K3K_VAL_HORIZONTAL,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrHistogramAxisRangeTable));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_HISTOGRAM_WINDOW_BLIMIT,
                                            "AGX2K3K_ATTR_HISTOGRAM_WINDOW_BLIMIT", -15,
                                            IVI_VAL_COERCEABLE_ONLY_BY_INSTR,
                                            agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback,
                                            &attrHistogramBLimitRangeTable, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_HISTOGRAM_WINDOW_LLIMIT,
                                            "AGX2K3K_ATTR_HISTOGRAM_WINDOW_LLIMIT", -400e-6,
                                            0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback,
                                            &attrHistogramLLimitRangeTable, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_HISTOGRAM_WINDOW_RLIMIT,
                                            "AGX2K3K_ATTR_HISTOGRAM_WINDOW_RLIMIT", 400e-6,
                                            0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback,
                                            &attrHistogramRLimitRangeTable, 0));
        checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_HISTOGRAM_WINDOW_TLIMIT,
                                            "AGX2K3K_ATTR_HISTOGRAM_WINDOW_TLIMIT", 15,
                                            0, agx2k3kViReal64_ReadCallback,
                                            agx2k3kViReal64_WriteCallback,
                                            &attrHistogramTLimitRangeTable, 0));
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_HISTOGRAM_WINDOW_SOURCE,
                                            "AGX2K3K_ATTR_HISTOGRAM_WINDOW_SOURCE", "CHAN1",
                                            0, agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_JITTER_MEASUREMENT,
                                           "AGX2K3K_ATTR_JITTER_MEASUREMENT", AGX2K3K_VAL_MEAS1,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrMeasurementRangeTable));
        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_JITTER_ENABLE,
                                             "AGX2K3K_ATTR_JITTER_ENABLE", VI_FALSE,
                                             0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_RTEYE_SOURCE,
                                            "AGX2K3K_ATTR_RTEYE_SOURCE", "CHAN1",
                                            0, agx2k3kViString_ReadCallback,
                                            agx2k3kViString_WriteCallback));
        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_RTEYE_ENABLE,
                                             "AGX2K3K_ATTR_RTEYE_ENABLE", VI_FALSE,
                                             0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_CGRADE_ENABLED,
                                             "AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_CGRADE_ENABLED", VI_FALSE,
                                             0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_HISTOGRAM_ENABLED,
                                             "AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_HISTOGRAM_ENABLED", VI_FALSE,
                                             0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_SYSTEM_PRECISION_ENABLED,
                                             "AGX2K3K_ATTR_SYSTEM_PRECISION_ENABLED", VI_FALSE,
                                             0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SYSTEM_PRECISION_LENGTH,
                                           "AGX2K3K_ATTR_SYSTEM_PRECISION_LENGTH", 100000,
                                           0, agx2k3kViInt32_ReadCallback,
                                           agx2k3kViInt32_WriteCallback,
                                           &attrPrecisionLengthRangeTable));
        checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_TRIGGER_JFREE_ENABLED,
                                             "AGX2K3K_ATTR_TRIGGER_JFREE_ENABLED", VI_FALSE,
                                             0, agx2k3kViBoolean_ReadCallback,
                                             agx2k3kViBoolean_WriteCallback));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SBUS_CAN_FDSTANDARD,
                                           "AGX2K3K_ATTR_SBUS_CAN_FDSTANDARD", AGX2K3K_VAL_ISO,
                                           0, VI_NULL, VI_NULL,
                                           &attrCANFDStandardRangeTable));
        checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_WAVEFORM_SOURCE_SUBSOURCE,
                                           "AGX2K3K_ATTR_WAVEFORM_SOURCE_SUBSOURCE", AGX2K3K_VAL_SUB0,
                                           0, agx2k3kEnum_ReadCallback,
                                           agx2k3kEnum_WriteCallback,
                                           &attrSubsourceRangeTable));
        /* invalidations */
        checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_HISTOGRAM_MODE,
                                                AGX2K3K_ATTR_SAVE_RESULTS_FORMAT_HISTOGRAM_ENABLED, VI_TRUE));
        checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_JITTER_ENABLE,
                                                AGX2K3K_ATTR_SYSTEM_PRECISION_ENABLED, VI_TRUE));
        checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_JITTER_ENABLE,
                                                AGX2K3K_ATTR_SYSTEM_PRECISION_LENGTH, VI_TRUE));
    }
    /*- AGX2K3K_ATTR_ACQUISITION_TYPE -*/
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_ACQUISITION_TYPE,
                                       "AGX2K3K_ATTR_ACQUISITION_TYPE",
                                       AGX2K3K_VAL_NORMAL,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrAcquisitionTypeRangeTable));

    /*- AGX2K3K_ATTR_ACQUISITION_MODE -*/
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_ACQUISITION_MODE,
                                       "AGX2K3K_ATTR_ACQUISITION_MODE",
                                       AGX2K3K_VAL_ACQ_MODE_REALTIME,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrAcquisitionModeRangeTable));
    checkErr (Ivi_SetAttrCheckCallbackViInt32 (vi, AGX2K3K_ATTR_ACQUISITION_MODE,
                                               agx2k3kAttrAcquisitionMode_CheckCallback));

    /* AGX2K3K_ATTR_SEGMENT_ANALYZE_ENABLE, with option SGM */
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_SEGMENT_ANALYZE_ENABLE,
                                         "AGX2K3K_ATTR_SEGMENT_ANALYZE_ENABLE",
                                         VI_FALSE,
                                         IVI_VAL_NOT_USER_READABLE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         VI_NULL,
                                         agx2k3kAttrSegmentAnalyzeEnable_WriteCallback));

    /* AGX2K3K_ATTR_SEGMENT_COUNT, with option SGM */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEGMENT_COUNT,
                                       "AGX2K3K_ATTR_SEGMENT_COUNT", 2,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &attrSegmentCountRangeTable));

    /* AGX2K3K_ATTR_SEGMENT_INDEX, with option SGM */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SEGMENT_INDEX,
                                       "AGX2K3K_ATTR_SEGMENT_INDEX", 1,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback, VI_NULL));

    /* AGX2K3K_ATTR_INITIATE_CONTINUOUS */
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_INITIATE_CONTINUOUS,
                                         "AGX2K3K_ATTR_INITIATE_CONTINUOUS",
                                         VI_FALSE, 0, VI_NULL,
                                         agx2k3kAttrInitiateContinuous_WriteCallback));

    /* AGX2K3K_ATTR_PROBE_SKEW */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_PROBE_SKEW,
                                        "AGX2K3K_ATTR_PROBE_SKEW", -100.0e-9,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrProbeSkewRangeTable, 0));

    /* AGX2K3K_ATTR_PROBE_UNITS */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_PROBE_UNITS,
                                       "AGX2K3K_ATTR_PROBE_UNITS",
                                       AGX2K3K_VAL_PROBE_UNITS_VOLTS,
                                       IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrProbeUnitsRangeTable));

    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_CHANNEL_LABEL,
                                        "AGX2K3K_ATTR_CHANNEL_LABEL", "",
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrChannelLabel_ReadCallback,
                                        agx2k3kAttrChannelLabel_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_CHANNEL_LABEL,
                                                agx2k3kAttrChannelLabel_CheckCallback));

    /* AGX2K3K_ATTR_DIG_POSITION */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_DIG_POSITION,
                                       "AGX2K3K_ATTR_DIG_POSITION", 0,
                                       IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &attrDigitalPositionRangeTable));

    /* AGX2K3K_ATTR_TIMEBASE_MODE */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TIMEBASE_MODE,
                                       "AGX2K3K_ATTR_TIMEBASE_MODE",
                                       AGX2K3K_VAL_TIMEBASE_NORMAL,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrTimebaseModeRangeTable));

    /*- AGX2K3K_ATTR_TIMEBASE_POSITION -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_TIMEBASE_POSITION,
                                        "AGX2K3K_ATTR_TIMEBASE_POSITION", 0.0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrTimebasePositionRangeTable, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_TIMEBASE_POSITION,
                                                agx2k3kAttrTimebasePosition_CheckCallback));

    /* AGX2K3K_ATTR_TIMEBASE_REFERENCE */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_TIMEBASE_REFERENCE,
                                       "AGX2K3K_ATTR_TIMEBASE_REFERENCE",
                                       AGX2K3K_VAL_TIMEBASE_REF_CENTER,
                                       IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrTimebaseReferenceRangeTable));

    /* AGX2K3K_ATTR_TIMEBASE_VERNIER */
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_TIMEBASE_VERNIER,
                                         "AGX2K3K_ATTR_TIMEBASE_VERNIER", VI_FALSE,
                                         IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));

    /* AGX2K3K_ATTR_WIN_TIMEBASE_POSITION */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WIN_TIMEBASE_POSITION,
                                        "AGX2K3K_ATTR_WIN_TIMEBASE_POSITION", 0.0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_WIN_TIMEBASE_POSITION,
                                                agx2k3kAttrWindowTimebasePosition_CheckCallback));

    /* AGX2K3K_ATTR_WIN_TIMEBASE_RANGE */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WIN_TIMEBASE_RANGE,
                                        "AGX2K3K_ATTR_WIN_TIMEBASE_RANGE", 5.0e-6,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_WIN_TIMEBASE_RANGE,
                                                agx2k3kAttrWindowTimebaseRange_CheckCallback));

    /* AGX2K3K_ATTR_WIN_TIMEBASE_SCALE */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WIN_TIMEBASE_SCALE,
                                        "AGX2K3K_ATTR_WIN_TIMEBASE_SCALE", 0.5e-6,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_WIN_TIMEBASE_SCALE,
                                                agx2k3kAttrWindowTimebaseScale_CheckCallback));

    /*- AGX2K3K_ATTR_NUM_AVERAGES -*/
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_NUM_AVERAGES,
                                       "AGX2K3K_ATTR_NUM_AVERAGES", 8,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kViInt32_ReadCallback,
                                       agx2k3kViInt32_WriteCallback,
                                       &attrNumAveragesRangeTable));

    /* AGX2K3K_ATTR_SAMPLE_MODE */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_SAMPLE_MODE,
                                       "AGX2K3K_ATTR_SAMPLE_MODE",
                                       AGX2K3K_VAL_EQUIVALENT_TIME,
                                       IVI_VAL_NOT_USER_WRITABLE,
                                       agx2k3kAttrSampleMode_ReadCallback, VI_NULL,
                                       VI_NULL));


    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEAS_HIGH_REF,
                                        "AGX2K3K_ATTR_MEAS_HIGH_REF", 90.0, 0,
                                        VI_NULL, VI_NULL, &attrMeasHighRefRangeTable,
                                        0));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEAS_LOW_REF,
                                        "AGX2K3K_ATTR_MEAS_LOW_REF", 10.0, 0,
                                        VI_NULL, VI_NULL, VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_MEAS_LOW_REF,
                                                agx2k3kAttrMeasLowRef_CheckCallback));
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MEAS_MID_REF,
                                        "AGX2K3K_ATTR_MEAS_MID_REF", 50.0, 0,
                                        VI_NULL, VI_NULL, VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_MEAS_MID_REF,
                                                agx2k3kAttrMeasMidRef_CheckCallback));
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_MEASURE_SOURCE,
                                        "AGX2K3K_ATTR_MEASURE_SOURCE", "CHAN1,CHAN1",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrMeasureSource_ReadCallback,
                                        agx2k3kAttrMeasureSource_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_MEASURE_SOURCE,
                                                agx2k3kAttrMeasureSource_CheckCallback));
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_MEASURE_DELAY,
                                        "AGX2K3K_ATTR_MEASURE_DELAY", "DEL,0,0",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrMeasureDelay_ReadCallback,
                                        agx2k3kAttrMeasureDelay_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_MEASURE_DELAY,
                                                agx2k3kAttrMeasureDelay_CheckCallback));
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_MEASURE_REF,
                                        "AGX2K3K_ATTR_MEASURE_REF",
                                        "THR,PERC,90,50,10",
                                        IVI_VAL_NOT_USER_READABLE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        VI_NULL, agx2k3kAttrMeasureRef_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_MEASURE_REF,
                                                agx2k3kAttrMeasureRef_CheckCallback));

    /* AGX2K3K_ATTR_MATH_CHANNEL_ENABLED */
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_MATH_CHANNEL_ENABLED,
                                         "AGX2K3K_ATTR_MATH_CHANNEL_ENABLED",
                                         VI_TRUE,
                                         IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));
    checkErr (Ivi_AddAttributeViBoolean (vi,
                                         AGX2K3K_ATTR_MATH_CHANNEL_ENABLED_MULTICHANNEL,
                                         "AGX2K3K_ATTR_MATH_CHANNEL_ENABLED_MULTICHANNEL",
                                         VI_TRUE,
                                         IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));


    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_MATH_SOURCE1,
                                        "AGX2K3K_ATTR_MATH_SOURCE1",
                                        AGX2K3K_VAL_CHANNEL1,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrMathChannel_ReadCallback,
                                        agx2k3kAttrMathChannel_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_MATH_SOURCE1,
                                                agx2k3kAttrMathChannel_CheckCallback));
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_MATH_SOURCE2,
                                        "AGX2K3K_ATTR_MATH_SOURCE2",
                                        AGX2K3K_VAL_CHANNEL1,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrMathChannel_ReadCallback,
                                        agx2k3kAttrMathChannel_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_MATH_SOURCE2,
                                                agx2k3kAttrMathChannel_CheckCallback));

    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_MATH_OPERATION,
                                       "AGX2K3K_ATTR_MATH_OPERATION", 0,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kAttrMathOperation_ReadCallback,
                                       agx2k3kAttrMathOperation_WriteCallback,
                                       &attrMathOperationRangeTable));

    /* AGX2K3K_ATTR_MATH_SCALE */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MATH_SCALE,
                                        "AGX2K3K_ATTR_MATH_SCALE", 0.0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_MATH_SCALE,
                                                agx2k3kAttrMathScale_CheckCallback));

    /* AGX2K3K_ATTR_MATH_SCALE_MULTICHANNEL */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MATH_SCALE_MULTICHANNEL,
                                        "AGX2K3K_ATTR_MATH_SCALE_MULTICHANNEL", 0.0,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_MATH_SCALE_MULTICHANNEL,
                                                agx2k3kAttrMathScale_CheckCallback));
    /* AGX2K3K_ATTR_MATH_OFFSET */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MATH_OFFSET,
                                        "AGX2K3K_ATTR_MATH_OFFSET", 0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_MATH_OFFSET,
                                                agx2k3kAttrMathOffset_CheckCallback));

    /* AGX2K3K_ATTR_MATH_OFFSET_MULTICHANNEL */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MATH_OFFSET_MULTICHANNEL,
                                        "AGX2K3K_ATTR_MATH_OFFSET_MULTICHANNEL", 0,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_MATH_OFFSET_MULTICHANNEL,
                                                agx2k3kAttrMathOffset_CheckCallback));
    /* AGX2K3K_ATTR_MATH_SPAN */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MATH_SPAN,
                                        "AGX2K3K_ATTR_MATH_SPAN", 100.0e3,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrMathSpanRangeTable, 0));

    /* AGX2K3K_ATTR_MATH_SPAN_MULTICHANNEL */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MATH_SPAN_MULTICHANNEL,
                                        "AGX2K3K_ATTR_MATH_SPAN_MULTICHANNEL",
                                        100.0e3,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrMathSpanRangeTable, 0));

    /* AGX2K3K_ATTR_MATH_CENTER */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MATH_CENTER,
                                        "AGX2K3K_ATTR_MATH_CENTER", 50.0e3,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrMathCenterRangeTable, 0));

    /* AGX2K3K_ATTR_MATH_CENTER_MULTICHANNEL */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_MATH_CENTER_MULTICHANNEL,
                                        "AGX2K3K_ATTR_MATH_CENTER_MULTICHANNEL",
                                        50.0e3,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrMathCenterRangeTable, 0));
    /* AGX2K3K_ATTR_MATH_WINDOW */
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_MATH_WINDOW,
                                       "AGX2K3K_ATTR_MATH_WINDOW",
                                       AGX2K3K_VAL_MATH_WINDOW_HANNING,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrMathWindowRangeTable));

    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_MATH_WINDOW_MULTICHANNEL,
                                       "AGX2K3K_ATTR_MATH_WINDOW_MULTICHANNEL",
                                       AGX2K3K_VAL_MATH_WINDOW_HANNING,
                                       IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrMathWindowRangeTable));

    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_ID_QUERY_RESPONSE,
                                        "AGX2K3K_ATTR_ID_QUERY_RESPONSE", idnBuffer,
                                        IVI_VAL_NOT_USER_WRITABLE,
                                        agx2k3kAttrIdQueryResponse_ReadCallback,
                                        VI_NULL));


    /*- Memory Waveform Sub-system --------------------------*/
    /* AGX2K3K_ATTR_WMEMORY_COPY */
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_WMEMORY_COPY,
                                        "AGX2K3K_ATTR_WMEMORY_COPY", "CHAN1",
                                        IVI_VAL_NOT_USER_READABLE | IVI_VAL_MULTI_CHANNEL,
                                        VI_NULL, agx2k3kViString_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_WMEMORY_COPY,
                                                agx2k3kAttrWmemoryCopy_CheckCallback));

    /* AGX2K3K_ATTR_WMEMORY_SKEW */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WMEMORY_SKEW,
                                        "AGX2K3K_ATTR_WMEMORY_SKEW", 0.0,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrWmemorySkewRangeTable, 0));

    /* AGX2K3K_ATTR_WMEMORY_Y_OFFSET */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WMEMORY_Y_OFFSET,
                                        "AGX2K3K_ATTR_WMEMORY_Y_OFFSET", 0.0,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrWmemoryYOffsetRangeTable, 0));

    /* AGX2K3K_ATTR_WMEMORY_Y_RANGE */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WMEMORY_Y_RANGE,
                                        "AGX2K3K_ATTR_WMEMORY_Y_RANGE", 40.0,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrWmemoryYRangeRangeTable, 0));

    /* AGX2K3K_ATTR_WMEMORY_Y_SCALE */
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WMEMORY_Y_SCALE,
                                        "AGX2K3K_ATTR_WMEMORY_Y_SCALE", 5.0,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrWmemoryYScaleRangeTable, 0));

    /*- Save Recall Sub-system -----------------------------*/
    /* AGX2K3K_ATTR_RECALL_WMEMORY_FILE_PATH */
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_RECALL_WMEMORY_FILE_PATH,
                                        "AGX2K3K_ATTR_RECALL_WMEMORY_FILE_PATH", "",
                                        IVI_VAL_NOT_USER_READABLE | IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        VI_NULL, agx2k3kViString_WriteCallback));

    /* AGX2K3K_ATTR_SAVE_WMEMORY_SOURCE */
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SAVE_WMEMORY_SOURCE,
                                        "AGX2K3K_ATTR_SAVE_WMEMORY_SOURCE", "CHAN1",
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));
    checkErr (Ivi_SetAttrCheckCallbackViString (vi, AGX2K3K_ATTR_SAVE_WMEMORY_SOURCE,
                                                agx2k3kAttrSaveWmemory_CheckCallback));

    /* AGX2K3K_ATTR_SAVE_WMEMORY_FILE_PATH */
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_SAVE_WMEMORY_FILE_PATH,
                                        "AGX2K3K_ATTR_SAVE_WMEMORY_FILE_PATH", "",
                                        IVI_VAL_NOT_USER_READABLE | IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        VI_NULL, agx2k3kViString_WriteCallback));

    /*- Waveform Generator Sub-system -----------------------*/
    /*- AGX2K3K_ATTR_WAVEGEN_FREQUENCY -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WAVEGEN_FREQUENCY,
                                        "AGX2K3K_ATTR_WAVEGEN_FREQUENCY", 1.0e3,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrWavegenFrequencyRangeTable, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_FREQUENCY_MULTICHANNEL -*/
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_WAVEGEN_FREQUENCY_MULTICHANNEL,
                                        "AGX2K3K_ATTR_WAVEGEN_FREQUENCY_MULTICHANNEL",
                                        1.0e3,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrWavegenFrequencyRangeTable, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_FUNCTION -*/
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_WAVEGEN_FUNCTION,
                                       "AGX2K3K_ATTR_WAVEGEN_FUNCTION",
                                       AGX2K3K_VAL_WAVEGEN_SINE,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrWavegenFunctionRangeTable));

    /*- AGX2K3K_ATTR_WAVEGEN_FUNCTION_MULTICHANNEL -*/
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_WAVEGEN_FUNCTION_MULTICHANNEL,
                                       "AGX2K3K_ATTR_WAVEGEN_FUNCTION_MULTICHANNEL",
                                       AGX2K3K_VAL_WAVEGEN_SINE,
                                       IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrWavegenFunctionRangeTable));

    /*- AGX2K3K_ATTR_WAVEGEN_PERIOD -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WAVEGEN_PERIOD,
                                        "AGX2K3K_ATTR_WAVEGEN_PERIOD", 10.0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrWavegenPeriodRangeTable, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_PERIOD_MULTICHANNEL -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WAVEGEN_PERIOD_MULTICHANNEL,
                                        "AGX2K3K_ATTR_WAVEGEN_PERIOD_MULTICHANNEL",
                                        10.0,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrWavegenPeriodRangeTable, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WAVEGEN_VOLTAGE,
                                        "AGX2K3K_ATTR_WAVEGEN_VOLTAGE", 0.5,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_MULTICHANNEL -*/
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_WAVEGEN_VOLTAGE_MULTICHANNEL,
                                        "AGX2K3K_ATTR_WAVEGEN_VOLTAGE_MULTICHANNEL",
                                        0.5,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH,
                                        "AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH", 0.5,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH_MULTICHANNEL -*/
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH_MULTICHANNEL,
                                        "AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH_MULTICHANNEL",
                                        0.5,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW,
                                        "AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW", 0.5,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW_MULTICHANNEL -*/
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW_MULTICHANNEL,
                                        "AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW_MULTICHANNEL",
                                        0.5,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET,
                                        "AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET", 0.5,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET_MULTICHANNEL -*/
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET_MULTICHANNEL,
                                        "AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET_MULTICHANNEL",
                                        0.5,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH,
                                        "AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH", 100.0e-6,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH,
                                                agx2k3kAttrWavegenPulseWidth_CheckCallback));

    /*- AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH_MULTICHANNEL -*/
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH_MULTICHANNEL,
                                        "AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH_MULTICHANNEL",
                                        100.0e-6,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));
    checkErr (Ivi_SetAttrCheckCallbackViReal64 (vi, AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH_MULTICHANNEL,
                                                agx2k3kAttrWavegenPulseWidth_CheckCallback));


    /*- AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY,
                                        "AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY", 50.0,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrWavegenRampSymmetryRangeTable, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY_MULTICHANNEL -*/
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY_MULTICHANNEL,
                                        "AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY_MULTICHANNEL",
                                        50.0,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrWavegenRampSymmetryRangeTable, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE,
                                        "AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE",
                                        50.0, IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrWavegenSquareDutyCycleRangeTable, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE_MULTICHANNEL -*/
    checkErr (Ivi_AddAttributeViReal64 (vi,
                                        AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE_MULTICHANNEL,
                                        "AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE_MULTICHANNEL",
                                        50.0,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrWavegenSquareDutyCycleRangeTable, 0));

    /*- AGX2K3K_ATTR_WAVEGEN_RESET -*/
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_WAVEGEN_RESET,
                                         "AGX2K3K_ATTR_WAVEGEN_RESET", VI_FALSE,
                                         IVI_VAL_NOT_USER_READABLE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         VI_NULL,
                                         agx2k3kAttrWavegenReset_WriteCallback));

    /*- AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE -*/
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE,
                                         "AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE",
                                         VI_FALSE,
                                         IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));

    /*- AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE_MULTICHANNEL -*/
    checkErr (Ivi_AddAttributeViBoolean (vi,
                                         AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE_MULTICHANNEL,
                                         "AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE_MULTICHANNEL",
                                         VI_FALSE,
                                         IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));


    /*- AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE -*/
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE,
                                       "AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE",
                                       AGX2K3K_VAL_WAVEGEN_IMP_FIFTY,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrWavegenLoadImpedanceRangeTable));

    /*- AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE_MULTICHANNEL -*/
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE_MULTICHANNEL,
                                       "AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE_MULTICHANNEL",
                                       AGX2K3K_VAL_WAVEGEN_IMP_FIFTY,
                                       IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrWavegenLoadImpedanceRangeTable));

    /*- AGX2K3K_ATTR_TIMEBASE_SCALE -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_TIMEBASE_SCALE,
                                        "AGX2K3K_ATTR_TIMEBASE_SCALE", 100.0e-6,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback,
                                        &attrInstrTimebaseScaleRangeTable, 0));
    checkErr (Ivi_SetAttrRangeTableCallback (vi, AGX2K3K_ATTR_TIMEBASE_SCALE,
                                             agx2k3kAttrTimebaseScale_RangeTableCallback));

    /*- Hidden attributes -----------------------------------*/
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_OPC_TIMEOUT,
                                       "AGX2K3K_ATTR_OPC_TIMEOUT", 5000,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS | IVI_VAL_HIDDEN,
                                       VI_NULL, VI_NULL, VI_NULL));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_OPC_CALLBACK,
                                       "AGX2K3K_ATTR_OPC_CALLBACK", VI_NULL,
                                       IVI_VAL_DONT_CHECK_STATUS | IVI_VAL_HIDDEN,
                                       VI_NULL, VI_NULL, VI_NULL));
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_CHECK_STATUS_CALLBACK,
                                       "AGX2K3K_ATTR_CHECK_STATUS_CALLBACK", VI_NULL,
                                       IVI_VAL_DONT_CHECK_STATUS | IVI_VAL_HIDDEN,
                                       VI_NULL, VI_NULL, VI_NULL));
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_USER_INTERCHANGE_CHECK_CALLBACK,
                                       "AGX2K3K_ATTR_USER_INTERCHANGE_CHECK_CALLBACK",
                                       VI_NULL,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS | IVI_VAL_HIDDEN,
                                       VI_NULL, VI_NULL, VI_NULL));
    /*- AGX2K3K_ATTR_INSTR_MODEL_TYPE (hidden) -*/
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_INSTR_MODEL_TYPE,
                                       "AGX2K3K_ATTR_INSTR_MODEL_TYPE", modelType,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_DONT_CHECK_STATUS | IVI_VAL_HIDDEN,
                                       VI_NULL, VI_NULL, VI_NULL));

    /*- AGX2K3K_ATTR_INSTR_INPUT_IMPEDANCE (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_INPUT_IMPEDANCE,
                                        "AGX2K3K_ATTR_INSTR_INPUT_IMPEDANCE", "",
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_BW_LIMIT (hidden) -*/
    checkErr (Ivi_AddAttributeViBoolean (vi, AGX2K3K_ATTR_INSTR_BW_LIMIT,
                                         "AGX2K3K_ATTR_INSTR_BW_LIMIT", VI_FALSE,
                                         IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                         agx2k3kViBoolean_ReadCallback,
                                         agx2k3kViBoolean_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_MAX_INPUT_FREQUENCY (hidden) -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_INSTR_MAX_INPUT_FREQUENCY,
                                        "AGX2K3K_ATTR_INSTR_MAX_INPUT_FREQUENCY",
                                        26.0e6,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        VI_NULL, VI_NULL, VI_NULL, 0));

    /*- AGX2K3K_ATTR_PROBE_SENSE_VALUE -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_PROBE_SENSE_VALUE,
                                        "AGX2K3K_ATTR_PROBE_SENSE_VALUE", 1.0,
                                        IVI_VAL_NOT_USER_WRITABLE | IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION,
                                        agx2k3kAttrProbeSenseValue_ReadCallback,
                                        VI_NULL, VI_NULL, 0));

    /*- AGX2K3K_ATTR_INSTR_AUTO_PROBE_SENSE_ENABLED -*/
    checkErr (Ivi_AddAttributeViBoolean (vi,
                                         AGX2K3K_ATTR_INSTR_AUTO_PROBE_SENSE_ENABLED,
                                         "AGX2K3K_ATTR_INSTR_AUTO_PROBE_SENSE_ENABLED",
                                         VI_FALSE,
                                         IVI_VAL_MULTI_CHANNEL | IVI_VAL_HIDDEN,
                                         VI_NULL, VI_NULL));

    /*- AGX2K3K_ATTR_INSTR_PROBE_ATTENUATION (hidden) -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_INSTR_PROBE_ATTENUATION,
                                        "AGX2K3K_ATTR_INSTR_PROBE_ATTENUATION", 1.0,
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /*- AGX2K3K_ATTR_INSTR_CHANNEL_LABEL (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_CHANNEL_LABEL,
                                        "AGX2K3K_ATTR_INSTR_CHANNEL_LABEL", "",
                                        IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_SOURCE (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_SOURCE,
                                        "AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_SOURCE",
                                        "CHAN1",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_LEVEL (hidden) -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_LEVEL,
                                        "AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_LEVEL", 0.0,
                                        IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /*- AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_SOURCE (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_SOURCE,
                                        "AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_SOURCE",
                                        "CHAN1",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_LEVEL (hidden) -*/
    checkErr (Ivi_AddAttributeViReal64 (vi, AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_LEVEL,
                                        "AGX2K3K_ATTR_INSTR_TRIGGER_GLITCH_LEVEL",
                                        0.0,
                                        IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViReal64_ReadCallback,
                                        agx2k3kViReal64_WriteCallback, VI_NULL, 0));

    /*- AGX2K3K_ATTR_INSTR_TRIGGER_PATTERN (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_TRIGGER_PATTERN,
                                        "AGX2K3K_ATTR_INSTR_TRIGGER_PATTERN", "",
                                        IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_TRIGGER_TV_SOURCE (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_TRIGGER_TV_SOURCE,
                                        "AGX2K3K_ATTR_INSTR_TRIGGER_TV_SOURCE",
                                        "CHAN1",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_TRIGGER_RUNT_SOURCE (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_TRIGGER_RUNT_SOURCE,
                                        "AGX2K3K_ATTR_INSTR_TRIGGER_RUNT_SOURCE",
                                        "CHAN1",
                                        IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));
	
    /*- AGX2K3K_ATTR_INSTR_TRIGGER_TRANSITION_SOURCE (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_TRIGGER_TRANSITION_SOURCE,
                                        "AGX2K3K_ATTR_INSTR_TRIGGER_TRANSITION_SOURCE",
                                        "CHAN1",
                                        IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));
	
    /*- AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_BURST_SOURCE (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_BURST_SOURCE,
                                        "AGX2K3K_ATTR_INSTR_TRIGGER_EDGE_BURST_SOURCE",
                                        "CHAN1",
                                        IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_MEAS_SOURCE (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_MEAS_SOURCE,
                                        "AGX2K3K_ATTR_INSTR_MEAS_SOURCE",
                                        "CHAN1,CHAN1",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_MEAS_DELAY (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_MEAS_DELAY,
                                        "AGX2K3K_ATTR_INSTR_MEAS_DELAY", "DEL,0,0",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_MEAS_REF (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_MEAS_REF,
                                        "AGX2K3K_ATTR_INSTR_MEAS_REF",
                                        "THR,PERC,90,50,10",
                                        IVI_VAL_NEVER_CACHE | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        VI_NULL, agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_MATH_SOURCE (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_MATH_SOURCE,
                                        "AGX2K3K_ATTR_INSTR_MATH_SOURCE",
                                        AGX2K3K_VAL_CHANNEL1,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_ACQUISITION_POINTS (hidden) -*/
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_INSTR_ACQUISITION_POINTS,
                                       "AGX2K3K_ATTR_INSTR_ACQUISITION_POINTS",
                                       8000000, IVI_VAL_HIDDEN,
                                       agx2k3kViInt32_ReadCallback, VI_NULL, VI_NULL));

    /*- AGX2K3K_ATTR_INSTR_MATH_SOURCE1 (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_MATH_SOURCE1,
                                        "AGX2K3K_ATTR_INSTR_MATH_SOURCE1",
                                        AGX2K3K_VAL_CHANNEL1,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));
    /*- AGX2K3K_ATTR_INSTR_MATH_SOURCE2 (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_MATH_SOURCE2,
                                        "AGX2K3K_ATTR_INSTR_MATH_SOURCE2",
                                        AGX2K3K_VAL_CHANNEL1,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_MATH_OPERATION (hidden) -*/
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_INSTR_MATH_OPERATION,
                                       "AGX2K3K_ATTR_INSTR_MATH_OPERATION",
                                       AGX2K3K_VAL_MATH_OPERATION_ADD,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrInstrMathOperationRangeTable));

    /*- AGX2K3K_ATTR_INSTR_MATH_OPERATION_MULTICHANNEL (hidden) -*/
    checkErr (Ivi_AddAttributeViInt32 (vi,
                                       AGX2K3K_ATTR_INSTR_MATH_OPERATION_MULTICHANNEL,
                                       "AGX2K3K_ATTR_INSTR_MATH_OPERATION_MULTICHANNEL",
                                       AGX2K3K_VAL_MATH_OPERATION_ADD,
                                       IVI_VAL_MULTI_CHANNEL | IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrInstrMathOperationRangeTable));
    /*- AGX2K3K_ATTR_INSTR_MATH_GOFT_OPERATION (hidden) -*/
    checkErr (Ivi_AddAttributeViInt32 (vi, AGX2K3K_ATTR_INSTR_MATH_GOFT_OPERATION,
                                       "AGX2K3K_ATTR_INSTR_MATH_GOFT_OPERATION",
                                       AGX2K3K_VAL_MATH_OPERATION_ADD,
                                       IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                       agx2k3kEnum_ReadCallback,
                                       agx2k3kEnum_WriteCallback,
                                       &attrMathGoftOperationRangeTable));

    /*- AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE1 (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE1,
                                        "AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE1",
                                        AGX2K3K_VAL_CHANNEL1,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));
    /*- AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE2 (hidden) -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE2,
                                        "AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE2",
                                        AGX2K3K_VAL_CHANNEL1,
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));

    /*- AGX2K3K_ATTR_INSTR_DATA_SOURCE -*/
    checkErr (Ivi_AddAttributeViString (vi, AGX2K3K_ATTR_INSTR_DATA_SOURCE,
                                        "AGX2K3K_ATTR_INSTR_DATA_SOURCE", "CHAN1",
                                        IVI_VAL_USE_CALLBACKS_FOR_SIMULATION | IVI_VAL_HIDDEN,
                                        agx2k3kViString_ReadCallback,
                                        agx2k3kViString_WriteCallback));


    /*- Setup attribute invalidations -----------------------------------*/
    /*- AGX2K3K_ATTR_VERTICAL_RANGE Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_VERTICAL_RANGE,
                                            AGX2K3K_ATTR_VERTICAL_OFFSET,
                                            VI_FALSE));
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_VERTICAL_RANGE,
                                            AGX2K3K_ATTR_TRIGGER_LEVEL,
                                            VI_TRUE));

    /*- AGX2K3K_ATTR_VERTICAL_OFFSET Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_VERTICAL_OFFSET,
                                            AGX2K3K_ATTR_TRIGGER_LEVEL,
                                            VI_TRUE));

    /*- AGX2K3K_ATTR_PROBE_ATTENUATION Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_PROBE_ATTENUATION,
                                            AGX2K3K_ATTR_VERTICAL_RANGE,
                                            VI_FALSE));
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_PROBE_ATTENUATION,
                                            AGX2K3K_ATTR_VERTICAL_OFFSET,
                                            VI_FALSE));
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_PROBE_ATTENUATION,
                                            AGX2K3K_ATTR_TRIGGER_LEVEL,
                                            VI_FALSE));

    /*- AGX2K3K_ATTR_HORZ_RECORD_LENGTH Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_HORZ_RECORD_LENGTH,
                                            AGX2K3K_ATTR_HORZ_SAMPLE_RATE,
                                            VI_TRUE));

    /*- AGX2K3K_ATTR_HORZ_TIME_PER_RECORD Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_HORZ_TIME_PER_RECORD,
                                            AGX2K3K_ATTR_ACQUISITION_START_TIME,
                                            VI_TRUE));
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_HORZ_TIME_PER_RECORD,
                                            AGX2K3K_ATTR_HORZ_SAMPLE_RATE,
                                            VI_TRUE));

    /*- AGX2K3K_ATTR_TRIGGER_SOURCE Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_TRIGGER_SOURCE,
                                            AGX2K3K_ATTR_TRIGGER_LEVEL,
                                            VI_TRUE));

    /*- AGX2K3K_ATTR_ACQUISITION_TYPE Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_ACQUISITION_TYPE,
                                            AGX2K3K_ATTR_HORZ_RECORD_LENGTH,
                                            VI_TRUE));

    /*- AGX2K3K_ATTR_TRIGGER_MODIFIER Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_TRIGGER_MODIFIER,
                                            AGX2K3K_ATTR_TRIGGER_SLOPE,
                                            VI_FALSE));

    /*- AGX2K3K_ATTR_TRIGGER_TYPE Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_TRIGGER_TYPE,
                                            AGX2K3K_ATTR_TRIGGER_MODIFIER,
                                            VI_FALSE));
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_TRIGGER_TYPE,
                                            AGX2K3K_ATTR_TRIGGER_SLOPE,
                                            VI_FALSE));

    /*- AGX2K3K_ATTR_MEASURE_SOURCE Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_MEASURE_SOURCE,
                                            AGX2K3K_ATTR_MEASURE_REF,
                                            VI_TRUE));

    /*- AGX2K3K_ATTR_MATH_SOURCE1 Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_MATH_SOURCE1,
                                            AGX2K3K_ATTR_INSTR_MATH_SOURCE1,
                                            VI_TRUE));
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_MATH_SOURCE1,
                                            AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE1,
                                            VI_TRUE));

    /*- AGX2K3K_ATTR_MATH_SOURCE2 Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_MATH_SOURCE2,
                                            AGX2K3K_ATTR_INSTR_MATH_SOURCE2,
                                            VI_TRUE));
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_MATH_SOURCE2,
                                            AGX2K3K_ATTR_INSTR_MATH_GOFT_SOURCE2,
                                            VI_TRUE));

    /*- AGX2K3K_ATTR_RUNT_HIGH_THRESHOLD & AGX2K3K_ATTR_RUNT_LOW_THRESHOLD Invalidations -*/
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_TRIGGER_SOURCE,
                                            AGX2K3K_ATTR_RUNT_HIGH_THRESHOLD,
                                            VI_TRUE));
    checkErr (Ivi_AddAttributeInvalidation (vi, AGX2K3K_ATTR_TRIGGER_SOURCE,
                                            AGX2K3K_ATTR_RUNT_LOW_THRESHOLD,
                                            VI_TRUE));


    if (HAS_2CHANNELS (modelType))
        strcpy (AnalogChannels, CHANNEL_LIST_2);
    else
        strcpy (AnalogChannels, CHANNEL_LIST_4);

    strcpy (AnalogExtChannels, EXTERNAL_CHANNELS);
    strcat (AnalogExtChannels, ",");
    strcat (AnalogExtChannels, AnalogChannels);

    strcpy (AnalogExtMathChannels, "MATH,FUNC");
    strcat (AnalogExtMathChannels, ",");
    strcat (AnalogExtMathChannels, AnalogExtChannels);

    /* Restricting channel names for the attributes */


    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_VERTICAL_RANGE,
                                          AnalogExtMathChannels));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_VERTICAL_OFFSET,
                                          AnalogChannels));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_VERTICAL_COUPLING,
                                          AnalogChannels));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_PROBE_ATTENUATION,
                                          AnalogExtChannels));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_PROBE_SENSE_VALUE,
                                          AnalogExtChannels));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_MAX_INPUT_FREQUENCY,
                                          AnalogChannels));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_WMEMORY_COPY,
                                          WMEMORY_CHANNELS));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_WMEMORY_SKEW,
                                          WMEMORY_CHANNELS));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_WMEMORY_Y_OFFSET,
                                          WMEMORY_CHANNELS));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_WMEMORY_Y_RANGE,
                                          WMEMORY_CHANNELS));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_WMEMORY_Y_SCALE,
                                          WMEMORY_CHANNELS));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_RECALL_WMEMORY_FILE_PATH,
                                          WMEMORY_CHANNELS));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_SAVE_WMEMORY_SOURCE,
                                          WMEMORY_CHANNELS));

    checkErr (Ivi_RestrictAttrToChannels (vi,
                                          AGX2K3K_ATTR_SAVE_WMEMORY_FILE_PATH,
                                          WMEMORY_CHANNELS));

    if (IS_MSO_INSTR (modelType))
    {
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_DIG_THRESHOLD,
                                              LOGIC_CHANNELS));

        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_DIG_SIZE,
                                              LOGIC_CHANNELS));

        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_DIG_POSITION,
                                              LOGIC_CHANNELS));
    }

    if (IS_3000_SERIES (modelType) || IS_4000_SERIES (modelType) || IS_6000_SERIES (modelType))
    {
        /* AGX2K3K_ATTR_SBUS_CAN_BAUDRATE */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_CAN_BAUDRATE,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_CAN_SIGNAL */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_CAN_SIGNAL,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_CAN_TRIGGER */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_CAN_TRIGGER,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_CAN_SOURCE */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_CAN_SOURCE,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_CAN_DATA */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_CAN_DATA,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_CAN_DATA_LENGTH */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_CAN_DATA_LENGTH,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_CAN_ID_MODE */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_CAN_ID_MODE,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_CAN_ID */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_CAN_ID,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_IIC_SCL */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_IIC_SCL,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_IIC_SDA */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_IIC_SDA,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_IIC_TYPE */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_IIC_TYPE,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_IIC_QUALIFIER */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_IIC_QUALIFIER,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_IIC_ADDRESS */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_IIC_ADDRESS,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_IIC_DATA */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_IIC_DATA,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_IIC_DATA2 */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_IIC_DATA2,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_ALIGNMENT */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_ALIGNMENT,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_CLOCK_SLOPE */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_CLOCK_SLOPE,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_RECEIVER_WIDTH */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_RECEIVER_WIDTH,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_TRANSMIT_WIDTH */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_TRANSMIT_WIDTH,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_SOURCE_CLOCK */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_SOURCE_CLOCK,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_SOURCE_DATA */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_SOURCE_DATA,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_SOURCE_WS */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_SOURCE_WS,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_TRIGGER */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_TRIGGER,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_TRIGGER_AUDIO */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_TRIGGER_AUDIO,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_TRIGGER_DATA */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_TRIGGER_DATA,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_LOW,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_TRIGGER_RANGE_HIGH,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_I2S_WS_LOW */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_I2S_WS_LOW,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_BAUDRATE */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_BAUDRATE,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_BIT_ORDER */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_BIT_ORDER,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_COUNT_RESET */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_COUNT_RESET,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_COUNT_ERROR */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_COUNT_ERROR,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_COUNT_TX */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_COUNT_TX,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_COUNT_RX */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_COUNT_RX,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_FRAMING */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_FRAMING,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_PARITY */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_PARITY,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_POLARITY */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_POLARITY,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_SOURCE_RX */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_SOURCE_RX,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_SOURCE_TX */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_SOURCE_TX,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_TRIGGER_BURST */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_TRIGGER_BURST,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_TRIGGER_DATA */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_TRIGGER_DATA,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_TRIGGER_IDLE */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_TRIGGER_IDLE,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_TRIGGER_QUALIFIER */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_TRIGGER_QUALIFIER,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_TRIGGER_TYPE */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_TRIGGER_TYPE,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_UART_WIDTH */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_UART_WIDTH,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_IIC_SIZE */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_IIC_SIZE,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_LIN_BAUDRATE */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_LIN_BAUDRATE,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_LIN_TRIGGER */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_LIN_TRIGGER,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_LIN_SOURCE */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_LIN_SOURCE,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_LIN_PARITY */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_LIN_PARITY,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_LIN_STANDARD */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_LIN_STANDARD,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_LIN_SYNC_BREAK */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_LIN_SYNC_BREAK,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_LIN_TRIGGER_ID */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_LIN_TRIGGER_ID,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA_LENGTH */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_LIN_TRIGGER_DATA_LENGTH,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_SPI_MISO_WIDTH */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_MISO_WIDTH,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_SPI_MOSI_WIDTH */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_MOSI_WIDTH,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_SPI_WORD_WIDTH */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_WORD_WIDTH,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_SPI_MISO_DATA */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_MISO_DATA,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_SPI_MOSI_DATA */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_MOSI_DATA,
                                              SERIAL_CHANNELS));

        /* AGX2K3K_ATTR_SBUS_SPI_CLKSOURCE */
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_CLKSOURCE,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_SPI_DSOURCE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_DSOURCE,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_SPI_FSOURCE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_FSOURCE,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_SPI_TRIGGER_TYPE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_TRIGGER_TYPE,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_SPI_FRAME -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_FRAME,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_SPI_SLOPE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_SLOPE,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_SPI_TIMEOUT -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_TIMEOUT,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_SPI_BIT_ORDER -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_SPI_BIT_ORDER,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_MATH_FFT_FREQUENCY_START -*/
        checkErr (Ivi_RestrictAttrToChannels (vi, AGX2K3K_ATTR_MATH_FFT_FREQUENCY_START, FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_MATH_FFT_FREQUENCY_STOP -*/
        checkErr (Ivi_RestrictAttrToChannels (vi, AGX2K3K_ATTR_MATH_FFT_FREQUENCY_STOP, FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_MATH_SMOOTH_POINTS -*/
        checkErr (Ivi_RestrictAttrToChannels (vi, AGX2K3K_ATTR_MATH_SMOOTH_POINTS, FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_TRIGGER_ZONE_MODE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi, AGX2K3K_ATTR_TRIGGER_ZONE_MODE, ZONE_CHANNELS));

        /*- AGX2K3K_ATTR_MULTICHANNEL_TRIGGER_ZONE_STATE_ENABLED -*/
        checkErr (Ivi_RestrictAttrToChannels (vi, AGX2K3K_ATTR_MULTICHANNEL_TRIGGER_ZONE_STATE_ENABLED, ZONE_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_OUTPUT_MODE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi, AGX2K3K_ATTR_WAVEGEN_OUTPUT_MODE, WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_TRACK_PHASE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi, AGX2K3K_ATTR_WAVEGEN_TRACK_PHASE, WGEN_CHANNELS));


        if (HAS_2CHANNELS (modelType))
        {
            /*- AGX2K3K_ATTR_CHANNEL_PROBE_TEK_MODEL -*/
            checkErr (Ivi_RestrictAttrToChannels (vi, AGX2K3K_ATTR_CHANNEL_PROBE_TEK_MODEL, CHANNEL_LIST_2));
        }
        else
        {
            /*- AGX2K3K_ATTR_CHANNEL_PROBE_TEK_MODEL -*/
            checkErr (Ivi_RestrictAttrToChannels (vi, AGX2K3K_ATTR_CHANNEL_PROBE_TEK_MODEL, CHANNEL_LIST_4));
        }
    }
    if (IS_4000_SERIES (modelType) || IS_6000_SERIES (modelType))
    {
        /*- AGX2K3K_ATTR_SBUS_FLEX_EVENT_TRIGGER_MODE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_FLEX_EVENT_TRIGGER_MODE,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_BASE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_BASE,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_DIFFERENTIAL_SOURCE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_DIFFERENTIAL_SOURCE,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_D_MINUS_SOURCE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_D_MINUS_SOURCE,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_D_PLUS_SOURCE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_D_PLUS_SOURCE,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_SPEED -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_SPEED,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_MODE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_MODE,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_LENGTH -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_LENGTH,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PID -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PID,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_HANDSHAKE_PID -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_HANDSHAKE_PID,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_SPECIAL_PID -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_SPECIAL_PID,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_TOKEN_PID -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_TOKEN_PID,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_STORE_ARB_WAVEFORM -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_STORE_ARB_WAVEFORM,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_MODULATION_SIGNAL_SHAPE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_MODULATION_SIGNAL_SHAPE,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_MODULATION_TYPE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_MODULATION_TYPE,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_INTERPOLATION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_INTERPOLATION,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_NUM_AVERAGES -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_NUM_AVERAGES,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_A429_ERROR_COUNT -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_A429_ERROR_COUNT,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_A429_WORD_COUNT -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_A429_WORD_COUNT,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_FLEX_SYNC_FRAME_COUNT -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_FLEX_SYNC_FRAME_COUNT,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_FLEX_TOTAL_FRAME_COUNT -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_FLEX_TOTAL_FRAME_COUNT,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_ARB_WAVEFORM_POINT_COUNT -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_ARB_WAVEFORM_POINT_COUNT,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_COUNT -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_COUNT,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_MODULATION_RAMP_SYMMETRY -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_MODULATION_RAMP_SYMMETRY,
                                              WGEN_CHANNELS));


        /*- AGX2K3K_ATTR_FUNCTION_VERTICAL_AXIS -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_VERTICAL_AXIS,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_REFERENCE_LEVEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_REFERENCE_LEVEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_FREQUENCY -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_AM_MODULATION_FREQUENCY,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_DEVIATION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_DEVIATION,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_FREQUENCY -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_FM_MODULATION_FREQUENCY,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_HOP_FREQUENCY -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_HOP_FREQUENCY,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_RATE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_FSKEY_MODULATION_RATE,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_MODULATION_ENABLED -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_MODULATION_ENABLED,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_OUTPUT_POLARITY_INVERTED -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_OUTPUT_POLARITY_INVERTED,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_TRACKING_ENABLED -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_TRACKING_ENABLED,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_AMPLITUDE_TRACKING_ENABLED -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_AMPLITUDE_TRACKING_ENABLED,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_FREQUENCY_TRACKING_ENABLED -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_FREQUENCY_TRACKING_ENABLED,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_A429_TRIGGER_RANGE -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_A429_TRIGGER_RANGE,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_ADDRESS_PORTION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_ADDRESS_PORTION,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_CRC_PORTION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_CRC_PORTION,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PORTION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_DATA_PORTION,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_ENDPOINT_PORTION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_ENDPOINT_PORTION,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_ET_PORTION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_ET_PORTION,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_FRAME_PORTION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_FRAME_PORTION,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_HUB_ADDRESS_PORTION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_HUB_ADDRESS_PORTION,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_PID_CHECK_PORTION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_PID_CHECK_PORTION,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_PORT_PORTION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_PORT_PORTION,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_SC_PORTION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_SC_PORTION,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_SBUS_USB_TRIGGER_SEU_PORTION -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_SBUS_USB_TRIGGER_SEU_PORTION,
                                              SERIAL_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_FLOAT_ARB_WAVEFORM -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_FLOAT_ARB_WAVEFORM,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_DAC_ARB_WAVEFORM -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_DOWNLOAD_DAC_ARB_WAVEFORM,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_MATH_WINDOW_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_MATH_WINDOW_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_FUNCTION_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_FUNCTION_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_LOAD_IMPEDANCE_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WGEN_ARBITRARY_BYTEORDER_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WGEN_ARBITRARY_BYTEORDER_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_BUS_CLOCK_MULTICHANNEL-*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_BUS_CLOCK_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_BUS_SLOPE_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_BUS_SLOPE_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_BUS_YUNITS_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_BUS_YUNITS_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_TREND_MEASUREMENT_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_TREND_MEASUREMENT_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_VTYPE_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_VTYPE_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_WGEN_MODULATION_NOISE_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WGEN_MODULATION_NOISE_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_MATH_SCALE_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_MATH_SCALE_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_MATH_OFFSET_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_MATH_OFFSET_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_MATH_SPAN_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_MATH_SPAN_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_MATH_CENTER_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_MATH_CENTER_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_PERIOD_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_PERIOD_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_VOLTAGE_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_VOLTAGE_HIGH_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_VOLTAGE_LOW_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_VOLTAGE_OFFSET_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_FREQUENCY_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_FREQUENCY_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_PULSE_WIDTH_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_RAMP_SYMMETRY_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_SQUARE_DUTY_CYCLE_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_BUS_YINCREMENT_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_BUS_YINCREMENT_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_BUS_YORIGIN_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_BUS_YORIGIN_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_FREQ_HIGHPASS_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_FREQ_HIGHPASS_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_FREQ_LOWPASS_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_FREQ_LOWPASS_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_LINEAR_GAIN_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_LINEAR_GAIN_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_LINEAR_OFFSET_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_LINEAR_OFFSET_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_FUNCTION_INTEGRATE_IOFFSET_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_FUNCTION_INTEGRATE_IOFFSET_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_MATH_CHANNEL_ENABLED_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_MATH_CHANNEL_ENABLED_MULTICHANNEL,
                                              FUNCTION_CHANNELS));

        /*- AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_WAVEGEN_OUTPUT_ENABLE_MULTICHANNEL,
                                              WGEN_CHANNELS));

        /*- AGX2K3K_ATTR_INSTR_MATH_OPERATION_MULTICHANNEL -*/
        checkErr (Ivi_RestrictAttrToChannels (vi,
                                              AGX2K3K_ATTR_INSTR_MATH_OPERATION_MULTICHANNEL,
                                              FUNCTION_CHANNELS));
    }

Error:
    return error;
}

/*****************************************************************************
 *------------------- End Instrument Driver Source Code ---------------------*
 *****************************************************************************/
